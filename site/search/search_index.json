{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is it? Jumperless V5 lets you prototype like a nerdy wizard who can see electricity and conjure jumpers with a magic wand. It\u2019s an Integrated Development Environment (IDE) for hardware, with an analog-by-nature RP2350B-based dev board, a drawer full of wires, and a workbench full of test equipment (including a power supply, a multimeter, an oscilloscope, a function generator, and a logic analyzer) all crammed inside a breadboard. You can connect any point to any other using software-defined jumpers, so the four individually programmable \u00b18 V power supplies; ten GPIOs; and seven management channels for voltage, current, and resistance can all be connected anywhere on the breadboard or the Arduino Nano header. RGB LEDs under each hole turn the breadboard itself into a display that provides real-time information about whatever\u2019s happening in your circuit. These are the docs where you will learn how to use all this stuff If you don't already have one, Get a Jumperless V5 on Crowd Supply Getting Started Documentation Sections Basic Controls - Learn how to use the probe and click wheel The App - For talking to your Jumperless OLED - Add a better display Arduino - The reason for those headers at the top Configuration - Persistent settings Debugging - Crossbar, bridge, and net list views File Manager - Do stuff with the onboard file system MicroPython - Use the onboard MicroPython interpreter Odds and Ends - Stuff I couldn't think of a good category for 3D Printable Stand - Print your own stand Writing Native Apps - Dig into the actual firmware and write your own apps Glossary - Key terms and definitions (You should turn off Dark Reader for this site if you have it, it messes up the sidebar colors) Find Me On The Internet Join the Discord for pretty much instant answers to your questions file_handle = jfs . open ( 'temp.txt' , 'w' ) jfs . write ( file_handle , 'some data' ) jfs . close ( file_handle ) Functions for interacting with the physical probe. probe_read ([ blocking = True ]) Reads the pad currently being touched by the probe. blocking (optional): If True (default), the function will wait until a pad is touched. If False , it returns immediately. Returns a ProbePad object (e.g., 25 , D13_PAD , NO_PAD ). Aliases : read_probe () , probe_read_blocking () , probe_read_nonblocking () , probe_wait () , wait_probe () , probe_touch () , wait_touch () probe_button ([ blocking = True ]) Reads the state of the buttons on the probe. blocking (optional): If True (default), waits for a button press. If False , returns the current state immediately. Returns a ProbeButton object ( CONNECT_BUTTON , REMOVE_BUTTON , or BUTTON_NONE ). Aliases : get_button () , button_read () , read_button () , probe_button_blocking () , probe_button_nonblocking () , check_button () , button_check () Example: print ( \"Touch a pad...\" ) pad = probe_read () print ( \"You touched: \" + str ( pad )) if pad == D13_PAD : print ( \"That's the Arduino LED pin!\" ) print ( \"Press a probe button...\" ) button = get_button () if button == CONNECT_BUTTON : print ( \"Connect button pressed.\" )","title":"Home"},{"location":"#what-is-it","text":"Jumperless V5 lets you prototype like a nerdy wizard who can see electricity and conjure jumpers with a magic wand. It\u2019s an Integrated Development Environment (IDE) for hardware, with an analog-by-nature RP2350B-based dev board, a drawer full of wires, and a workbench full of test equipment (including a power supply, a multimeter, an oscilloscope, a function generator, and a logic analyzer) all crammed inside a breadboard. You can connect any point to any other using software-defined jumpers, so the four individually programmable \u00b18 V power supplies; ten GPIOs; and seven management channels for voltage, current, and resistance can all be connected anywhere on the breadboard or the Arduino Nano header. RGB LEDs under each hole turn the breadboard itself into a display that provides real-time information about whatever\u2019s happening in your circuit. These are the docs where you will learn how to use all this stuff If you don't already have one,","title":"What is it?"},{"location":"#get-a-jumperless-v5-on-crowd-supply","text":"","title":"Get a Jumperless V5 on Crowd Supply"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#documentation-sections","text":"Basic Controls - Learn how to use the probe and click wheel The App - For talking to your Jumperless OLED - Add a better display Arduino - The reason for those headers at the top Configuration - Persistent settings Debugging - Crossbar, bridge, and net list views File Manager - Do stuff with the onboard file system MicroPython - Use the onboard MicroPython interpreter Odds and Ends - Stuff I couldn't think of a good category for 3D Printable Stand - Print your own stand Writing Native Apps - Dig into the actual firmware and write your own apps Glossary - Key terms and definitions (You should turn off Dark Reader for this site if you have it, it messes up the sidebar colors)","title":"Documentation Sections"},{"location":"#find-me-on-the-internet","text":"Join the Discord for pretty much instant answers to your questions file_handle = jfs . open ( 'temp.txt' , 'w' ) jfs . write ( file_handle , 'some data' ) jfs . close ( file_handle ) Functions for interacting with the physical probe.","title":"Find Me On The Internet"},{"location":"#probe_readblockingtrue","text":"Reads the pad currently being touched by the probe. blocking (optional): If True (default), the function will wait until a pad is touched. If False , it returns immediately. Returns a ProbePad object (e.g., 25 , D13_PAD , NO_PAD ). Aliases : read_probe () , probe_read_blocking () , probe_read_nonblocking () , probe_wait () , wait_probe () , probe_touch () , wait_touch ()","title":"probe_read([blocking=True])"},{"location":"#probe_buttonblockingtrue","text":"Reads the state of the buttons on the probe. blocking (optional): If True (default), waits for a button press. If False , returns the current state immediately. Returns a ProbeButton object ( CONNECT_BUTTON , REMOVE_BUTTON , or BUTTON_NONE ). Aliases : get_button () , button_read () , read_button () , probe_button_blocking () , probe_button_nonblocking () , check_button () , button_check () Example: print ( \"Touch a pad...\" ) pad = probe_read () print ( \"You touched: \" + str ( pad )) if pad == D13_PAD : print ( \"That's the Arduino LED pin!\" ) print ( \"Press a probe button...\" ) button = get_button () if button == CONNECT_BUTTON : print ( \"Connect button pressed.\" )","title":"probe_button([blocking=True])"},{"location":"01-basic-controls/","text":"Basic Controls The Probe First, keep the switch on the probe set to Select Why Select mode? Measure mode allows the probe tip to be \u00b19V tolerant and routable like any other node, but as of yet, the code to actually do anything with it is unwritten so it just connects to DAC 0 and outputs 3.3V just like it was in Select mode. But the DAC is much worse at matching the RP2350B's idea of what 3.3V is exactly , so probing will be flaky and may be off from the rows you're tapping in Measure . Connecting Rows Click the Connect button on the probe The logo should turn blue and the LEDs on the probe should also change Now any pair of nodes you tap should get connected as you make them. In connect mode, you're creating bridges (see the glossary ), so connections are made in pairs. When you've tapped the first node in a pair, the logo and Connect text on the probe will brighten to show that you're \" holding \" a connection, and the next thing you tap will connect to that first node . If you make a mistake while holding a connection, click the Connect button and it will clear it and take you back to the first node . If you click the Connect button while you're not holding a node , it will leave probe mode and bring you back into idle mode (rainbowy logo , all 3 probe LED s on.) Special Functions To connect to special functions , tap the corresponding pad near the logo, it will show you a menu on the breadboard and terminal to choose them. (This is an ASCII version of what will show on the breadboard LEDs) And here's what the LEDs will show R in the main menu to toggle this view\" src=\"../assets/gpioSelection.png\" /> You can think of special functions just like any other node , the only difference is they're in a sort of \"folder\" so I didn't need to put a dedicated pad for each of them. DAC Pad \u2514\u2500 0 1 [ Tap pads below selection ] \u2514\u2500 - 8 V ! : . : ! + 8 V [ Tap bottom pads or use clickwheel to select a voltage ] > [ click probe Connect button to confirm ] \u2514\u2500 [ Tap a row to connect it to ] ( or if you were already \"holding\" a node , it 'll connect there) GPIO Pad \u2514\u2500 \u20711 \u2070 \u20712 \u2070 \u20713 \u2070 \u20714 \u2070 \u2081 5 \u2080 \u2081 6 \u2080 \u2081 7 \u2080 \u2081 8 \u2080 [ Tap pads to choose which ` GPIO ` ( left side for input , right side for output )] \u2514\u2500 [ Tap a row to connect it to ] ( or if you were already \"holding\" a node , it 'll connect there) The other 4 user pads will be more remappable in the future, but for now, top_guy is routable UART Tx and bottom_guy is routable UART Rx . The building pads are for overriding colors in idle mode (you'll see more about that in Idle Mode Interactions .) To get out of Connect mode, press the button again. Removing Rows Click the Remove button and the logo should turn reddish Now you can swipe along the pad s or tap them one at a time. Remember it only disconnects that node and anything connected to it directly, not everything on the net . So tapping say, row 25 that's connected to GND won't clear everything connected to GND , but tapping the - on the rails (for GND ) would. The special functions work the same way, tap the pad, pick one, and it will remove it. Click the button again to get out. Probe Notes Remember the probe is read by a resistive voltage divider , so putting your fingers on the pads (or the back sides of the 4 risers that connect those probe sense boards to the main board), or anything causing the probe tip not to be at a steady 3.3V will give you weird readings. If you can't seem to stop playing with the switch on the probe, run DAC calibration with $ and the 3.3V measure mode puts out should be fairly accurate enough for probing. The Click Wheel There are two kinds of presses, click (short press) and hold (long press). In general, a click (short) is a yes , and a hold (long) is a no / back / exit / whatever . When I say click , it's more of a diagonal slide toward the center of the board ( these encoders were meant to poke out just a little bit from the side of a tablet or whatever.) To get to the menu, click the button and scroll through the menus, click will bring you into that menu, hold will take you back one level. If you have trouble reading stuff on the breadboard LEDs, everything is copied to the Serial terminal and the OLED (talked about in OLED Section ), and adjusting the brightness may help; in the menus, it's Display Options > Bright > Menu and then scroll around until you find a level you like, then click to confirm. Idle Mode Net Highlighting The main thing is that there's a lot more interaction that can be done outside of any particular mode (like not probing and the logo is rainbowy, I'm gonna call this idle mode here until I think of a good name) Here's what's new (all of this is in idle mode): Basic Interactions Tapping nets highlights them as before, but there's a slightly different animation on the row you have selected from the whole net The click wheel scrolls through highlighting rows as if you tapped each one Row Selection Actions With a row selected, here's what you can do: Connect Button connect button will bring you into probing mode with the highlighted row already selected and then spit you back out to idle mode once you've made a connection to another row, or click connect again to exit Remove Button remove will briefly turn the row reddish warn (I need to settle on a good time for this, if it feels too short or long lmk), another remove press will remove that row (just like in probe mode, it removes the bridge it's in, so just things that have a direct connection to that row , not the whole net ), if you let it time out without pressing anything, the row will be unhighlighted. TL;DR, double click remove to remove, single click to unhighlight. Color Picker tapping the building top pad with something highlighted will open the color picker , (note: the color now follows the row instead of the net, so it can keep the colors even if you remove nets below it and they shift, this was soooo difficult until I realized I should do it by node ). Also the color assignments are saved to a file for each slot, so they should work after a reboot and when changing slots In the color picker , short clicking the probe buttons will zoom in and out, long press will confirm. The click wheel is similar, except you toggle zoom and scroll modes with short presses and long press to confirm Here's a demo on YouTube Measurement Display if the highlighted row is a measurement ( gpio input or adc ) it will print the state to serial and the oled Output Toggle if the highlighted row is an output ( gpio output , I'll eventually do dacs too) clicking the connect button will toggle it high / low . The remove button will just unhighlight the net (there were some choices here, like make each button assigned to high / low or allow removing them, but this felt like the best way after trying them all). I will eventually add a setting for the toggle repeat rate (set to 500ms now) and a way to set it freewheeling as a clock. this one feature is the reason I did this whole update. And it's worth it because it's sick af.","title":"Basic Controls"},{"location":"01-basic-controls/#basic-controls","text":"","title":"Basic Controls"},{"location":"01-basic-controls/#the-probe","text":"First, keep the switch on the probe set to Select Why Select mode? Measure mode allows the probe tip to be \u00b19V tolerant and routable like any other node, but as of yet, the code to actually do anything with it is unwritten so it just connects to DAC 0 and outputs 3.3V just like it was in Select mode. But the DAC is much worse at matching the RP2350B's idea of what 3.3V is exactly , so probing will be flaky and may be off from the rows you're tapping in Measure .","title":"The Probe"},{"location":"01-basic-controls/#connecting-rows","text":"Click the Connect button on the probe The logo should turn blue and the LEDs on the probe should also change Now any pair of nodes you tap should get connected as you make them. In connect mode, you're creating bridges (see the glossary ), so connections are made in pairs. When you've tapped the first node in a pair, the logo and Connect text on the probe will brighten to show that you're \" holding \" a connection, and the next thing you tap will connect to that first node . If you make a mistake while holding a connection, click the Connect button and it will clear it and take you back to the first node . If you click the Connect button while you're not holding a node , it will leave probe mode and bring you back into idle mode (rainbowy logo , all 3 probe LED s on.)","title":"Connecting Rows"},{"location":"01-basic-controls/#special-functions","text":"To connect to special functions , tap the corresponding pad near the logo, it will show you a menu on the breadboard and terminal to choose them. (This is an ASCII version of what will show on the breadboard LEDs) And here's what the LEDs will show R in the main menu to toggle this view\" src=\"../assets/gpioSelection.png\" /> You can think of special functions just like any other node , the only difference is they're in a sort of \"folder\" so I didn't need to put a dedicated pad for each of them. DAC Pad \u2514\u2500 0 1 [ Tap pads below selection ] \u2514\u2500 - 8 V ! : . : ! + 8 V [ Tap bottom pads or use clickwheel to select a voltage ] > [ click probe Connect button to confirm ] \u2514\u2500 [ Tap a row to connect it to ] ( or if you were already \"holding\" a node , it 'll connect there) GPIO Pad \u2514\u2500 \u20711 \u2070 \u20712 \u2070 \u20713 \u2070 \u20714 \u2070 \u2081 5 \u2080 \u2081 6 \u2080 \u2081 7 \u2080 \u2081 8 \u2080 [ Tap pads to choose which ` GPIO ` ( left side for input , right side for output )] \u2514\u2500 [ Tap a row to connect it to ] ( or if you were already \"holding\" a node , it 'll connect there) The other 4 user pads will be more remappable in the future, but for now, top_guy is routable UART Tx and bottom_guy is routable UART Rx . The building pads are for overriding colors in idle mode (you'll see more about that in Idle Mode Interactions .) To get out of Connect mode, press the button again.","title":"Special Functions"},{"location":"01-basic-controls/#removing-rows","text":"Click the Remove button and the logo should turn reddish Now you can swipe along the pad s or tap them one at a time. Remember it only disconnects that node and anything connected to it directly, not everything on the net . So tapping say, row 25 that's connected to GND won't clear everything connected to GND , but tapping the - on the rails (for GND ) would. The special functions work the same way, tap the pad, pick one, and it will remove it. Click the button again to get out.","title":"Removing Rows"},{"location":"01-basic-controls/#probe-notes","text":"Remember the probe is read by a resistive voltage divider , so putting your fingers on the pads (or the back sides of the 4 risers that connect those probe sense boards to the main board), or anything causing the probe tip not to be at a steady 3.3V will give you weird readings. If you can't seem to stop playing with the switch on the probe, run DAC calibration with $ and the 3.3V measure mode puts out should be fairly accurate enough for probing.","title":"Probe Notes"},{"location":"01-basic-controls/#the-click-wheel","text":"There are two kinds of presses, click (short press) and hold (long press). In general, a click (short) is a yes , and a hold (long) is a no / back / exit / whatever . When I say click , it's more of a diagonal slide toward the center of the board ( these encoders were meant to poke out just a little bit from the side of a tablet or whatever.) To get to the menu, click the button and scroll through the menus, click will bring you into that menu, hold will take you back one level. If you have trouble reading stuff on the breadboard LEDs, everything is copied to the Serial terminal and the OLED (talked about in OLED Section ), and adjusting the brightness may help; in the menus, it's Display Options > Bright > Menu and then scroll around until you find a level you like, then click to confirm.","title":"The Click Wheel"},{"location":"01-basic-controls/#idle-mode-net-highlighting","text":"The main thing is that there's a lot more interaction that can be done outside of any particular mode (like not probing and the logo is rainbowy, I'm gonna call this idle mode here until I think of a good name) Here's what's new (all of this is in idle mode):","title":"Idle Mode Net Highlighting"},{"location":"01-basic-controls/#basic-interactions","text":"Tapping nets highlights them as before, but there's a slightly different animation on the row you have selected from the whole net The click wheel scrolls through highlighting rows as if you tapped each one","title":"Basic Interactions"},{"location":"01-basic-controls/#row-selection-actions","text":"With a row selected, here's what you can do:","title":"Row Selection Actions"},{"location":"01-basic-controls/#connect-button","text":"connect button will bring you into probing mode with the highlighted row already selected and then spit you back out to idle mode once you've made a connection to another row, or click connect again to exit","title":"Connect Button"},{"location":"01-basic-controls/#remove-button","text":"remove will briefly turn the row reddish warn (I need to settle on a good time for this, if it feels too short or long lmk), another remove press will remove that row (just like in probe mode, it removes the bridge it's in, so just things that have a direct connection to that row , not the whole net ), if you let it time out without pressing anything, the row will be unhighlighted. TL;DR, double click remove to remove, single click to unhighlight.","title":"Remove Button"},{"location":"01-basic-controls/#color-picker","text":"tapping the building top pad with something highlighted will open the color picker , (note: the color now follows the row instead of the net, so it can keep the colors even if you remove nets below it and they shift, this was soooo difficult until I realized I should do it by node ). Also the color assignments are saved to a file for each slot, so they should work after a reboot and when changing slots In the color picker , short clicking the probe buttons will zoom in and out, long press will confirm. The click wheel is similar, except you toggle zoom and scroll modes with short presses and long press to confirm Here's a demo on YouTube","title":"Color Picker"},{"location":"01-basic-controls/#measurement-display","text":"if the highlighted row is a measurement ( gpio input or adc ) it will print the state to serial and the oled","title":"Measurement Display"},{"location":"01-basic-controls/#output-toggle","text":"if the highlighted row is an output ( gpio output , I'll eventually do dacs too) clicking the connect button will toggle it high / low . The remove button will just unhighlight the net (there were some choices here, like make each button assigned to high / low or allow removing them, but this felt like the best way after trying them all). I will eventually add a setting for the toggle repeat rate (set to 500ms now) and a way to set it freewheeling as a clock. this one feature is the reason I did this whole update. And it's worth it because it's sick af.","title":"Output Toggle"},{"location":"03-app/","text":"The App Installation guide Find the latest release https://github.com/Architeuthis-Flux/JumperlessV5/releases/latest The link above will magically lead you to the latest version, and will look something like https : // github . com / Architeuthis - Flux / JumperlessV5 / releases / tag / 5.2.0.0 At the bottom under Assets, download the Jumperless App for your OS Windows Jumperless . exe Jumperless - Windows - x64 . zip macOS Jumperless_Installer . dmg Jumperless_macOS . zip Linux x86 Jumperless - linux - x86_64 . tar . gz (if you're not sure which flavor of Linux, use this one) arm64 Jumperless - linux - arm64 . tar . gz Python download JumperlessWokwiBridge . py and requirements . txt open your favorite terminal, navigate to the folder where you downloaded the two files above. pip install - r requirements . txt # run this command to install the needed Python libraries python3 JumperlessWokwiBridge . py # open the app, will update firmware if there's a newer version Now that I've lifted my self-imposed ban on VT100 commands (for compatibility and me-spending-too-much-time-on-them reasons, but, YOLO), we've got colors now! But that's like the least cool thing the new app can do, here's a list of what's new: What It Does Firmware updating should be pretty reliable when there's a new version (falls back to instructions for how to do it manually) Command history and tab completion , up arrows will go through past commands and are persistent after closing Properly detects which port is the main Jumperless Serial and which is routable UART Arduino flashing from Wokwi works once again and is a lot more solid It installs arduino-cli on first startup and uses it pull in libraries, compile, and flash an arduino Nano in the header If the routable UART lines aren't connected when the app detects a change in the sketch file, it will connect them to flash the new code and then return them to how they were avrdude output is shown in real time (you'd be amazed how difficult this was) No longer a janky pile of garbage Local Arduino Sketch Support You can set a slot to point to a local Arduino sketch.ino file and it will flash if it detects a change If you don't like using Arduino IDE or Wokwi and prefer using vim or emacs or whatever, now you can let the app handle the flashing stuff and just edit an .ino file. In the app, type menu then slots and instead of entering a link to a Wokwi project, just give it a path to a file (this will be saved so you can unassign it and pick it later by name) (This one is so fucking sick) Launch Scripts Launch scripts included to easily run it from your favorite terminal emulator and not just the system default (terminal.app on macOS, Powershell on Windows, idk on Linux), just go to the directory in a terminal and run the script in tabby or whatever The launcher should kill other instances (and close their windows) that happen to be open because it's such a common issue for me at least Linux people are no longer red-headed stepchildren, there are proper tar.gz packages now for you nerds Terminal Compatibility Or you can use any terminal emulator you like, iTerm2 , xTerm , Tabby , Arduino IDE 's Serial Monitor, whatever. The TUI is all handled from the Jumperless itself so it just needs something to print text.","title":"The App"},{"location":"03-app/#the-app","text":"","title":"The App"},{"location":"03-app/#installation-guide","text":"","title":"Installation guide"},{"location":"03-app/#find-the-latest-release","text":"https://github.com/Architeuthis-Flux/JumperlessV5/releases/latest The link above will magically lead you to the latest version, and will look something like https : // github . com / Architeuthis - Flux / JumperlessV5 / releases / tag / 5.2.0.0 At the bottom under Assets, download the Jumperless App for your OS","title":"Find the latest release"},{"location":"03-app/#windows","text":"Jumperless . exe Jumperless - Windows - x64 . zip","title":"Windows"},{"location":"03-app/#macos","text":"Jumperless_Installer . dmg Jumperless_macOS . zip","title":"macOS"},{"location":"03-app/#linux","text":"x86 Jumperless - linux - x86_64 . tar . gz (if you're not sure which flavor of Linux, use this one) arm64 Jumperless - linux - arm64 . tar . gz","title":"Linux"},{"location":"03-app/#python","text":"download JumperlessWokwiBridge . py and requirements . txt open your favorite terminal, navigate to the folder where you downloaded the two files above. pip install - r requirements . txt # run this command to install the needed Python libraries python3 JumperlessWokwiBridge . py # open the app, will update firmware if there's a newer version Now that I've lifted my self-imposed ban on VT100 commands (for compatibility and me-spending-too-much-time-on-them reasons, but, YOLO), we've got colors now! But that's like the least cool thing the new app can do, here's a list of what's new:","title":"Python"},{"location":"03-app/#what-it-does","text":"Firmware updating should be pretty reliable when there's a new version (falls back to instructions for how to do it manually) Command history and tab completion , up arrows will go through past commands and are persistent after closing Properly detects which port is the main Jumperless Serial and which is routable UART Arduino flashing from Wokwi works once again and is a lot more solid It installs arduino-cli on first startup and uses it pull in libraries, compile, and flash an arduino Nano in the header If the routable UART lines aren't connected when the app detects a change in the sketch file, it will connect them to flash the new code and then return them to how they were avrdude output is shown in real time (you'd be amazed how difficult this was) No longer a janky pile of garbage","title":"What It Does"},{"location":"03-app/#local-arduino-sketch-support","text":"You can set a slot to point to a local Arduino sketch.ino file and it will flash if it detects a change If you don't like using Arduino IDE or Wokwi and prefer using vim or emacs or whatever, now you can let the app handle the flashing stuff and just edit an .ino file. In the app, type menu then slots and instead of entering a link to a Wokwi project, just give it a path to a file (this will be saved so you can unassign it and pick it later by name) (This one is so fucking sick)","title":"Local Arduino Sketch Support"},{"location":"03-app/#launch-scripts","text":"Launch scripts included to easily run it from your favorite terminal emulator and not just the system default (terminal.app on macOS, Powershell on Windows, idk on Linux), just go to the directory in a terminal and run the script in tabby or whatever The launcher should kill other instances (and close their windows) that happen to be open because it's such a common issue for me at least Linux people are no longer red-headed stepchildren, there are proper tar.gz packages now for you nerds","title":"Launch Scripts"},{"location":"03-app/#terminal-compatibility","text":"Or you can use any terminal emulator you like, iTerm2 , xTerm , Tabby , Arduino IDE 's Serial Monitor, whatever. The TUI is all handled from the Jumperless itself so it just needs something to print text.","title":"Terminal Compatibility"},{"location":"04-oled/","text":"OLED Support First, get yourself one of these bad boys (literally any of these are fine.) https://www.amazon.com/MakerFocus-Display-SSD1306-3-3V-5V-Arduino/dp/B079BN2J8V Ignore the really cool LEDs. Installation They should friction fit into the SBC/SMD/OLED board included with your Jumperless V5. Functionality This should copy basically any text printed on the breadboard, some people have trouble reading text on the breadboard LEDs, which is why I added all this. (if I missed something, let me know, it's a fairly new thing so I've probably forgot to add code for it to print in a bunch of places.) Connection To connect the data lines to the Jumperless' GPIO 7 and 8, just use the menu option . (that's a period). It will try to find the OLED on the I2C bus, after a few failed attempts, it'll automatically disconnect to free up GPIO 7 and 8. Auto-Connect on Boot If you want to use this all the time, there's a config option to connect the OLED on startup. You can just paste this into the main menu: ` [ top_oled ] connect_on_boot = true ;","title":"OLED Support"},{"location":"04-oled/#oled-support","text":"First, get yourself one of these bad boys (literally any of these are fine.) https://www.amazon.com/MakerFocus-Display-SSD1306-3-3V-5V-Arduino/dp/B079BN2J8V Ignore the really cool LEDs.","title":"OLED Support"},{"location":"04-oled/#installation","text":"They should friction fit into the SBC/SMD/OLED board included with your Jumperless V5.","title":"Installation"},{"location":"04-oled/#functionality","text":"This should copy basically any text printed on the breadboard, some people have trouble reading text on the breadboard LEDs, which is why I added all this. (if I missed something, let me know, it's a fairly new thing so I've probably forgot to add code for it to print in a bunch of places.)","title":"Functionality"},{"location":"04-oled/#connection","text":"To connect the data lines to the Jumperless' GPIO 7 and 8, just use the menu option . (that's a period). It will try to find the OLED on the I2C bus, after a few failed attempts, it'll automatically disconnect to free up GPIO 7 and 8.","title":"Connection"},{"location":"04-oled/#auto-connect-on-boot","text":"If you want to use this all the time, there's a config option to connect the OLED on startup. You can just paste this into the main menu: ` [ top_oled ] connect_on_boot = true ;","title":"Auto-Connect on Boot"},{"location":"05-arduino/","text":"Arduino Stuff UART Passthrough With an Arduino Nano in the header and the UART lines connected, anything on those lines should be passed through to the second serial port that shows up when you plug in your Jumperless. (You can also set the config option ` [ serial_1 ] print_passthrough = true ; and have it print on both. Don't worry about the baud rate, the Jumperless senses what the host computer is set to and changes the speed accordingly. Quick Connection Shortcuts The shortcuts to connect D0 and D1 to the Jumperless's UART Tx and Rx is A to connect, and a to disconnect. Automatic Flashing It will even sense when Arduino IDE is trying to upload code and twiddle the reset lines to allow you to flash code with just a single USB cable going to your Jumperless. Commands from Routable UART Starting a UART message (that would normally just be passed through to the second serial port) with 0x02 ( non-printable ASCII code for Start of Text / STX ) and ending with 0x03 ( End of Text / ETX ) will cause the Jumperless to interpret that as something that was sent though the menu on the main serial port. So you can send commands to make connections and such while also using serial passthrough.","title":"Arduino Stuff"},{"location":"05-arduino/#arduino-stuff","text":"","title":"Arduino Stuff"},{"location":"05-arduino/#uart-passthrough","text":"With an Arduino Nano in the header and the UART lines connected, anything on those lines should be passed through to the second serial port that shows up when you plug in your Jumperless. (You can also set the config option ` [ serial_1 ] print_passthrough = true ; and have it print on both. Don't worry about the baud rate, the Jumperless senses what the host computer is set to and changes the speed accordingly.","title":"UART Passthrough"},{"location":"05-arduino/#quick-connection-shortcuts","text":"The shortcuts to connect D0 and D1 to the Jumperless's UART Tx and Rx is A to connect, and a to disconnect.","title":"Quick Connection Shortcuts"},{"location":"05-arduino/#automatic-flashing","text":"It will even sense when Arduino IDE is trying to upload code and twiddle the reset lines to allow you to flash code with just a single USB cable going to your Jumperless.","title":"Automatic Flashing"},{"location":"05-arduino/#commands-from-routable-uart","text":"Starting a UART message (that would normally just be passed through to the second serial port) with 0x02 ( non-printable ASCII code for Start of Text / STX ) and ending with 0x03 ( End of Text / ETX ) will cause the Jumperless to interpret that as something that was sent though the menu on the main serial port. So you can send commands to make connections and such while also using serial passthrough.","title":"Commands from Routable UART"},{"location":"06-config/","text":"Config File To change any persistent settings, there's a config file. You can read it with ~ and edit settings by copying any of those lines, pasting it back, and changing the value to whatever you want it to be. Viewing Configuration ~ copy / edit / paste any of these lines into the main menu to change a setting Jumperless Config : ` [ config ] firmware_version = 5.2.2.0 ; ` [ hardware ] generation = 5 ; ` [ hardware ] revision = 5 ; ` [ hardware ] probe_revision = 5 ; ` [ dacs ] top_rail = 3.50 ; ` [ dacs ] bottom_rail = 3.50 ; ` [ dacs ] dac_0 = 3.33 ; ` [ dacs ] dac_1 = 0.00 ; ` [ dacs ] set_dacs_on_boot = false ; ` [ dacs ] set_rails_on_boot = true ; ` [ dacs ] probe_power_dac = 0 ; ` [ dacs ] limit_max = 8.00 ; ` [ dacs ] limit_min = - 8.00 ; ` [ debug ] file_parsing = false ; ` [ debug ] net_manager = false ; ` [ debug ] nets_to_chips = false ; ` [ debug ] nets_to_chips_alt = false ; ` [ debug ] leds = false ; ` [ routing ] stack_paths = 2 ; ` [ routing ] stack_rails = 3 ; ` [ routing ] stack_dacs = 0 ; ` [ routing ] rail_priority = 1 ; ` [ calibration ] top_rail_zero = 1650 ; ` [ calibration ] top_rail_spread = 21.50 ; ` [ calibration ] bottom_rail_zero = 1650 ; ` [ calibration ] bottom_rail_spread = 21.50 ; ` [ calibration ] dac_0_zero = 1650 ; ` [ calibration ] dac_0_spread = 21.50 ; ` [ calibration ] dac_1_zero = 1650 ; ` [ calibration ] dac_1_spread = 21.50 ; ` [ calibration ] adc_0_zero = 9.00 ; ` [ calibration ] adc_0_spread = 18.28 ; ` [ calibration ] adc_1_zero = 9.00 ; ` [ calibration ] adc_1_spread = 18.28 ; ` [ calibration ] adc_2_zero = 9.00 ; ` [ calibration ] adc_2_spread = 18.28 ; ` [ calibration ] adc_3_zero = 9.00 ; ` [ calibration ] adc_3_spread = 18.28 ; ` [ calibration ] adc_4_zero = 0.00 ; ` [ calibration ] adc_4_spread = 5.00 ; ` [ calibration ] adc_7_zero = 9.00 ; ` [ calibration ] adc_7_spread = 18.28 ; ` [ calibration ] probe_max = 4060 ; ` [ calibration ] probe_min = 12 ; ` [ logo_pads ] top_guy = uart_tx ; ` [ logo_pads ] bottom_guy = uart_rx ; ` [ logo_pads ] building_pad_top = off ; ` [ logo_pads ] building_pad_bottom = off ; ` [ display ] lines_wires = wires ; ` [ display ] menu_brightness = - 10 ; ` [ display ] led_brightness = 10 ; ` [ display ] rail_brightness = 55 ; ` [ display ] special_net_brightness = 20 ; ` [ display ] net_color_mode = rainbow ; ` [ display ] dump_leds = ; ` [ display ] dump_format = image ; ` [ gpio ] direction = 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 ; ` [ gpio ] pulls = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 ; ` [ gpio ] uart_tx_function = uart_tx ; ` [ gpio ] uart_rx_function = uart_rx ; ` [ serial_1 ] function = passthrough ; ` [ serial_1 ] baud_rate = 115200 ; ` [ serial_1 ] print_passthrough = false ; ` [ serial_1 ] connect_on_boot = false ; ` [ serial_1 ] lock_connection = false ; ` [ serial_1 ] autoconnect_flashing = true ; ` [ serial_2 ] function = off ; ` [ serial_2 ] baud_rate = 115200 ; ` [ serial_2 ] print_passthrough = false ; ` [ serial_2 ] connect_on_boot = false ; ` [ serial_2 ] lock_connection = false ; ` [ serial_2 ] autoconnect_flashing = false ; ` [ top_oled ] enabled = false ; ` [ top_oled ] i2c_address = 0x3C ; ` [ top_oled ] width = 128 ; ` [ top_oled ] height = 32 ; ` [ top_oled ] sda_pin = 26 ; ` [ top_oled ] scl_pin = 27 ; ` [ top_oled ] gpio_sda = GP_7 ; ` [ top_oled ] gpio_scl = GP_8 ; ` [ top_oled ] sda_row = D2 ; ` [ top_oled ] scl_row = D3 ; ` [ top_oled ] connect_on_boot = false ; ` [ top_oled ] lock_connection = false ; ` [ top_oled ] show_in_terminal = false ; ` [ top_oled ] font = jokerman ; END Configuration Help There's also a help you can get to by entering ~ ? ~? Help for command : ~ Read config ~ = show current config ~ names = show names for settings ~ numbers = show numbers for settings ~ [ section ] = show specific section ( e . g . ~ [ routing ]) Write config ` [ section ] setting = value ; = enter config settings ( pro tip : copy / paste setting from ~ output and just change the value ) Reset config ` reset = reset to defaults ( keeps calibration and hardware version ) ` reset_hardware = reset hardware settings ( keeps calibration ) ` reset_calibration = reset calibration settings ( keeps hardware version ) ` reset_all = reset to defaults and clear all settings ` force_first_start = clears everything to factory settings and runs first startup calibration Help ~? = show this help","title":"Config File"},{"location":"06-config/#config-file","text":"To change any persistent settings, there's a config file. You can read it with ~ and edit settings by copying any of those lines, pasting it back, and changing the value to whatever you want it to be.","title":"Config File"},{"location":"06-config/#viewing-configuration","text":"~ copy / edit / paste any of these lines into the main menu to change a setting Jumperless Config : ` [ config ] firmware_version = 5.2.2.0 ; ` [ hardware ] generation = 5 ; ` [ hardware ] revision = 5 ; ` [ hardware ] probe_revision = 5 ; ` [ dacs ] top_rail = 3.50 ; ` [ dacs ] bottom_rail = 3.50 ; ` [ dacs ] dac_0 = 3.33 ; ` [ dacs ] dac_1 = 0.00 ; ` [ dacs ] set_dacs_on_boot = false ; ` [ dacs ] set_rails_on_boot = true ; ` [ dacs ] probe_power_dac = 0 ; ` [ dacs ] limit_max = 8.00 ; ` [ dacs ] limit_min = - 8.00 ; ` [ debug ] file_parsing = false ; ` [ debug ] net_manager = false ; ` [ debug ] nets_to_chips = false ; ` [ debug ] nets_to_chips_alt = false ; ` [ debug ] leds = false ; ` [ routing ] stack_paths = 2 ; ` [ routing ] stack_rails = 3 ; ` [ routing ] stack_dacs = 0 ; ` [ routing ] rail_priority = 1 ; ` [ calibration ] top_rail_zero = 1650 ; ` [ calibration ] top_rail_spread = 21.50 ; ` [ calibration ] bottom_rail_zero = 1650 ; ` [ calibration ] bottom_rail_spread = 21.50 ; ` [ calibration ] dac_0_zero = 1650 ; ` [ calibration ] dac_0_spread = 21.50 ; ` [ calibration ] dac_1_zero = 1650 ; ` [ calibration ] dac_1_spread = 21.50 ; ` [ calibration ] adc_0_zero = 9.00 ; ` [ calibration ] adc_0_spread = 18.28 ; ` [ calibration ] adc_1_zero = 9.00 ; ` [ calibration ] adc_1_spread = 18.28 ; ` [ calibration ] adc_2_zero = 9.00 ; ` [ calibration ] adc_2_spread = 18.28 ; ` [ calibration ] adc_3_zero = 9.00 ; ` [ calibration ] adc_3_spread = 18.28 ; ` [ calibration ] adc_4_zero = 0.00 ; ` [ calibration ] adc_4_spread = 5.00 ; ` [ calibration ] adc_7_zero = 9.00 ; ` [ calibration ] adc_7_spread = 18.28 ; ` [ calibration ] probe_max = 4060 ; ` [ calibration ] probe_min = 12 ; ` [ logo_pads ] top_guy = uart_tx ; ` [ logo_pads ] bottom_guy = uart_rx ; ` [ logo_pads ] building_pad_top = off ; ` [ logo_pads ] building_pad_bottom = off ; ` [ display ] lines_wires = wires ; ` [ display ] menu_brightness = - 10 ; ` [ display ] led_brightness = 10 ; ` [ display ] rail_brightness = 55 ; ` [ display ] special_net_brightness = 20 ; ` [ display ] net_color_mode = rainbow ; ` [ display ] dump_leds = ; ` [ display ] dump_format = image ; ` [ gpio ] direction = 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 ; ` [ gpio ] pulls = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 ; ` [ gpio ] uart_tx_function = uart_tx ; ` [ gpio ] uart_rx_function = uart_rx ; ` [ serial_1 ] function = passthrough ; ` [ serial_1 ] baud_rate = 115200 ; ` [ serial_1 ] print_passthrough = false ; ` [ serial_1 ] connect_on_boot = false ; ` [ serial_1 ] lock_connection = false ; ` [ serial_1 ] autoconnect_flashing = true ; ` [ serial_2 ] function = off ; ` [ serial_2 ] baud_rate = 115200 ; ` [ serial_2 ] print_passthrough = false ; ` [ serial_2 ] connect_on_boot = false ; ` [ serial_2 ] lock_connection = false ; ` [ serial_2 ] autoconnect_flashing = false ; ` [ top_oled ] enabled = false ; ` [ top_oled ] i2c_address = 0x3C ; ` [ top_oled ] width = 128 ; ` [ top_oled ] height = 32 ; ` [ top_oled ] sda_pin = 26 ; ` [ top_oled ] scl_pin = 27 ; ` [ top_oled ] gpio_sda = GP_7 ; ` [ top_oled ] gpio_scl = GP_8 ; ` [ top_oled ] sda_row = D2 ; ` [ top_oled ] scl_row = D3 ; ` [ top_oled ] connect_on_boot = false ; ` [ top_oled ] lock_connection = false ; ` [ top_oled ] show_in_terminal = false ; ` [ top_oled ] font = jokerman ; END","title":"Viewing Configuration"},{"location":"06-config/#configuration-help","text":"There's also a help you can get to by entering ~ ? ~? Help for command : ~ Read config ~ = show current config ~ names = show names for settings ~ numbers = show numbers for settings ~ [ section ] = show specific section ( e . g . ~ [ routing ]) Write config ` [ section ] setting = value ; = enter config settings ( pro tip : copy / paste setting from ~ output and just change the value ) Reset config ` reset = reset to defaults ( keeps calibration and hardware version ) ` reset_hardware = reset hardware settings ( keeps calibration ) ` reset_calibration = reset calibration settings ( keeps hardware version ) ` reset_all = reset to defaults and clear all settings ` force_first_start = clears everything to factory settings and runs first startup calibration Help ~? = show this help","title":"Configuration Help"},{"location":"07-debugging/","text":"Debug Views Look Inside your Jumperless Crossbar Array There's a new way to see what the 12 analog crossbar switches are up to, just enter c in the menu Analog Crossbar Array chip A chip B chip C chip D 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 \u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AI 0 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AB0 0 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500 AC0 0 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 AD0 1 \u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AJ 1 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AB1 1 \u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500 AC1 1 . \u2502 . . \u2502 . \u2502 . AD1 2 \u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AB0 2 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500 BI 2 \u2502 \u2502 . . \u2502 . \u2502 . BC0 2 . \u2502 . . \u2502 . \u2502 . BD0 3 \u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500 AB1 3 . \u2502 \u2502 . . . . \u2502 BJ 3 \u2502 \u2502 . . \u2502 . \u2502 . BC1 3 . \u2502 . . \u2502 . \u2502 . BD1 4 \u2502 . . . \u2502 . . \u2502 AC0 4 . \u2502 \u2502 . . . . \u2502 BC0 4 \u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 CI 4 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 CD0 5 \u2502 . . . \u2502 . . \u2502 AC1 5 . \u2502 \u2502 . . . . \u2502 BC1 5 \u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 CJ 5 . \u2502 . . \u2502 . \u2502 . CD1 6 \u2502 . . . \u2502 . . \u2502 AD0 6 . \u2502 \u2502 . . . . \u2502 BD0 6 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 CD0 6 . \u2502 . . \u2502 . \u2502 . DI 7 \u2502 . . . \u2502 . . \u2502 AD1 7 . \u2502 \u2502 . . . . \u2502 BD1 7 \u2502 \u2502 . . \u2502 . \u2502 . CD1 7 . \u2502 . . \u2502 . \u2502 . DJ 8 \u2502 . . . \u2502 . . \u2502 AE0 8 . \u2502 \u2502 . . . . \u2502 BE0 8 \u2502 \u2502 . . \u2502 . \u2502 . CE0 8 . \u2502 . . \u2502 . \u2502 . DE0 9 \u2502 . . . \u2502 . . \u2502 AK 9 . \u2502 \u2502 . . . . \u2502 BE1 9 \u2502 \u2502 . . \u2502 . \u2502 . CL 9 . \u2502 . . \u2502 . \u2502 . DE1 10 \u2502 . . . \u2502 . . \u2502 AF0 10 . \u2502 \u2502 . . . . \u2502 BF0 10 \u2502 \u2502 . . \u2502 . \u2502 . CF0 10 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500 DF0 11 \u2502 . . . \u2502 . . \u2502 AF1 11 . \u2502 \u2502 . . . . \u2502 BK 11 \u2502 \u2502 . . \u2502 . \u2502 . CF1 11 . \u2502 . . \u2502 . \u2502 . DL 12 \u2502 . . . \u2502 . . \u2502 AG0 12 . \u2502 \u2502 . . . . \u2502 BG0 12 \u2502 \u2502 . . \u2502 . \u2502 . CG0 12 . \u2502 . . \u2502 . \u2502 . DG0 13 \u2502 . . . \u2502 . . \u2502 AL 13 . \u2502 \u2502 . . . . \u2502 BG1 13 \u2502 \u2502 . . \u2502 . \u2502 . CK 13 . \u2502 . . \u2502 . \u2502 . DK 14 \u2502 . . . \u2502 . . \u2502 AH0 14 . \u2502 \u2502 . . . . \u2502 BH0 14 \u2502 \u2502 . . \u2502 . \u2502 . CH0 14 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 DH0 15 \u2502 . . . \u2502 . . \u2502 AH1 15 . \u2502 \u2502 . . . . \u2502 BL 15 \u2502 \u2502 . . \u2502 . \u2502 . CH1 15 . \u2502 . . \u2502 . \u2502 . DH1 u 1 2 3 4 5 6 7 u 8 9 10 11 12 13 14 u 15 16 17 18 19 20 21 u 22 23 24 25 26 27 28 chip E chip F chip G chip H 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500 AE0 0 . . . \u2502 . \u2502 . . AF0 0 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500 AG0 0 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AH0 1 . . . . \u2502 . \u2502 . EK 1 . . . \u2502 . \u2502 . . AF1 1 . \u2502 . . . \u2502 . . GL 1 . \u2502 . \u2502 . . . \u2502 AH1 2 . . . . \u2502 . \u2502 . BE0 2 . . . \u2502 . \u2502 . . BF0 2 . \u2502 . . . \u2502 . . BG0 2 . \u2502 . \u2502 . . . \u2502 BH0 3 . . . . \u2502 . \u2502 . BE1 3 . . . \u2502 . \u2502 . . FK 3 . \u2502 . . . \u2502 . . BG1 3 . \u2502 . \u2502 . . . \u2502 HL 4 . . . . \u2502 . \u2502 . CE0 4 . . . \u2502 . \u2502 . . CF0 4 . \u2502 . . . \u2502 . . CG0 4 . \u2502 . \u2502 . . . \u2502 CH0 5 . . . . \u2502 . \u2502 . EL 5 . . . \u2502 . \u2502 . . CF1 5 . \u2502 . . . \u2502 . . GK 5 . \u2502 . \u2502 . . . \u2502 CH1 6 . . . . \u2502 . \u2502 . DE0 6 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500 DF0 6 . \u2502 . . . \u2502 . . DG0 6 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500 DH0 7 . . . . \u2502 . \u2502 . DE1 7 . . . \u2502 . \u2502 . . FL 7 . \u2502 . . . \u2502 . . DG1 7 . \u2502 . \u2502 . . . \u2502 HK 8 . . . . \u2502 . \u2502 . EI 8 . . . \u2502 . \u2502 . . EF0 8 . \u2502 . . . \u2502 . . EG0 8 . \u2502 . \u2502 . . . \u2502 EH0 9 . . . . \u2502 . \u2502 . EJ 9 . . . \u2502 . \u2502 . . EF1 9 . \u2502 . . . \u2502 . . EG1 9 . \u2502 . \u2502 . . . \u2502 EH1 10 . . . . \u2502 . \u2502 . EF0 10 . . . \u2502 . \u2502 . . FI 10 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500 FG0 10 . \u2502 . \u2502 . . . \u2502 FH0 11 . . . . \u2502 . \u2502 . EF1 11 . . . \u2502 . \u2502 . . FJ 11 . \u2502 . . . \u2502 . . FG1 11 . \u2502 . \u2502 . . . \u2502 FH1 12 . . . . \u2502 . \u2502 . EG0 12 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 FG0 12 . \u2502 . . . \u2502 . . GI 12 . \u2502 . \u2502 . . . \u2502 GH0 13 . . . . \u2502 . \u2502 . EG1 13 . . . \u2502 . \u2502 . . FG1 13 . \u2502 . . . \u2502 . . GJ 13 . \u2502 . \u2502 . . . \u2502 GH1 14 . . . . \u2502 . \u2502 . EH0 14 . . . \u2502 . \u2502 . . FH0 14 . \u2502 . . . \u2502 . . GH0 14 . \u2502 . \u2502 . . . \u2502 HI 15 . . . . \u2502 . \u2502 . EH1 15 . . . \u2502 . \u2502 . . FH1 15 . \u2502 . . . \u2502 . . GH1 15 . \u2502 . \u2502 . . . \u2502 HJ u 31 32 33 34 35 36 37 u 38 39 40 41 42 43 44 u 45 46 47 48 49 50 51 u 52 53 54 55 56 57 58 chip I chip J chip K chip L 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA0 0 \u2502 \u2502 \u2502 . . . . . nD0 0 \u2502 . . . . . . . 29 0 . . . . . . . . 30 1 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nD1 1 \u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA1 1 \u2502 . . . . . . . 59 1 . . . . . . . . 60 2 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nA2 2 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nD2 2 \u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 BFi 2 . . . . . . . . BFo 3 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nD3 3 \u2502 \u2502 \u2502 . . . . . nA3 3 \u2502 . . . . . . . ARF 3 . . . . . . . . 5 V 4 \u2500\u2588\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA4 4 \u2502 \u2502 \u2502 . . . . . nD4 4 \u2502 . . . . . . . TRl 4 . . . . . . . . GP1 5 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nD5 5 \u2500\u2588\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA5 5 \u2502 . . . . . . . BRl 5 . . . . . . . . GP2 6 \u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA6 6 \u2502 \u2502 \u2502 . . . . . nD6 6 \u2502 . . . . . . . Da1 6 . . . . . . . . GP3 7 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nD7 7 \u2502 \u2502 \u2502 . . . . . nA7 7 \u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Da0 7 . . . . . . . . GP4 8 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nD1 8 \u2502 \u2502 \u2502 . . . . . nD8 8 \u2502 . . . . . . . Ad0 8 . . . . . . . . GP5 9 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nD9 9 \u2502 \u2502 \u2502 . . . . . nD1 9 \u2502 . . . . . . . Ad1 9 . . . . . . . . GP6 10 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nD1 10 \u2502 \u2502 \u2502 . . . . . nD1 10 \u2502 . . . . . . . Ad2 10 . . . . . . . . GP7 11 \u2502 \u2502 \u2502 \u2502 \u2502 . . . I + 11 \u2502 \u2502 \u2502 . . . . . I - 11 \u2502 . . . . . . . Ad3 11 . . . . . . . . GP8 12 \u2502 \u2502 \u2502 \u2502 \u2502 . . . IL 12 \u2502 \u2502 \u2502 . . . . . JL 12 \u2502 . . . . . . . KL 12 . . . . . . . . LI 13 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 IJ 13 \u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 IJ 13 \u2502 . . . . . . . KI 13 . . . . . . . . LJ 14 \u2502 \u2502 \u2502 \u2502 \u2502 . . . IK 14 \u2502 \u2502 \u2502 . . . . . JK 14 \u2502 . . . . . . . KJ 14 . . . . . . . . LK 15 \u2502 \u2502 \u2502 \u2502 \u2502 . . . uRX 15 \u2502 \u2502 \u2502 . . . . . uTX 15 \u2502 . . . . . . . GND 15 . . . . . . . . GND AI BI CI DI EI FI GI HI AJ BJ CJ DJ EJ FJ GJ HJ AK BK CK DK EK FK GK HK AL BL CL DL EL FL GL HL Bridge Array Enter b in the menu. This is generally the most helpful one for me to troubleshoot what's going on if your issue has anything to do with routing or connections. It probably looks like nonsense to you but I've been in it so long it makes perfect sense to me. Net List Enter n in the menu to show this one. If you have anything that's doing any measurement ( gpio input or ADC s), it'll stay up and live update if any of them change. (And just like basically any menu not asking for input, entering anything will bring you back to the main menu.)","title":"Debug Views"},{"location":"07-debugging/#debug-views","text":"Look Inside your Jumperless","title":"Debug Views"},{"location":"07-debugging/#crossbar-array","text":"There's a new way to see what the 12 analog crossbar switches are up to, just enter c in the menu Analog Crossbar Array chip A chip B chip C chip D 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 \u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AI 0 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AB0 0 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500 AC0 0 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 AD0 1 \u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AJ 1 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AB1 1 \u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500 AC1 1 . \u2502 . . \u2502 . \u2502 . AD1 2 \u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AB0 2 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500 BI 2 \u2502 \u2502 . . \u2502 . \u2502 . BC0 2 . \u2502 . . \u2502 . \u2502 . BD0 3 \u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500 AB1 3 . \u2502 \u2502 . . . . \u2502 BJ 3 \u2502 \u2502 . . \u2502 . \u2502 . BC1 3 . \u2502 . . \u2502 . \u2502 . BD1 4 \u2502 . . . \u2502 . . \u2502 AC0 4 . \u2502 \u2502 . . . . \u2502 BC0 4 \u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 CI 4 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 CD0 5 \u2502 . . . \u2502 . . \u2502 AC1 5 . \u2502 \u2502 . . . . \u2502 BC1 5 \u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 CJ 5 . \u2502 . . \u2502 . \u2502 . CD1 6 \u2502 . . . \u2502 . . \u2502 AD0 6 . \u2502 \u2502 . . . . \u2502 BD0 6 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 CD0 6 . \u2502 . . \u2502 . \u2502 . DI 7 \u2502 . . . \u2502 . . \u2502 AD1 7 . \u2502 \u2502 . . . . \u2502 BD1 7 \u2502 \u2502 . . \u2502 . \u2502 . CD1 7 . \u2502 . . \u2502 . \u2502 . DJ 8 \u2502 . . . \u2502 . . \u2502 AE0 8 . \u2502 \u2502 . . . . \u2502 BE0 8 \u2502 \u2502 . . \u2502 . \u2502 . CE0 8 . \u2502 . . \u2502 . \u2502 . DE0 9 \u2502 . . . \u2502 . . \u2502 AK 9 . \u2502 \u2502 . . . . \u2502 BE1 9 \u2502 \u2502 . . \u2502 . \u2502 . CL 9 . \u2502 . . \u2502 . \u2502 . DE1 10 \u2502 . . . \u2502 . . \u2502 AF0 10 . \u2502 \u2502 . . . . \u2502 BF0 10 \u2502 \u2502 . . \u2502 . \u2502 . CF0 10 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500 DF0 11 \u2502 . . . \u2502 . . \u2502 AF1 11 . \u2502 \u2502 . . . . \u2502 BK 11 \u2502 \u2502 . . \u2502 . \u2502 . CF1 11 . \u2502 . . \u2502 . \u2502 . DL 12 \u2502 . . . \u2502 . . \u2502 AG0 12 . \u2502 \u2502 . . . . \u2502 BG0 12 \u2502 \u2502 . . \u2502 . \u2502 . CG0 12 . \u2502 . . \u2502 . \u2502 . DG0 13 \u2502 . . . \u2502 . . \u2502 AL 13 . \u2502 \u2502 . . . . \u2502 BG1 13 \u2502 \u2502 . . \u2502 . \u2502 . CK 13 . \u2502 . . \u2502 . \u2502 . DK 14 \u2502 . . . \u2502 . . \u2502 AH0 14 . \u2502 \u2502 . . . . \u2502 BH0 14 \u2502 \u2502 . . \u2502 . \u2502 . CH0 14 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 DH0 15 \u2502 . . . \u2502 . . \u2502 AH1 15 . \u2502 \u2502 . . . . \u2502 BL 15 \u2502 \u2502 . . \u2502 . \u2502 . CH1 15 . \u2502 . . \u2502 . \u2502 . DH1 u 1 2 3 4 5 6 7 u 8 9 10 11 12 13 14 u 15 16 17 18 19 20 21 u 22 23 24 25 26 27 28 chip E chip F chip G chip H 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500 AE0 0 . . . \u2502 . \u2502 . . AF0 0 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500 AG0 0 \u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 AH0 1 . . . . \u2502 . \u2502 . EK 1 . . . \u2502 . \u2502 . . AF1 1 . \u2502 . . . \u2502 . . GL 1 . \u2502 . \u2502 . . . \u2502 AH1 2 . . . . \u2502 . \u2502 . BE0 2 . . . \u2502 . \u2502 . . BF0 2 . \u2502 . . . \u2502 . . BG0 2 . \u2502 . \u2502 . . . \u2502 BH0 3 . . . . \u2502 . \u2502 . BE1 3 . . . \u2502 . \u2502 . . FK 3 . \u2502 . . . \u2502 . . BG1 3 . \u2502 . \u2502 . . . \u2502 HL 4 . . . . \u2502 . \u2502 . CE0 4 . . . \u2502 . \u2502 . . CF0 4 . \u2502 . . . \u2502 . . CG0 4 . \u2502 . \u2502 . . . \u2502 CH0 5 . . . . \u2502 . \u2502 . EL 5 . . . \u2502 . \u2502 . . CF1 5 . \u2502 . . . \u2502 . . GK 5 . \u2502 . \u2502 . . . \u2502 CH1 6 . . . . \u2502 . \u2502 . DE0 6 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500 DF0 6 . \u2502 . . . \u2502 . . DG0 6 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500 DH0 7 . . . . \u2502 . \u2502 . DE1 7 . . . \u2502 . \u2502 . . FL 7 . \u2502 . . . \u2502 . . DG1 7 . \u2502 . \u2502 . . . \u2502 HK 8 . . . . \u2502 . \u2502 . EI 8 . . . \u2502 . \u2502 . . EF0 8 . \u2502 . . . \u2502 . . EG0 8 . \u2502 . \u2502 . . . \u2502 EH0 9 . . . . \u2502 . \u2502 . EJ 9 . . . \u2502 . \u2502 . . EF1 9 . \u2502 . . . \u2502 . . EG1 9 . \u2502 . \u2502 . . . \u2502 EH1 10 . . . . \u2502 . \u2502 . EF0 10 . . . \u2502 . \u2502 . . FI 10 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500 FG0 10 . \u2502 . \u2502 . . . \u2502 FH0 11 . . . . \u2502 . \u2502 . EF1 11 . . . \u2502 . \u2502 . . FJ 11 . \u2502 . . . \u2502 . . FG1 11 . \u2502 . \u2502 . . . \u2502 FH1 12 . . . . \u2502 . \u2502 . EG0 12 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 FG0 12 . \u2502 . . . \u2502 . . GI 12 . \u2502 . \u2502 . . . \u2502 GH0 13 . . . . \u2502 . \u2502 . EG1 13 . . . \u2502 . \u2502 . . FG1 13 . \u2502 . . . \u2502 . . GJ 13 . \u2502 . \u2502 . . . \u2502 GH1 14 . . . . \u2502 . \u2502 . EH0 14 . . . \u2502 . \u2502 . . FH0 14 . \u2502 . . . \u2502 . . GH0 14 . \u2502 . \u2502 . . . \u2502 HI 15 . . . . \u2502 . \u2502 . EH1 15 . . . \u2502 . \u2502 . . FH1 15 . \u2502 . . . \u2502 . . GH1 15 . \u2502 . \u2502 . . . \u2502 HJ u 31 32 33 34 35 36 37 u 38 39 40 41 42 43 44 u 45 46 47 48 49 50 51 u 52 53 54 55 56 57 58 chip I chip J chip K chip L 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA0 0 \u2502 \u2502 \u2502 . . . . . nD0 0 \u2502 . . . . . . . 29 0 . . . . . . . . 30 1 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nD1 1 \u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA1 1 \u2502 . . . . . . . 59 1 . . . . . . . . 60 2 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nA2 2 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nD2 2 \u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 BFi 2 . . . . . . . . BFo 3 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nD3 3 \u2502 \u2502 \u2502 . . . . . nA3 3 \u2502 . . . . . . . ARF 3 . . . . . . . . 5 V 4 \u2500\u2588\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA4 4 \u2502 \u2502 \u2502 . . . . . nD4 4 \u2502 . . . . . . . TRl 4 . . . . . . . . GP1 5 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nD5 5 \u2500\u2588\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA5 5 \u2502 . . . . . . . BRl 5 . . . . . . . . GP2 6 \u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nA6 6 \u2502 \u2502 \u2502 . . . . . nD6 6 \u2502 . . . . . . . Da1 6 . . . . . . . . GP3 7 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nD7 7 \u2502 \u2502 \u2502 . . . . . nA7 7 \u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Da0 7 . . . . . . . . GP4 8 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nD1 8 \u2502 \u2502 \u2502 . . . . . nD8 8 \u2502 . . . . . . . Ad0 8 . . . . . . . . GP5 9 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 nD9 9 \u2502 \u2502 \u2502 . . . . . nD1 9 \u2502 . . . . . . . Ad1 9 . . . . . . . . GP6 10 \u2502 \u2502 \u2502 \u2502 \u2502 . . . nD1 10 \u2502 \u2502 \u2502 . . . . . nD1 10 \u2502 . . . . . . . Ad2 10 . . . . . . . . GP7 11 \u2502 \u2502 \u2502 \u2502 \u2502 . . . I + 11 \u2502 \u2502 \u2502 . . . . . I - 11 \u2502 . . . . . . . Ad3 11 . . . . . . . . GP8 12 \u2502 \u2502 \u2502 \u2502 \u2502 . . . IL 12 \u2502 \u2502 \u2502 . . . . . JL 12 \u2502 . . . . . . . KL 12 . . . . . . . . LI 13 \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 IJ 13 \u2500\u253c\u2500\u2500\u2588\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 IJ 13 \u2502 . . . . . . . KI 13 . . . . . . . . LJ 14 \u2502 \u2502 \u2502 \u2502 \u2502 . . . IK 14 \u2502 \u2502 \u2502 . . . . . JK 14 \u2502 . . . . . . . KJ 14 . . . . . . . . LK 15 \u2502 \u2502 \u2502 \u2502 \u2502 . . . uRX 15 \u2502 \u2502 \u2502 . . . . . uTX 15 \u2502 . . . . . . . GND 15 . . . . . . . . GND AI BI CI DI EI FI GI HI AJ BJ CJ DJ EJ FJ GJ HJ AK BK CK DK EK FK GK HK AL BL CL DL EL FL GL HL","title":"Crossbar Array"},{"location":"07-debugging/#bridge-array","text":"Enter b in the menu. This is generally the most helpful one for me to troubleshoot what's going on if your issue has anything to do with routing or connections. It probably looks like nonsense to you but I've been in it so long it makes perfect sense to me.","title":"Bridge Array"},{"location":"07-debugging/#net-list","text":"Enter n in the menu to show this one. If you have anything that's doing any measurement ( gpio input or ADC s), it'll stay up and live update if any of them change. (And just like basically any menu not asking for input, entering anything will bring you back to the main menu.)","title":"Net List"},{"location":"08-file-manager/","text":"File Manager The Jumperless has a built in File Manager which you can access in the menu with / , or enter U in the menu and Jumperless will mount as a USB Mass Storage drive called JUMPERLESS where you can edit files on the filesystem. Directory Structure Navigation Basic Movement Control Action \u2191/\u2193 Arrow Keys or Rotary Encoder Move selection up/down Enter or Click Encoder Open directory or edit file / Go to root directory . Go up one directory CTRL + q Quit File Manager or Text Editor File Manager Commands Key Action Description [enter] Open Open file or enter directory h Help Show help v Quick view View file contents . Up dir Go up one directory n New file Create new file (prompts for filename) d New directory Create new directory x Delete Delete file or directory (confirm with y / N ) File Type Icons and Colors Icon File Type Extensions Color \u2318 Directories - Blue \ud80c\udd9a Python files .py, .pyw, .pyi Green \u237a Text files .txt, .md White \u2699 Config files .cfg, .conf, config.txt Yellow \u27d0 JSON files .json Cyan \u260a Node files nodeFileSlot*.txt Magenta \u2383 Color files netColorsSlot*.txt Orange Jumperless Kilo Text Editor The File Manager also has text editor based off eKilo Editor Controls Ctrl+S : Save file Ctrl+Q : Quit editor Ctrl+P : Save and launch MicroPython REPL Arrow keys : Navigate cursor Rotary encoder : Move cursor horizontally Click encoder : Enter character selection mode (you can scroll through the letters on the OLED and click again to insert it) Character Selection With the Click Wheel and OLED When using the rotary encoder in the editor: Click encoder : Enter character selection mode Rotate encoder : Cycle through available characters Click encoder : Confirm character selection Wait 3 seconds : Exit character selection mode Yes, you could write code with just the click wheel and the OLED if you really wanted to. MicroPython Examples The File Manager automatically creates example Python scripts in / python_scripts / examples / : 01_dac_basics.py : DAC (Digital-to-Analog Converter) examples 02_adc_basics.py : ADC (Analog-to-Digital Converter) examples 03_gpio_basics.py : GPIO (General Purpose Input/Output) examples 04_node_connections.py : Node connection and routing examples led_brightness_control.py : LED brightness control You can trigger them to regenerate if you messed them up by deleting it with x , and then entering m to create new copies of any examples it doesn't see. USB Mass Storage Enter U in the menu and Jumperless will mount as a USB Mass Storage drive called JUMPERLESS where you can edit files on the filesystem. Keep in mind that file operations are pretty slow, so make sure to give it time to fully save files when you drop them onto the filesystem. When you're finished u (or just eject the drive) will unmount the Mass Storage device. You can also enter Z for a little debug menu OLED Display Support If you have an OLED connected, the File Manager shows: - Current path and selected file - File navigation with scrolling support - Real-time updates as you navigate Navigation Reference Key Action \u2191/\u2193 Move selection Enter Open/Edit / Go to root . Go up directory h Show help File Operations Key Action v View file e Edit file i File info n New file d New directory x Delete r Refresh System Key Action u Memory status m Initialize examples Ctrl+Q Quit","title":"File Manager"},{"location":"08-file-manager/#file-manager","text":"The Jumperless has a built in File Manager which you can access in the menu with / , or enter U in the menu and Jumperless will mount as a USB Mass Storage drive called JUMPERLESS where you can edit files on the filesystem.","title":"File Manager"},{"location":"08-file-manager/#directory-structure","text":"","title":"Directory Structure"},{"location":"08-file-manager/#navigation","text":"","title":"Navigation"},{"location":"08-file-manager/#basic-movement","text":"Control Action \u2191/\u2193 Arrow Keys or Rotary Encoder Move selection up/down Enter or Click Encoder Open directory or edit file / Go to root directory . Go up one directory CTRL + q Quit File Manager or Text Editor","title":"Basic Movement"},{"location":"08-file-manager/#file-manager-commands","text":"Key Action Description [enter] Open Open file or enter directory h Help Show help v Quick view View file contents . Up dir Go up one directory n New file Create new file (prompts for filename) d New directory Create new directory x Delete Delete file or directory (confirm with y / N )","title":"File Manager Commands"},{"location":"08-file-manager/#file-type-icons-and-colors","text":"Icon File Type Extensions Color \u2318 Directories - Blue \ud80c\udd9a Python files .py, .pyw, .pyi Green \u237a Text files .txt, .md White \u2699 Config files .cfg, .conf, config.txt Yellow \u27d0 JSON files .json Cyan \u260a Node files nodeFileSlot*.txt Magenta \u2383 Color files netColorsSlot*.txt Orange","title":"File Type Icons and Colors"},{"location":"08-file-manager/#jumperless-kilo-text-editor","text":"The File Manager also has text editor based off eKilo","title":"Jumperless Kilo Text Editor"},{"location":"08-file-manager/#editor-controls","text":"Ctrl+S : Save file Ctrl+Q : Quit editor Ctrl+P : Save and launch MicroPython REPL Arrow keys : Navigate cursor Rotary encoder : Move cursor horizontally Click encoder : Enter character selection mode (you can scroll through the letters on the OLED and click again to insert it)","title":"Editor Controls"},{"location":"08-file-manager/#character-selection-with-the-click-wheel-and-oled","text":"When using the rotary encoder in the editor: Click encoder : Enter character selection mode Rotate encoder : Cycle through available characters Click encoder : Confirm character selection Wait 3 seconds : Exit character selection mode Yes, you could write code with just the click wheel and the OLED if you really wanted to.","title":"Character Selection With the Click Wheel and OLED"},{"location":"08-file-manager/#micropython-examples","text":"The File Manager automatically creates example Python scripts in / python_scripts / examples / : 01_dac_basics.py : DAC (Digital-to-Analog Converter) examples 02_adc_basics.py : ADC (Analog-to-Digital Converter) examples 03_gpio_basics.py : GPIO (General Purpose Input/Output) examples 04_node_connections.py : Node connection and routing examples led_brightness_control.py : LED brightness control You can trigger them to regenerate if you messed them up by deleting it with x , and then entering m to create new copies of any examples it doesn't see.","title":"MicroPython Examples"},{"location":"08-file-manager/#usb-mass-storage","text":"Enter U in the menu and Jumperless will mount as a USB Mass Storage drive called JUMPERLESS where you can edit files on the filesystem. Keep in mind that file operations are pretty slow, so make sure to give it time to fully save files when you drop them onto the filesystem. When you're finished u (or just eject the drive) will unmount the Mass Storage device. You can also enter Z for a little debug menu","title":"USB Mass Storage"},{"location":"08-file-manager/#oled-display-support","text":"If you have an OLED connected, the File Manager shows: - Current path and selected file - File navigation with scrolling support - Real-time updates as you navigate","title":"OLED Display Support"},{"location":"08-file-manager/#navigation-reference","text":"Key Action \u2191/\u2193 Move selection Enter Open/Edit / Go to root . Go up directory h Show help","title":"Navigation Reference"},{"location":"08-file-manager/#file-operations","text":"Key Action v View file e Edit file i File info n New file d New directory x Delete r Refresh","title":"File Operations"},{"location":"08-file-manager/#system","text":"Key Action u Memory status m Initialize examples Ctrl+Q Quit","title":"System"},{"location":"08-micropython/","text":"MicroPython This guide covers how to write, load, and run Python scripts that control Jumperless hardware using the embedded MicroPython interpreter. Quick Start From the main Jumperless menu, press p to enter the MicroPython REPL: REPL Navigation Up / Down arrow keys on a blank prompt will scroll through history, any other key will break out of history mode and enter multiline editing. So you can use arrow keys to navigate and edit the script. Hardware Control Functions All Jumperless hardware functions are automatically imported into the global namespace - no prefix needed Basic Hardware Control # Connect nodes 1 and 5 connect ( 1 , 5 ) # Set GPIO pin 1 to HIGH gpio_set ( 1 , True ) # Read ADC channel 0 voltage = adc_get ( 0 ) print ( \"Voltage: \" + str ( voltage ) + \"V\" ) # Set DAC channel 0 to 3.3V dac_set ( 0 , 3.3 ) Node Connections # Connect two nodes connect ( 1 , 5 ) # Connect using numbers connect ( \"d13\" , \"tOp_rAiL\" ) # Connect using node names (case insensitive when in quotes) connect ( TOP_RAIL , BOTTOM_RAIL ) # Connect using DEFINEs (all caps) Note: This will actually just be ignored by the Jumperless due to Do Not Intersect rules # Disconnect bridges disconnect ( 1 , 5 ) # Disconnect everything connected to a node disconnect ( 5 , - 1 ) # Check if nodes are connected if is_connected ( 1 , 5 ): print ( \"Nodes 1 and 5 are connected\" ) # Clear all connections nodes_clear () DAC (Output Voltage) # Set DAC voltage (-8.0V to 8.0V) dac_set ( 0 , 2.5 ) # Set DAC channel 0 to 2.5V dac_set ( 1 , 1.65 ) # Set DAC channel 1 to 1.65V # Read current DAC voltage voltage = dac_get ( 0 ) print ( \"DAC 0: \" + str ( voltage ) + \"V\" ) # Available channels: # 0 = DAC0, 1 = DAC1, 2 = TOP_RAIL, 3 = BOTTOM_RAIL # Can also use node names: DAC0, DAC1, TOP_RAIL, BOTTOM_RAIL ADC (Measure Voltage) # Read analog voltage (0-8V range for channels 0-3, 0-5V for channel 4) voltage = adc_get ( 0 ) # Read ADC channel 0 voltage = adc_get ( 1 ) # Read ADC channel 1 # Available channels: 0, 1, 2, 3, 4 GPIO (General Purpose I/O) # Set GPIO direction gpio_set_dir ( 1 , True ) # Set GPIO 1 as OUTPUT gpio_set_dir ( 2 , False ) # Set GPIO 2 as INPUT # Set GPIO state gpio_set ( 1 , True ) # Set GPIO 1 HIGH gpio_set ( 1 , False ) # Set GPIO 1 LOW # Read GPIO state (returns \"HIGH\" or \"LOW\") state = gpio_get ( 2 ) # Returns formatted string # Configure pull resistors gpio_set_pull ( 3 , 1 ) # Enable pull-up gpio_set_pull ( 3 , - 1 ) # Enable pull-down gpio_set_pull ( 3 , 0 ) # No pull resistor # Read GPIO configuration (returns formatted strings) direction = gpio_get_dir ( 1 ) # Returns \"INPUT\" or \"OUTPUT\" pull = gpio_get_pull ( 2 ) # Returns \"PULLUP\", \"PULLDOWN\", or \"NONE\" # Available GPIO pins: 1-8 (GPIO 1-8), 9 (UART Tx), 10 (UART Rx) Current Sensing (INA219) # Read current sensor data current = ina_get_current ( 0 ) # Current in A current = ina_get_current ( 0 ) * 1000 # Current in mA voltage = ina_get_voltage ( 0 ) # Shunt voltage in V bus_voltage = ina_get_bus_voltage ( 0 ) # Bus voltage in V power = ina_get_power ( 0 ) # Power in W # Available sensors: 0, 1 # INA 1 is hardwired to the output of DAC 0 because it's meant for measuring resistance OLED Display # Initialize OLED oled_connect () # Connect to OLED oled_print ( \"Hello World!\" ) # Display text # Clear display oled_clear () # Disconnect oled_disconnect () Probe Functions # Read probe pad (blocking) pad = probe_read_blocking () # Returns ProbePad object only when a pad is touched # Read probe pad (non-blocking) pad = probe_read_nonblocking () # Returns ProbePad object (which can be NO_PAD) # Button functions (probe button) button = probe_button () # Read probe button state (blocking) button = get_button () # Alias button = button_read () # Another alias button = read_button () # Another alias button = check_button () # Non-blocking check button = button_check () # Alias # Button with parameters button = probe_button ( True ) # Blocking button = probe_button ( False ) # Non-blocking System Functions # Reset Arduino arduino_reset () # Run built-in apps run_app ( \"I2C Scan\" ) # Run I2C scanner run_app ( \"Bounce Startup\" ) # Loop the startup animation # Show help help () # Display all available functions nodes_help () # Show all available node names and aliases The help() and nodes_help() functions will list all the available commands (except for the new ones I forget to update) Basic Script Structure \"\"\" My Jumperless Script Description of what this script does \"\"\" print ( \"Starting my script...\" ) # Connect some nodes connect ( 1 , 5 ) connect ( 2 , 6 ) # Set up GPIO gpio_set_dir ( 1 , True ) # Output gpio_set_dir ( 2 , False ) # Input # Main loop for i in range ( 10 ): gpio_set ( 1 , True ) time . sleep ( 0.5 ) gpio_set ( 1 , False ) time . sleep ( 0.5 ) # Read input if gpio_get ( 2 ) == \"HIGH\" : print ( \"Button pressed!\" ) # Cleanup nodes_clear () print ( \"Script complete!\" ) Loading and Running Scripts Method 1: File Manager From the REPL, type files to open the file manager: >>> files Navigate to your script and press Enter to load it for editing, then press Ctrl + P to load it into the REPL for execution. Note: The standard Python exec ( open ( ... ) . read ()) method is not supported in the Jumperless MicroPython environment. Always use the file manager and Ctrl + P to run scripts. Method 2: REPL Commands From the MicroPython REPL, you can use the following commands to manage scripts: # Load script into editor for modification load my_script . py # Save current session as script save my_new_script . py Method 4: Direct Execution From the main Jumperless menu, you can execute single commands: > gpio_set ( 1 , True ) > adc_get ( 0 ) > connect ( 1 , 5 ) REPL (Interactive Mode) Starting REPL From main menu: Press p REPL Commands CTRL + q - Exit REPL history - Show command history and saved scripts save [ name ] - Save last executed script load < name > - Load script by name or number files - Open file manager new - Create new script with eKilo editor helpl - Show REPL help help () - Show hardware commands Navigation \u2191 / \u2193 arrows - Browse command history \u2190 / \u2192 arrows - Move cursor , edit text TAB - Add 4 - space indentation Enter - Execute ( empty line in multiline to finish ) Ctrl + Q - Force quit REPL or interrupt running script Multiline Auto-Indent Mode The REPL automatically detects when you need multiple lines after a : >>> def blink_led (): ... for i in range ( 5 ): ... gpio_set ( 1 , True ) ... time . sleep ( 0.5 ) ... gpio_set ( 1 , False ) ... time . sleep ( 0.5 ) ... >>> blink_led () If you want to use real multiline mode, use the Kilo file editor. Command History Use \u2191/\u2193 arrows to browse previous commands Commands are automatically saved Type history to see all saved scripts Built-in Examples The system includes several example scripts. To run an example: Type files in the REPL. Navigate to the examples / directory. Select the desired script and press Enter to edit/view it. Press Ctrl + P to load it into the REPL for execution. Example scripts include: - 01_dac_basics.py (DAC basics - voltage control) - 02_adc_basics.py (ADC basics - voltage reading) - 03_gpio_basics.py (GPIO basics - digital I/O) - 04_node_connections.py (Node connections) REPL not responding: - Press Ctrl+Q to force quit - Unplug / replug your Jumperless (don't worry, almost everything is persistent) Formatted Output and Custom Types The Jumperless module provides formatted output for better readability: # GPIO state returns formatted strings state = gpio_get ( 1 ) # Returns \"HIGH\" or \"LOW\" direction = gpio_get_dir ( 1 ) # Returns \"INPUT\" or \"OUTPUT\" pull = gpio_get_pull ( 1 ) # Returns \"PULLUP\", \"PULLDOWN\", or \"NONE\" # Connection status returns formatted strings connected = is_connected ( 1 , 5 ) # Returns \"CONNECTED\" (truthy) or \"DISCONNECTED\" (falsey) # Voltage and current readings are automatically formatted voltage = adc_get ( 0 ) # Returns float (e.g., 3.300) current = ina_get_current ( 0 ) # Returns float in A (e.g., 0.0123) power = ina_get_power ( 0 ) # Returns float in W (e.g., 0.4567) # All functions work with both numbers and string aliases gpio_set_dir ( \"GPIO_1\" , True ) # Same as gpio_set_dir(1, True) connect ( \"TOP_RAIL\" , \"GPIO_1\" ) # Same as connect(101, 131) Node Names and Constants The Jumperless module provides extensive node name support with multiple aliases for each node: # Power rails (multiple aliases supported) TOP_RAIL = 101 # Also: TOPRAIL, T_R, TOP_R BOTTOM_RAIL = 102 # Also: BOT_RAIL, BOTTOMRAIL, BOTRAIL, B_R, BOT_R SUPPLY_3V3 = 103 # Also: 3V3, 3.3V SUPPLY_5V = 105 # Also: 5V, +5V SUPPLY_8V_P = 120 # Also: 8V_P, 8V_POS SUPPLY_8V_N = 121 # Also: 8V_N, 8V_NEG # Ground connections GND = 100 # Also: GROUND TOP_RAIL_GND = 104 # Also: TOP_GND (not actually routable but included for PADs) BOTTOM_RAIL_GND = 126 # Also: BOT_GND, BOTTOM_GND (not actually routable but included for PADs) # DAC outputs DAC0 = 106 # Also: DAC_0, DAC0_5V DAC1 = 107 # Also: DAC_1, DAC1_8V # ADC inputs ADC0 = 110 # Also: ADC_0, ADC0_8V ADC1 = 111 # Also: ADC_1, ADC1_8V ADC2 = 112 # Also: ADC_2, ADC2_8V ADC3 = 113 # Also: ADC_3, ADC3_8V ADC4 = 114 # Also: ADC_4, ADC4_5V ADC7 = 115 # Also: ADC_7, ADC7_PROBE, PROBE # Current sensing ISENSE_PLUS = 108 # Also: ISENSE_POS, ISENSE_P, INA_P, I_P, CURRENT_SENSE_PLUS, ISENSE_POSITIVE, I_POS ISENSE_MINUS = 109 # Also: ISENSE_NEG, ISENSE_N, INA_N, I_N, CURRENT_SENSE_MINUS, ISENSE_NEGATIVE, I_NEG # GPIO pins (multiple naming conventions) GPIO_1 = 131 # Also: RP_GPIO_1, GPIO1, GP_1, GP1 GPIO_2 = 132 # Also: RP_GPIO_2, GPIO2, GP_2, GP2 GPIO_3 = 133 # Also: RP_GPIO_3, GPIO3, GP_3, GP3 GPIO_4 = 134 # Also: RP_GPIO_4, GPIO4, GP_4, GP4 GPIO_5 = 135 # Also: RP_GPIO_5, GPIO5, GP_5, GP5 GPIO_6 = 136 # Also: RP_GPIO_6, GPIO6, GP_6, GP6 GPIO_7 = 137 # Also: RP_GPIO_7, GPIO7, GP_7, GP7 GPIO_8 = 138 # Also: RP_GPIO_8, GPIO8, GP_8, GP8 # UART pins UART_TX = 116 # Also: RP_UART_TX, TX, RP_GPIO_16 UART_RX = 117 # Also: RP_UART_RX, RX, RP_GPIO_17 # Additional RP GPIOs RP_GPIO_18 = 118 # Also: GP_18 RP_GPIO_19 = 119 # Also: GP_19 # Buffer connections BUFFER_IN = 139 # Also: ROUTABLE_BUFFER_IN, BUF_IN, BUFF_IN, BUFFIN BUFFER_OUT = 140 # Also: ROUTABLE_BUFFER_OUT, BUF_OUT, BUFF_OUT, BUFFOUT # Arduino Nano pins (extensive support) D13 = 83 # Also: NANO_D13 D12 = 82 # Also: NANO_D12 D11 = 81 # Also: NANO_D11 D10 = 80 # Also: NANO_D10 D9 = 79 # Also: NANO_D9 D8 = 78 # Also: NANO_D8 D7 = 77 # Also: NANO_D7 D6 = 76 # Also: NANO_D6 D5 = 75 # Also: NANO_D5 D4 = 74 # Also: NANO_D4 D3 = 73 # Also: NANO_D3 D2 = 72 # Also: NANO_D2 D1 = 71 # Also: NANO_D1 D0 = 70 # Also: NANO_D0 # Arduino Nano analog pins A0 = 86 # Also: NANO_A0 A1 = 87 # Also: NANO_A1 A2 = 88 # Also: NANO_A2 A3 = 89 # Also: NANO_A3 A4 = 90 # Also: NANO_A4 A5 = 91 # Also: NANO_A5 A6 = 92 # Also: NANO_A6 A7 = 93 # Also: NANO_A7 # Arduino Nano non-routable hardwired connections VIN = 69 # Unconnected to anything RST0 = 94 # Hardwired to GPIO 18 on the RP2350 RST1 = 95 # Hardwired to GPIO 19 on the RP2350 N_GND0 = 97 # GND N_GND1 = 96 # GND NANO_5V = 99 # Hardwired to USB 5V bus (can also be used to power the Jumperless) NANO_3V3 = 98 # Unconnected (without bridging the solder jumper on the back) The entire output of help() >>> help () Jumperless Native MicroPython Module Hardware Control Functions with Formatted Output : ( GPIO functions return formatted strings like HIGH / LOW , INPUT / OUTPUT , PULLUP / NONE , CONNECTED / DISCONNECTED ) DAC ( Digital - to - Analog Converter ): jumperless . dac_set ( channel , voltage ) - Set DAC output voltage jumperless . dac_get ( channel ) - Get DAC output voltage jumperless . set_dac ( channel , voltage ) - Alias for dac_set jumperless . get_dac ( channel ) - Alias for dac_get channel : 0 - 3 , DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL channel 0 / DAC0 : DAC 0 channel 1 / DAC1 : DAC 1 channel 2 / TOP_RAIL : top rail channel 3 / BOTTOM_RAIL : bottom rail voltage : - 8.0 to 8.0 V ADC ( Analog - to - Digital Converter ): jumperless . adc_get ( channel ) - Read ADC input voltage jumperless . get_adc ( channel ) - Alias for adc_get channel : 0 - 4 INA ( Current / Power Monitor ): jumperless . ina_get_current ( sensor ) - Read current in amps jumperless . ina_get_voltage ( sensor ) - Read shunt voltage jumperless . ina_get_bus_voltage ( sensor ) - Read bus voltage jumperless . ina_get_power ( sensor ) - Read power in watts Aliases : get_current , get_voltage , get_bus_voltage , get_power sensor : 0 or 1 GPIO : jumperless . gpio_set ( pin , value ) - Set GPIO pin state jumperless . gpio_get ( pin ) - Read GPIO pin state jumperless . gpio_set_dir ( pin , direction ) - Set GPIO pin direction jumperless . gpio_get_dir ( pin ) - Get GPIO pin direction jumperless . gpio_set_pull ( pin , pull ) - Set GPIO pull - up / down jumperless . gpio_get_pull ( pin ) - Get GPIO pull - up / down Aliases : set_gpio , get_gpio , set_gpio_dir , get_gpio_dir , etc . pin 1 - 8 : GPIO 1 - 8 pin 9 : UART Tx pin 10 : UART Rx value : True / False for HIGH / LOW direction : True / False for OUTPUT / INPUT pull : - 1 / 0 / 1 for PULL_DOWN / NONE / PULL_UP Node Connections : jumperless . connect ( node1 , node2 ) - Connect two nodes jumperless . disconnect ( node1 , node2 ) - Disconnect nodes jumperless . is_connected ( node1 , node2 ) - Check if nodes are connected jumperless . nodes_clear () - Clear all connections set node2 to - 1 to disconnect everything connected to node1 OLED Display : jumperless . oled_print ( \"text\" ) - Display text jumperless . oled_clear () - Clear display jumperless . oled_connect () - Connect OLED jumperless . oled_disconnect () - Disconnect OLED Clickwheel : jumperless . clickwheel_up ([ clicks ]) - Scroll up jumperless . clickwheel_down ([ clicks ]) - Scroll down jumperless . clickwheel_press () - Press button clicks : number of steps Status : jumperless . print_bridges () - Print all bridges jumperless . print_paths () - Print path between nodes jumperless . print_crossbars () - Print crossbar array jumperless . print_nets () - Print nets jumperless . print_chip_status () - Print chip status Probe Functions : jumperless . probe_read ([ blocking = True ]) - Read probe ( default : blocking ) jumperless . read_probe ([ blocking = True ]) - Read probe ( default : blocking ) jumperless . probe_read_blocking () - Wait for probe touch ( explicit ) jumperless . probe_read_nonblocking () - Check probe immediately ( explicit ) jumperless . get_button ([ blocking = True ]) - Get button state ( default : blocking ) jumperless . probe_button ([ blocking = True ]) - Get button state ( default : blocking ) jumperless . probe_button_blocking () - Wait for button press ( explicit ) jumperless . probe_button_nonblocking () - Check buttons immediately ( explicit ) Touch aliases : probe_wait , wait_probe , probe_touch , wait_touch ( always blocking ) Button aliases : button_read , read_button ( parameterized ) Non - blocking only : check_button , button_check Touch returns : ProbePad object ( 1 - 60 , D13_PAD , TOP_RAIL_PAD , LOGO_PAD_TOP , etc . ) Button returns : CONNECT , REMOVE , or NONE ( front = connect , rear = remove ) Misc : jumperless . arduino_reset () - Reset Arduino jumperless . probe_tap ( node ) - Tap probe on node ( unimplemented ) jumperless . run_app ( appName ) - Run app jumperless . format_output ( True / False ) - Enable / disable formatted output Help : jumperless . help () - Display this help Node Names : jumperless . node ( \"TOP_RAIL\" ) - Create node from string name jumperless . TOP_RAIL - Pre - defined node constant jumperless . D2 , jumperless . A0 , etc . - Arduino pin constants For global access : from jumperless_nodes import * Node names : All standard names like \"D13\" , \"A0\" , \"GPIO_1\" , etc . Examples ( all functions available globally ): dac_set ( TOP_RAIL , 3.3 ) # Set Top Rail to 3.3V using node set_dac ( 3 , 3.3 ) # Same as above using alias dac_set ( DAC0 , 5.0 ) # Set DAC0 using node constant voltage = get_adc ( 1 ) # Read ADC1 using alias connect ( TOP_RAIL , D13 ) # Connect using constants connect ( \"TOP_RAIL\" , 5 ) # Connect using strings connect ( 4 , 20 ) # Connect using numbers top_rail = node ( \"TOP_RAIL\" ) # Create node object connect ( top_rail , D13 ) # Mix objects and constants oled_print ( \"Fuck you!\" ) # Display text current = get_current ( 0 ) # Read current using alias set_gpio ( 1 , True ) # Set GPIO pin high using alias pad = probe_read () # Wait for probe touch if pad == 25 : print ( 'Touched pad 25!' ) # Check specific pad if pad == D13_PAD : connect ( D13 , TOP_RAIL ) # Auto-connect Arduino pin if pad == TOP_RAIL_PAD : show_voltage () # Show rail voltage if pad == LOGO_PAD_TOP : print ( 'Logo!' ) # Check logo pad button = get_button () # Wait for button press (blocking) if button == CONNECT_BUTTON : ... # Front button pressed if button == REMOVE_BUTTON : ... # Rear button pressed button = check_button () # Check buttons immediately if button == BUTTON_NONE : print ( 'None' ) # No button pressed pad = wait_touch () # Wait for touch btn = check_button () # Check button immediately if pad == D13_PAD and btn == CONNECT_BUTTON : connect ( D13 , TOP_RAIL ) Note : All functions and constants are available globally ! No need for 'jumperless.' prefix in REPL or single commands . >>> The entire output of nodes_help() >>> nodes_help () Jumperless Node Reference ======================== NODE TYPES : Numbered : 1 - 60 ( breadboard ) Arduino : D0 - D13 , A0 - A7 ( nano header ) GPIO : GPIO_1 - GPIO_8 ( routable GPIO ) Power : TOP_RAIL , BOTTOM_RAIL , GND DAC : DAC0 , DAC1 ( analog outputs ) ADC : ADC0 - ADC4 , PROBE ( analog inputs ) Current : ISENSE_PLUS , ISENSE_MINUS UART : UART_TX , UART_RX Buffer : BUFFER_IN , BUFFER_OUT THREE WAYS TO USE NODES : 1. NUMBERS ( direct breadboard holes ): connect ( 1 , 30 ) # Connect holes 1 and 30 connect ( 15 , 42 ) # Any number 1-60 2. STRINGS ( case - insensitive names ): connect ( \"D13\" , \"TOP_RAIL\" ) # Arduino pin to power rail connect ( \"gpio_1\" , \"adc0\" ) # GPIO to ADC (case-insensitive) connect ( \"15\" , \"dac1\" ) # Mix numbers and names 3. CONSTANTS ( pre - defined objects ): connect ( TOP_RAIL , D13 ) # Using imported constants connect ( GPIO_1 , A0 ) # No quotes needed connect ( DAC0 , 25 ) # Mix constants and numbers MIXED USAGE : my_pin = \"D13\" # Create node object from string connect ( my_pin , TOP_RAIL ) # Use node object with constant oled_print ( my_pin ) # Display shows 'D13' COMMON ALIASES ( many names work for same node ): \"TOP_RAIL\" = \"T_R\" \"GPIO_1\" = \"GPIO1\" = \"GP1\" \"DAC0\" = \"DAC_0\" \"UART_TX\" = \"TX\" NOTES : - String names are case - insensitive : \"d13\" = \"D13\" = \"nAnO_d13\" - Constants are case - sensitive : use D13 , not d13 - All three methods work in any function","title":"MicroPython"},{"location":"08-micropython/#micropython","text":"This guide covers how to write, load, and run Python scripts that control Jumperless hardware using the embedded MicroPython interpreter.","title":"MicroPython"},{"location":"08-micropython/#quick-start","text":"From the main Jumperless menu, press p to enter the MicroPython REPL:","title":"Quick Start"},{"location":"08-micropython/#repl-navigation","text":"Up / Down arrow keys on a blank prompt will scroll through history, any other key will break out of history mode and enter multiline editing. So you can use arrow keys to navigate and edit the script.","title":"REPL Navigation"},{"location":"08-micropython/#hardware-control-functions","text":"All Jumperless hardware functions are automatically imported into the global namespace - no prefix needed","title":"Hardware Control Functions"},{"location":"08-micropython/#basic-hardware-control","text":"# Connect nodes 1 and 5 connect ( 1 , 5 ) # Set GPIO pin 1 to HIGH gpio_set ( 1 , True ) # Read ADC channel 0 voltage = adc_get ( 0 ) print ( \"Voltage: \" + str ( voltage ) + \"V\" ) # Set DAC channel 0 to 3.3V dac_set ( 0 , 3.3 )","title":"Basic Hardware Control"},{"location":"08-micropython/#node-connections","text":"# Connect two nodes connect ( 1 , 5 ) # Connect using numbers connect ( \"d13\" , \"tOp_rAiL\" ) # Connect using node names (case insensitive when in quotes) connect ( TOP_RAIL , BOTTOM_RAIL ) # Connect using DEFINEs (all caps) Note: This will actually just be ignored by the Jumperless due to Do Not Intersect rules # Disconnect bridges disconnect ( 1 , 5 ) # Disconnect everything connected to a node disconnect ( 5 , - 1 ) # Check if nodes are connected if is_connected ( 1 , 5 ): print ( \"Nodes 1 and 5 are connected\" ) # Clear all connections nodes_clear ()","title":"Node Connections"},{"location":"08-micropython/#dac-output-voltage","text":"# Set DAC voltage (-8.0V to 8.0V) dac_set ( 0 , 2.5 ) # Set DAC channel 0 to 2.5V dac_set ( 1 , 1.65 ) # Set DAC channel 1 to 1.65V # Read current DAC voltage voltage = dac_get ( 0 ) print ( \"DAC 0: \" + str ( voltage ) + \"V\" ) # Available channels: # 0 = DAC0, 1 = DAC1, 2 = TOP_RAIL, 3 = BOTTOM_RAIL # Can also use node names: DAC0, DAC1, TOP_RAIL, BOTTOM_RAIL","title":"DAC (Output Voltage)"},{"location":"08-micropython/#adc-measure-voltage","text":"# Read analog voltage (0-8V range for channels 0-3, 0-5V for channel 4) voltage = adc_get ( 0 ) # Read ADC channel 0 voltage = adc_get ( 1 ) # Read ADC channel 1 # Available channels: 0, 1, 2, 3, 4","title":"ADC (Measure Voltage)"},{"location":"08-micropython/#gpio-general-purpose-io","text":"# Set GPIO direction gpio_set_dir ( 1 , True ) # Set GPIO 1 as OUTPUT gpio_set_dir ( 2 , False ) # Set GPIO 2 as INPUT # Set GPIO state gpio_set ( 1 , True ) # Set GPIO 1 HIGH gpio_set ( 1 , False ) # Set GPIO 1 LOW # Read GPIO state (returns \"HIGH\" or \"LOW\") state = gpio_get ( 2 ) # Returns formatted string # Configure pull resistors gpio_set_pull ( 3 , 1 ) # Enable pull-up gpio_set_pull ( 3 , - 1 ) # Enable pull-down gpio_set_pull ( 3 , 0 ) # No pull resistor # Read GPIO configuration (returns formatted strings) direction = gpio_get_dir ( 1 ) # Returns \"INPUT\" or \"OUTPUT\" pull = gpio_get_pull ( 2 ) # Returns \"PULLUP\", \"PULLDOWN\", or \"NONE\" # Available GPIO pins: 1-8 (GPIO 1-8), 9 (UART Tx), 10 (UART Rx)","title":"GPIO (General Purpose I/O)"},{"location":"08-micropython/#current-sensing-ina219","text":"# Read current sensor data current = ina_get_current ( 0 ) # Current in A current = ina_get_current ( 0 ) * 1000 # Current in mA voltage = ina_get_voltage ( 0 ) # Shunt voltage in V bus_voltage = ina_get_bus_voltage ( 0 ) # Bus voltage in V power = ina_get_power ( 0 ) # Power in W # Available sensors: 0, 1 # INA 1 is hardwired to the output of DAC 0 because it's meant for measuring resistance","title":"Current Sensing (INA219)"},{"location":"08-micropython/#oled-display","text":"# Initialize OLED oled_connect () # Connect to OLED oled_print ( \"Hello World!\" ) # Display text # Clear display oled_clear () # Disconnect oled_disconnect ()","title":"OLED Display"},{"location":"08-micropython/#probe-functions","text":"# Read probe pad (blocking) pad = probe_read_blocking () # Returns ProbePad object only when a pad is touched # Read probe pad (non-blocking) pad = probe_read_nonblocking () # Returns ProbePad object (which can be NO_PAD) # Button functions (probe button) button = probe_button () # Read probe button state (blocking) button = get_button () # Alias button = button_read () # Another alias button = read_button () # Another alias button = check_button () # Non-blocking check button = button_check () # Alias # Button with parameters button = probe_button ( True ) # Blocking button = probe_button ( False ) # Non-blocking","title":"Probe Functions"},{"location":"08-micropython/#system-functions","text":"# Reset Arduino arduino_reset () # Run built-in apps run_app ( \"I2C Scan\" ) # Run I2C scanner run_app ( \"Bounce Startup\" ) # Loop the startup animation # Show help help () # Display all available functions nodes_help () # Show all available node names and aliases The help() and nodes_help() functions will list all the available commands (except for the new ones I forget to update)","title":"System Functions"},{"location":"08-micropython/#basic-script-structure","text":"\"\"\" My Jumperless Script Description of what this script does \"\"\" print ( \"Starting my script...\" ) # Connect some nodes connect ( 1 , 5 ) connect ( 2 , 6 ) # Set up GPIO gpio_set_dir ( 1 , True ) # Output gpio_set_dir ( 2 , False ) # Input # Main loop for i in range ( 10 ): gpio_set ( 1 , True ) time . sleep ( 0.5 ) gpio_set ( 1 , False ) time . sleep ( 0.5 ) # Read input if gpio_get ( 2 ) == \"HIGH\" : print ( \"Button pressed!\" ) # Cleanup nodes_clear () print ( \"Script complete!\" )","title":"Basic Script Structure"},{"location":"08-micropython/#loading-and-running-scripts","text":"","title":"Loading and Running Scripts"},{"location":"08-micropython/#method-1-file-manager","text":"From the REPL, type files to open the file manager: >>> files Navigate to your script and press Enter to load it for editing, then press Ctrl + P to load it into the REPL for execution. Note: The standard Python exec ( open ( ... ) . read ()) method is not supported in the Jumperless MicroPython environment. Always use the file manager and Ctrl + P to run scripts.","title":"Method 1: File Manager"},{"location":"08-micropython/#method-2-repl-commands","text":"From the MicroPython REPL, you can use the following commands to manage scripts: # Load script into editor for modification load my_script . py # Save current session as script save my_new_script . py","title":"Method 2: REPL Commands"},{"location":"08-micropython/#method-4-direct-execution","text":"From the main Jumperless menu, you can execute single commands: > gpio_set ( 1 , True ) > adc_get ( 0 ) > connect ( 1 , 5 )","title":"Method 4: Direct Execution"},{"location":"08-micropython/#repl-interactive-mode","text":"","title":"REPL (Interactive Mode)"},{"location":"08-micropython/#starting-repl","text":"From main menu: Press p","title":"Starting REPL"},{"location":"08-micropython/#repl-commands","text":"CTRL + q - Exit REPL history - Show command history and saved scripts save [ name ] - Save last executed script load < name > - Load script by name or number files - Open file manager new - Create new script with eKilo editor helpl - Show REPL help help () - Show hardware commands","title":"REPL Commands"},{"location":"08-micropython/#navigation","text":"\u2191 / \u2193 arrows - Browse command history \u2190 / \u2192 arrows - Move cursor , edit text TAB - Add 4 - space indentation Enter - Execute ( empty line in multiline to finish ) Ctrl + Q - Force quit REPL or interrupt running script","title":"Navigation"},{"location":"08-micropython/#multiline-auto-indent-mode","text":"The REPL automatically detects when you need multiple lines after a : >>> def blink_led (): ... for i in range ( 5 ): ... gpio_set ( 1 , True ) ... time . sleep ( 0.5 ) ... gpio_set ( 1 , False ) ... time . sleep ( 0.5 ) ... >>> blink_led () If you want to use real multiline mode, use the Kilo file editor.","title":"Multiline Auto-Indent Mode"},{"location":"08-micropython/#command-history","text":"Use \u2191/\u2193 arrows to browse previous commands Commands are automatically saved Type history to see all saved scripts","title":"Command History"},{"location":"08-micropython/#built-in-examples","text":"The system includes several example scripts. To run an example: Type files in the REPL. Navigate to the examples / directory. Select the desired script and press Enter to edit/view it. Press Ctrl + P to load it into the REPL for execution. Example scripts include: - 01_dac_basics.py (DAC basics - voltage control) - 02_adc_basics.py (ADC basics - voltage reading) - 03_gpio_basics.py (GPIO basics - digital I/O) - 04_node_connections.py (Node connections) REPL not responding: - Press Ctrl+Q to force quit - Unplug / replug your Jumperless (don't worry, almost everything is persistent)","title":"Built-in Examples"},{"location":"08-micropython/#formatted-output-and-custom-types","text":"The Jumperless module provides formatted output for better readability: # GPIO state returns formatted strings state = gpio_get ( 1 ) # Returns \"HIGH\" or \"LOW\" direction = gpio_get_dir ( 1 ) # Returns \"INPUT\" or \"OUTPUT\" pull = gpio_get_pull ( 1 ) # Returns \"PULLUP\", \"PULLDOWN\", or \"NONE\" # Connection status returns formatted strings connected = is_connected ( 1 , 5 ) # Returns \"CONNECTED\" (truthy) or \"DISCONNECTED\" (falsey) # Voltage and current readings are automatically formatted voltage = adc_get ( 0 ) # Returns float (e.g., 3.300) current = ina_get_current ( 0 ) # Returns float in A (e.g., 0.0123) power = ina_get_power ( 0 ) # Returns float in W (e.g., 0.4567) # All functions work with both numbers and string aliases gpio_set_dir ( \"GPIO_1\" , True ) # Same as gpio_set_dir(1, True) connect ( \"TOP_RAIL\" , \"GPIO_1\" ) # Same as connect(101, 131)","title":"Formatted Output and Custom Types"},{"location":"08-micropython/#node-names-and-constants","text":"The Jumperless module provides extensive node name support with multiple aliases for each node: # Power rails (multiple aliases supported) TOP_RAIL = 101 # Also: TOPRAIL, T_R, TOP_R BOTTOM_RAIL = 102 # Also: BOT_RAIL, BOTTOMRAIL, BOTRAIL, B_R, BOT_R SUPPLY_3V3 = 103 # Also: 3V3, 3.3V SUPPLY_5V = 105 # Also: 5V, +5V SUPPLY_8V_P = 120 # Also: 8V_P, 8V_POS SUPPLY_8V_N = 121 # Also: 8V_N, 8V_NEG # Ground connections GND = 100 # Also: GROUND TOP_RAIL_GND = 104 # Also: TOP_GND (not actually routable but included for PADs) BOTTOM_RAIL_GND = 126 # Also: BOT_GND, BOTTOM_GND (not actually routable but included for PADs) # DAC outputs DAC0 = 106 # Also: DAC_0, DAC0_5V DAC1 = 107 # Also: DAC_1, DAC1_8V # ADC inputs ADC0 = 110 # Also: ADC_0, ADC0_8V ADC1 = 111 # Also: ADC_1, ADC1_8V ADC2 = 112 # Also: ADC_2, ADC2_8V ADC3 = 113 # Also: ADC_3, ADC3_8V ADC4 = 114 # Also: ADC_4, ADC4_5V ADC7 = 115 # Also: ADC_7, ADC7_PROBE, PROBE # Current sensing ISENSE_PLUS = 108 # Also: ISENSE_POS, ISENSE_P, INA_P, I_P, CURRENT_SENSE_PLUS, ISENSE_POSITIVE, I_POS ISENSE_MINUS = 109 # Also: ISENSE_NEG, ISENSE_N, INA_N, I_N, CURRENT_SENSE_MINUS, ISENSE_NEGATIVE, I_NEG # GPIO pins (multiple naming conventions) GPIO_1 = 131 # Also: RP_GPIO_1, GPIO1, GP_1, GP1 GPIO_2 = 132 # Also: RP_GPIO_2, GPIO2, GP_2, GP2 GPIO_3 = 133 # Also: RP_GPIO_3, GPIO3, GP_3, GP3 GPIO_4 = 134 # Also: RP_GPIO_4, GPIO4, GP_4, GP4 GPIO_5 = 135 # Also: RP_GPIO_5, GPIO5, GP_5, GP5 GPIO_6 = 136 # Also: RP_GPIO_6, GPIO6, GP_6, GP6 GPIO_7 = 137 # Also: RP_GPIO_7, GPIO7, GP_7, GP7 GPIO_8 = 138 # Also: RP_GPIO_8, GPIO8, GP_8, GP8 # UART pins UART_TX = 116 # Also: RP_UART_TX, TX, RP_GPIO_16 UART_RX = 117 # Also: RP_UART_RX, RX, RP_GPIO_17 # Additional RP GPIOs RP_GPIO_18 = 118 # Also: GP_18 RP_GPIO_19 = 119 # Also: GP_19 # Buffer connections BUFFER_IN = 139 # Also: ROUTABLE_BUFFER_IN, BUF_IN, BUFF_IN, BUFFIN BUFFER_OUT = 140 # Also: ROUTABLE_BUFFER_OUT, BUF_OUT, BUFF_OUT, BUFFOUT # Arduino Nano pins (extensive support) D13 = 83 # Also: NANO_D13 D12 = 82 # Also: NANO_D12 D11 = 81 # Also: NANO_D11 D10 = 80 # Also: NANO_D10 D9 = 79 # Also: NANO_D9 D8 = 78 # Also: NANO_D8 D7 = 77 # Also: NANO_D7 D6 = 76 # Also: NANO_D6 D5 = 75 # Also: NANO_D5 D4 = 74 # Also: NANO_D4 D3 = 73 # Also: NANO_D3 D2 = 72 # Also: NANO_D2 D1 = 71 # Also: NANO_D1 D0 = 70 # Also: NANO_D0 # Arduino Nano analog pins A0 = 86 # Also: NANO_A0 A1 = 87 # Also: NANO_A1 A2 = 88 # Also: NANO_A2 A3 = 89 # Also: NANO_A3 A4 = 90 # Also: NANO_A4 A5 = 91 # Also: NANO_A5 A6 = 92 # Also: NANO_A6 A7 = 93 # Also: NANO_A7 # Arduino Nano non-routable hardwired connections VIN = 69 # Unconnected to anything RST0 = 94 # Hardwired to GPIO 18 on the RP2350 RST1 = 95 # Hardwired to GPIO 19 on the RP2350 N_GND0 = 97 # GND N_GND1 = 96 # GND NANO_5V = 99 # Hardwired to USB 5V bus (can also be used to power the Jumperless) NANO_3V3 = 98 # Unconnected (without bridging the solder jumper on the back)","title":"Node Names and Constants"},{"location":"08-micropython/#the-entire-output-of-help","text":">>> help () Jumperless Native MicroPython Module Hardware Control Functions with Formatted Output : ( GPIO functions return formatted strings like HIGH / LOW , INPUT / OUTPUT , PULLUP / NONE , CONNECTED / DISCONNECTED ) DAC ( Digital - to - Analog Converter ): jumperless . dac_set ( channel , voltage ) - Set DAC output voltage jumperless . dac_get ( channel ) - Get DAC output voltage jumperless . set_dac ( channel , voltage ) - Alias for dac_set jumperless . get_dac ( channel ) - Alias for dac_get channel : 0 - 3 , DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL channel 0 / DAC0 : DAC 0 channel 1 / DAC1 : DAC 1 channel 2 / TOP_RAIL : top rail channel 3 / BOTTOM_RAIL : bottom rail voltage : - 8.0 to 8.0 V ADC ( Analog - to - Digital Converter ): jumperless . adc_get ( channel ) - Read ADC input voltage jumperless . get_adc ( channel ) - Alias for adc_get channel : 0 - 4 INA ( Current / Power Monitor ): jumperless . ina_get_current ( sensor ) - Read current in amps jumperless . ina_get_voltage ( sensor ) - Read shunt voltage jumperless . ina_get_bus_voltage ( sensor ) - Read bus voltage jumperless . ina_get_power ( sensor ) - Read power in watts Aliases : get_current , get_voltage , get_bus_voltage , get_power sensor : 0 or 1 GPIO : jumperless . gpio_set ( pin , value ) - Set GPIO pin state jumperless . gpio_get ( pin ) - Read GPIO pin state jumperless . gpio_set_dir ( pin , direction ) - Set GPIO pin direction jumperless . gpio_get_dir ( pin ) - Get GPIO pin direction jumperless . gpio_set_pull ( pin , pull ) - Set GPIO pull - up / down jumperless . gpio_get_pull ( pin ) - Get GPIO pull - up / down Aliases : set_gpio , get_gpio , set_gpio_dir , get_gpio_dir , etc . pin 1 - 8 : GPIO 1 - 8 pin 9 : UART Tx pin 10 : UART Rx value : True / False for HIGH / LOW direction : True / False for OUTPUT / INPUT pull : - 1 / 0 / 1 for PULL_DOWN / NONE / PULL_UP Node Connections : jumperless . connect ( node1 , node2 ) - Connect two nodes jumperless . disconnect ( node1 , node2 ) - Disconnect nodes jumperless . is_connected ( node1 , node2 ) - Check if nodes are connected jumperless . nodes_clear () - Clear all connections set node2 to - 1 to disconnect everything connected to node1 OLED Display : jumperless . oled_print ( \"text\" ) - Display text jumperless . oled_clear () - Clear display jumperless . oled_connect () - Connect OLED jumperless . oled_disconnect () - Disconnect OLED Clickwheel : jumperless . clickwheel_up ([ clicks ]) - Scroll up jumperless . clickwheel_down ([ clicks ]) - Scroll down jumperless . clickwheel_press () - Press button clicks : number of steps Status : jumperless . print_bridges () - Print all bridges jumperless . print_paths () - Print path between nodes jumperless . print_crossbars () - Print crossbar array jumperless . print_nets () - Print nets jumperless . print_chip_status () - Print chip status Probe Functions : jumperless . probe_read ([ blocking = True ]) - Read probe ( default : blocking ) jumperless . read_probe ([ blocking = True ]) - Read probe ( default : blocking ) jumperless . probe_read_blocking () - Wait for probe touch ( explicit ) jumperless . probe_read_nonblocking () - Check probe immediately ( explicit ) jumperless . get_button ([ blocking = True ]) - Get button state ( default : blocking ) jumperless . probe_button ([ blocking = True ]) - Get button state ( default : blocking ) jumperless . probe_button_blocking () - Wait for button press ( explicit ) jumperless . probe_button_nonblocking () - Check buttons immediately ( explicit ) Touch aliases : probe_wait , wait_probe , probe_touch , wait_touch ( always blocking ) Button aliases : button_read , read_button ( parameterized ) Non - blocking only : check_button , button_check Touch returns : ProbePad object ( 1 - 60 , D13_PAD , TOP_RAIL_PAD , LOGO_PAD_TOP , etc . ) Button returns : CONNECT , REMOVE , or NONE ( front = connect , rear = remove ) Misc : jumperless . arduino_reset () - Reset Arduino jumperless . probe_tap ( node ) - Tap probe on node ( unimplemented ) jumperless . run_app ( appName ) - Run app jumperless . format_output ( True / False ) - Enable / disable formatted output Help : jumperless . help () - Display this help Node Names : jumperless . node ( \"TOP_RAIL\" ) - Create node from string name jumperless . TOP_RAIL - Pre - defined node constant jumperless . D2 , jumperless . A0 , etc . - Arduino pin constants For global access : from jumperless_nodes import * Node names : All standard names like \"D13\" , \"A0\" , \"GPIO_1\" , etc . Examples ( all functions available globally ): dac_set ( TOP_RAIL , 3.3 ) # Set Top Rail to 3.3V using node set_dac ( 3 , 3.3 ) # Same as above using alias dac_set ( DAC0 , 5.0 ) # Set DAC0 using node constant voltage = get_adc ( 1 ) # Read ADC1 using alias connect ( TOP_RAIL , D13 ) # Connect using constants connect ( \"TOP_RAIL\" , 5 ) # Connect using strings connect ( 4 , 20 ) # Connect using numbers top_rail = node ( \"TOP_RAIL\" ) # Create node object connect ( top_rail , D13 ) # Mix objects and constants oled_print ( \"Fuck you!\" ) # Display text current = get_current ( 0 ) # Read current using alias set_gpio ( 1 , True ) # Set GPIO pin high using alias pad = probe_read () # Wait for probe touch if pad == 25 : print ( 'Touched pad 25!' ) # Check specific pad if pad == D13_PAD : connect ( D13 , TOP_RAIL ) # Auto-connect Arduino pin if pad == TOP_RAIL_PAD : show_voltage () # Show rail voltage if pad == LOGO_PAD_TOP : print ( 'Logo!' ) # Check logo pad button = get_button () # Wait for button press (blocking) if button == CONNECT_BUTTON : ... # Front button pressed if button == REMOVE_BUTTON : ... # Rear button pressed button = check_button () # Check buttons immediately if button == BUTTON_NONE : print ( 'None' ) # No button pressed pad = wait_touch () # Wait for touch btn = check_button () # Check button immediately if pad == D13_PAD and btn == CONNECT_BUTTON : connect ( D13 , TOP_RAIL ) Note : All functions and constants are available globally ! No need for 'jumperless.' prefix in REPL or single commands . >>>","title":"The entire output of help()"},{"location":"08-micropython/#the-entire-output-of-nodes_help","text":">>> nodes_help () Jumperless Node Reference ======================== NODE TYPES : Numbered : 1 - 60 ( breadboard ) Arduino : D0 - D13 , A0 - A7 ( nano header ) GPIO : GPIO_1 - GPIO_8 ( routable GPIO ) Power : TOP_RAIL , BOTTOM_RAIL , GND DAC : DAC0 , DAC1 ( analog outputs ) ADC : ADC0 - ADC4 , PROBE ( analog inputs ) Current : ISENSE_PLUS , ISENSE_MINUS UART : UART_TX , UART_RX Buffer : BUFFER_IN , BUFFER_OUT THREE WAYS TO USE NODES : 1. NUMBERS ( direct breadboard holes ): connect ( 1 , 30 ) # Connect holes 1 and 30 connect ( 15 , 42 ) # Any number 1-60 2. STRINGS ( case - insensitive names ): connect ( \"D13\" , \"TOP_RAIL\" ) # Arduino pin to power rail connect ( \"gpio_1\" , \"adc0\" ) # GPIO to ADC (case-insensitive) connect ( \"15\" , \"dac1\" ) # Mix numbers and names 3. CONSTANTS ( pre - defined objects ): connect ( TOP_RAIL , D13 ) # Using imported constants connect ( GPIO_1 , A0 ) # No quotes needed connect ( DAC0 , 25 ) # Mix constants and numbers MIXED USAGE : my_pin = \"D13\" # Create node object from string connect ( my_pin , TOP_RAIL ) # Use node object with constant oled_print ( my_pin ) # Display shows 'D13' COMMON ALIASES ( many names work for same node ): \"TOP_RAIL\" = \"T_R\" \"GPIO_1\" = \"GPIO1\" = \"GP1\" \"DAC0\" = \"DAC_0\" \"UART_TX\" = \"TX\" NOTES : - String names are case - insensitive : \"d13\" = \"D13\" = \"nAnO_d13\" - Constants are case - sensitive : use D13 , not d13 - All three methods work in any function","title":"The entire output of nodes_help()"},{"location":"08.5-jfs/","text":"JFS (Jumperless FileSystem) Module The jfs module is basically like MicroPython's vfs and parts of os , but kinda written in a style that's probably more familiar to Arduino-style C++ people (me). It uses the almost standardized API shared by FatFS (the one Jumperless actually uses), LittleFS , and SDFS , but still has been Pythonified to use types that are easier to work with in MicroPython. Quick Reference File Operations: jfs . open ( path , mode ) - Opens file, returns file handle jfs . read ( file , size = 1024 ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . seek ( file , position , whence = 0 ) - Seek in file jfs . tell ( file ) - Get current position jfs . size ( file ) - Get file size jfs . available ( file ) - Get bytes available Directory Operations: jfs . exists ( path ) - Check if path exists (returns True/False) jfs . listdir ( path ) - List directory contents (returns list) jfs . mkdir ( path ) - Create directory jfs . rmdir ( path ) - Remove directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename/move file Filesystem Info: jfs . info () - Returns (total, used, free) tuple Usage import jfs #you don't actually need this, jfs is imported globally by default # List files in the root directory files = jfs . listdir ( '/' ) # returns a python list print ( files ) Output: [ 'config.txt' , 'nodeFileSlot0.txt' , 'python_scripts/' , 'nodeFileSlot1.txt' , 'nodeFileSlot2.txt' , 'nodeFileSlot3.txt' , 'nodeFileSlot4.txt' , 'nodeFileSlot5.txt' , 'nodeFileSlot6.txt' , 'nodeFileSlot7.txt' , 'net_colors/' ] If you want to make this print with subdirectories files = jfs . listdir ( '/' ) for file in range ( len ( files )): print ( files [ file ]) if files [ file ] . endswith ( \"/\" ): subdir = jfs . listdir ( files [ file ]) for i in range ( len ( subdir )): print ( \" - \" + subdir [ i ]) Output: nodeFileSlot0 . txt python_scripts / - history . txt - examples / - fake_gpio . py - _temp_repl_edit . py - Hey . txt - script_1 . py - script_2 . py - script_3 . py - log . txt - lib / - script_4 . py - pathtest . py nodeFileSlot1 . txt nodeFileSlot2 . txt nodeFileSlot3 . txt nodeFileSlot4 . txt nodeFileSlot5 . txt nodeFileSlot6 . txt nodeFileSlot7 . txt net_colors / - netColorsSlot0 . txt File API File objects returned by jfs . open () support method calls directly on the object: # Object-oriented file operations # Write-only mode f = jfs . open ( 'hello.txt' , 'w' ) f . write ( 'Hello, Jumperless!' ) f . close () # Read from the file (need to reopen or use w+/r+ mode) f = jfs . open ( 'hello.txt' , 'r' ) content = f . read () # Read from file object size = f . size () # Get file size f . close () # Read-write mode (truncates file) f = jfs . open ( 'hello.txt' , 'w+' ) f . write ( 'Hello, Jumperless!' ) f . seek ( 0 ) # Seek to beginning to read what we wrote content = f . read () # Now this works! f . close () # Context manager support (automatically closes file) with jfs . open ( 'data.txt' , 'w+' ) as f : f . write ( 'This file will be automatically closed' ) f . seek ( 0 ) # Reset to beginning content = f . read () # Read back what we wrote pos = f . tell () # Get current position name = f . name () # Get file name Other ways to do the same thing ### 2. Module-Level Functions You can also use module-level functions with file handles: f = jfs . open ( 'hello.txt' , 'w' ) jfs . write ( f , 'Hello, Jumperless!' ) # Module-level function jfs . seek ( f , 0 ) # Module-level function content = jfs . read ( f ) # Module-level function jfs . close ( f ) # Module-level function ### 3. Direct String Operations (For simple cases) # Write/read entire files at once (no file handles needed) jfs . write ( 'config.txt' , 'key=value \\n other=setting' ) content = jfs . read ( 'config.txt' ) File Modes When using jfs . open ( path , mode ) , the following modes are supported: Mode Description Read Write Create 'r' Read only \u2705 \u274c \u274c 'w' Write only \u274c \u2705 \u2705 'a' Append only \u274c \u2705 \u2705 'r+' Read + Write \u2705 \u2705 \u274c 'w+' Read + Write \u2705 \u2705 \u2705 'a+' Read + Append \u2705 \u2705 \u2705 Important: You cannot read from a file opened in write-only mode ( 'w' or 'a' ). Use 'w+' , 'r+' , or 'a+' if you need both read and write access. Open a file for writing f = jfs . open ( 'hello.txt' , 'w' ) f . write ( 'Hello, Jumperless!' ) # Now works with object-oriented API! f . close () Directory Operations jfs . listdir ( path ) Returns a list containing the names of the entries in the directory given by path . path (str): The path to the directory. Example: # List contents of the root directory print ( jfs . listdir ( '/' )) # List contents of a subdirectory jfs . mkdir ( '/my_dir' ) print ( jfs . listdir ( '/my_dir' )) jfs . mkdir ( path ) Create a new directory. path (str): The path of the new directory. jfs . rmdir ( path ) Remove an empty directory. path (str): The path of the directory to remove. jfs . remove ( path ) Remove a file. path (str): The path of the file to remove. jfs . rename ( old_path , new_path ) Rename a file or directory. old_path (str): The current path. new_path (str): The new path. jfs . exists ( path ) Check if a file or directory exists. path (str): The path to check. Returns True if it exists, False otherwise. jfs . stat ( path ) Get status of a file or directory. path (str): The path of the file or directory. Returns a tuple with file information (mode, size, etc.), similar to os . stat () . Filesystem Information jfs . info () Get information about the filesystem. Returns a tuple ( total_bytes , used_bytes , free_bytes ) . Example: total , used , free = jfs . info () print ( \"Filesystem Size: \" + str ( total / 1024 ) + \" KB\" ) print ( \"Used: \" + str ( used / 1024 ) + \" KB\" ) print ( \"Free: \" + str ( free / 1024 ) + \" KB\" ) File I/O The jfs module supports standard file opening and handling using jfs . open () and file objects, including support for the with statement for automatic resource management. jfs . open ( path , mode = 'r' ) Open a file and return a corresponding file object. path (str): The path to the file. mode (str, optional): The mode in which the file is opened. Defaults to 'r' . 'r' : Read (default). 'w' : Write (creates a new file or truncates an existing one). 'a' : Append. 'r+' : Read and write. 'w+' : Write and read (creates/truncates). 'a+' : Append and read. Example: # Open a file for reading f = jfs . open ( 'config.txt' , 'r' ) content = f . read () f . close () # Use 'with' for automatic closing with jfs . open ( 'data.log' , 'a' ) as log_file : log_file . write ( 'New log entry. \\\\ n' ) File Object Methods The file object returned by jfs . open () has the following methods: file . read ([ size ]) Read size bytes from the file. If size is omitted or negative, the entire file is read. file . write ( data ) Write the given string or bytes data to the file. Returns the number of bytes written. file . close () Close the file. A closed file cannot be read or written to. file . seek ( offset , [ whence ]) Change the stream position. * offset : The byte offset. * whence (optional): * 0 : Seek from the start of the stream (default). Use jfs . SEEK_SET . * 1 : Seek from the current position. Use jfs . SEEK_CUR . * 2 : Seek from the end of the stream. Use jfs . SEEK_END . file . tell () Return the current stream position. * Aliases : file . position () file . size () Return the total size of the file in bytes. file . available () Return the number of bytes available to be read from the current position to the end of the file. file . name Returns the name of the file. Module-Level File Operations For convenience, the jfs module also provides functions that operate directly on file handles returned by jfs . open () . This can be useful in some scripting scenarios but using file object methods is generally preferred for clarity. jfs . read ( file_handle , [ size ]) jfs . write ( file_handle , data ) jfs . close ( file_handle ) jfs . seek ( file_handle , offset , [ whence ]) jfs . tell ( file_handle ) jfs . size ( file_handle ) jfs . available ( file_handle ) Example: file_handle = jfs . open ( 'temp.txt' , 'w' ) jfs . write ( file_handle , 'some data' ) jfs . close ( file_handle )","title":"JFS (Jumperless FileSystem) Module"},{"location":"08.5-jfs/#jfs-jumperless-filesystem-module","text":"The jfs module is basically like MicroPython's vfs and parts of os , but kinda written in a style that's probably more familiar to Arduino-style C++ people (me). It uses the almost standardized API shared by FatFS (the one Jumperless actually uses), LittleFS , and SDFS , but still has been Pythonified to use types that are easier to work with in MicroPython.","title":"JFS (Jumperless FileSystem) Module"},{"location":"08.5-jfs/#quick-reference","text":"File Operations: jfs . open ( path , mode ) - Opens file, returns file handle jfs . read ( file , size = 1024 ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . seek ( file , position , whence = 0 ) - Seek in file jfs . tell ( file ) - Get current position jfs . size ( file ) - Get file size jfs . available ( file ) - Get bytes available Directory Operations: jfs . exists ( path ) - Check if path exists (returns True/False) jfs . listdir ( path ) - List directory contents (returns list) jfs . mkdir ( path ) - Create directory jfs . rmdir ( path ) - Remove directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename/move file Filesystem Info: jfs . info () - Returns (total, used, free) tuple","title":"Quick Reference"},{"location":"08.5-jfs/#usage","text":"import jfs #you don't actually need this, jfs is imported globally by default # List files in the root directory files = jfs . listdir ( '/' ) # returns a python list print ( files ) Output: [ 'config.txt' , 'nodeFileSlot0.txt' , 'python_scripts/' , 'nodeFileSlot1.txt' , 'nodeFileSlot2.txt' , 'nodeFileSlot3.txt' , 'nodeFileSlot4.txt' , 'nodeFileSlot5.txt' , 'nodeFileSlot6.txt' , 'nodeFileSlot7.txt' , 'net_colors/' ] If you want to make this print with subdirectories files = jfs . listdir ( '/' ) for file in range ( len ( files )): print ( files [ file ]) if files [ file ] . endswith ( \"/\" ): subdir = jfs . listdir ( files [ file ]) for i in range ( len ( subdir )): print ( \" - \" + subdir [ i ]) Output: nodeFileSlot0 . txt python_scripts / - history . txt - examples / - fake_gpio . py - _temp_repl_edit . py - Hey . txt - script_1 . py - script_2 . py - script_3 . py - log . txt - lib / - script_4 . py - pathtest . py nodeFileSlot1 . txt nodeFileSlot2 . txt nodeFileSlot3 . txt nodeFileSlot4 . txt nodeFileSlot5 . txt nodeFileSlot6 . txt nodeFileSlot7 . txt net_colors / - netColorsSlot0 . txt","title":"Usage"},{"location":"08.5-jfs/#file-api","text":"File objects returned by jfs . open () support method calls directly on the object: # Object-oriented file operations # Write-only mode f = jfs . open ( 'hello.txt' , 'w' ) f . write ( 'Hello, Jumperless!' ) f . close () # Read from the file (need to reopen or use w+/r+ mode) f = jfs . open ( 'hello.txt' , 'r' ) content = f . read () # Read from file object size = f . size () # Get file size f . close () # Read-write mode (truncates file) f = jfs . open ( 'hello.txt' , 'w+' ) f . write ( 'Hello, Jumperless!' ) f . seek ( 0 ) # Seek to beginning to read what we wrote content = f . read () # Now this works! f . close () # Context manager support (automatically closes file) with jfs . open ( 'data.txt' , 'w+' ) as f : f . write ( 'This file will be automatically closed' ) f . seek ( 0 ) # Reset to beginning content = f . read () # Read back what we wrote pos = f . tell () # Get current position name = f . name () # Get file name Other ways to do the same thing ### 2. Module-Level Functions You can also use module-level functions with file handles: f = jfs . open ( 'hello.txt' , 'w' ) jfs . write ( f , 'Hello, Jumperless!' ) # Module-level function jfs . seek ( f , 0 ) # Module-level function content = jfs . read ( f ) # Module-level function jfs . close ( f ) # Module-level function ### 3. Direct String Operations (For simple cases) # Write/read entire files at once (no file handles needed) jfs . write ( 'config.txt' , 'key=value \\n other=setting' ) content = jfs . read ( 'config.txt' )","title":"File API"},{"location":"08.5-jfs/#file-modes","text":"When using jfs . open ( path , mode ) , the following modes are supported: Mode Description Read Write Create 'r' Read only \u2705 \u274c \u274c 'w' Write only \u274c \u2705 \u2705 'a' Append only \u274c \u2705 \u2705 'r+' Read + Write \u2705 \u2705 \u274c 'w+' Read + Write \u2705 \u2705 \u2705 'a+' Read + Append \u2705 \u2705 \u2705 Important: You cannot read from a file opened in write-only mode ( 'w' or 'a' ). Use 'w+' , 'r+' , or 'a+' if you need both read and write access.","title":"File Modes"},{"location":"08.5-jfs/#open-a-file-for-writing","text":"f = jfs . open ( 'hello.txt' , 'w' ) f . write ( 'Hello, Jumperless!' ) # Now works with object-oriented API! f . close ()","title":"Open a file for writing"},{"location":"08.5-jfs/#directory-operations","text":"","title":"Directory Operations"},{"location":"08.5-jfs/#jfslistdirpath","text":"Returns a list containing the names of the entries in the directory given by path . path (str): The path to the directory. Example: # List contents of the root directory print ( jfs . listdir ( '/' )) # List contents of a subdirectory jfs . mkdir ( '/my_dir' ) print ( jfs . listdir ( '/my_dir' ))","title":"jfs.listdir(path)"},{"location":"08.5-jfs/#jfsmkdirpath","text":"Create a new directory. path (str): The path of the new directory.","title":"jfs.mkdir(path)"},{"location":"08.5-jfs/#jfsrmdirpath","text":"Remove an empty directory. path (str): The path of the directory to remove.","title":"jfs.rmdir(path)"},{"location":"08.5-jfs/#jfsremovepath","text":"Remove a file. path (str): The path of the file to remove.","title":"jfs.remove(path)"},{"location":"08.5-jfs/#jfsrenameold_path-new_path","text":"Rename a file or directory. old_path (str): The current path. new_path (str): The new path.","title":"jfs.rename(old_path, new_path)"},{"location":"08.5-jfs/#jfsexistspath","text":"Check if a file or directory exists. path (str): The path to check. Returns True if it exists, False otherwise.","title":"jfs.exists(path)"},{"location":"08.5-jfs/#jfsstatpath","text":"Get status of a file or directory. path (str): The path of the file or directory. Returns a tuple with file information (mode, size, etc.), similar to os . stat () .","title":"jfs.stat(path)"},{"location":"08.5-jfs/#filesystem-information","text":"","title":"Filesystem Information"},{"location":"08.5-jfs/#jfsinfo","text":"Get information about the filesystem. Returns a tuple ( total_bytes , used_bytes , free_bytes ) . Example: total , used , free = jfs . info () print ( \"Filesystem Size: \" + str ( total / 1024 ) + \" KB\" ) print ( \"Used: \" + str ( used / 1024 ) + \" KB\" ) print ( \"Free: \" + str ( free / 1024 ) + \" KB\" )","title":"jfs.info()"},{"location":"08.5-jfs/#file-io","text":"The jfs module supports standard file opening and handling using jfs . open () and file objects, including support for the with statement for automatic resource management.","title":"File I/O"},{"location":"08.5-jfs/#jfsopenpath-moder","text":"Open a file and return a corresponding file object. path (str): The path to the file. mode (str, optional): The mode in which the file is opened. Defaults to 'r' . 'r' : Read (default). 'w' : Write (creates a new file or truncates an existing one). 'a' : Append. 'r+' : Read and write. 'w+' : Write and read (creates/truncates). 'a+' : Append and read. Example: # Open a file for reading f = jfs . open ( 'config.txt' , 'r' ) content = f . read () f . close () # Use 'with' for automatic closing with jfs . open ( 'data.log' , 'a' ) as log_file : log_file . write ( 'New log entry. \\\\ n' )","title":"jfs.open(path, mode=&#39;r&#39;)"},{"location":"08.5-jfs/#file-object-methods","text":"The file object returned by jfs . open () has the following methods:","title":"File Object Methods"},{"location":"08.5-jfs/#filereadsize","text":"Read size bytes from the file. If size is omitted or negative, the entire file is read.","title":"file.read([size])"},{"location":"08.5-jfs/#filewritedata","text":"Write the given string or bytes data to the file. Returns the number of bytes written.","title":"file.write(data)"},{"location":"08.5-jfs/#fileclose","text":"Close the file. A closed file cannot be read or written to.","title":"file.close()"},{"location":"08.5-jfs/#fileseekoffset-whence","text":"Change the stream position. * offset : The byte offset. * whence (optional): * 0 : Seek from the start of the stream (default). Use jfs . SEEK_SET . * 1 : Seek from the current position. Use jfs . SEEK_CUR . * 2 : Seek from the end of the stream. Use jfs . SEEK_END .","title":"file.seek(offset, [whence])"},{"location":"08.5-jfs/#filetell","text":"Return the current stream position. * Aliases : file . position ()","title":"file.tell()"},{"location":"08.5-jfs/#filesize","text":"Return the total size of the file in bytes.","title":"file.size()"},{"location":"08.5-jfs/#fileavailable","text":"Return the number of bytes available to be read from the current position to the end of the file.","title":"file.available()"},{"location":"08.5-jfs/#filename","text":"Returns the name of the file.","title":"file.name"},{"location":"08.5-jfs/#module-level-file-operations","text":"For convenience, the jfs module also provides functions that operate directly on file handles returned by jfs . open () . This can be useful in some scripting scenarios but using file object methods is generally preferred for clarity. jfs . read ( file_handle , [ size ]) jfs . write ( file_handle , data ) jfs . close ( file_handle ) jfs . seek ( file_handle , offset , [ whence ]) jfs . tell ( file_handle ) jfs . size ( file_handle ) jfs . available ( file_handle ) Example: file_handle = jfs . open ( 'temp.txt' , 'w' ) jfs . write ( file_handle , 'some data' ) jfs . close ( file_handle )","title":"Module-Level File Operations"},{"location":"09-odds-and-ends/","text":"Odds and Ends Animations The Jumperless uses LED animations to show the state of different components on the breadboard. Rail Animations If it's a rail, those are animated and should be a continuous slow pulsing toward the top or bottom depending on the rail. ADC Animations ADCs are green at 0V, and go through the spectrum to red at +5V, and get whiter hot pink toward +8V. Negative voltages are kinda blue/icy and do that same thing with the \"cold\" colors towards -8V. GPIO Animations Input Mode GPIO as inputs are animated with a white pulsing (this might be broken in that FW release, I'm fixing that right now actually, and will just be purple/white) when floating, red for high, green for low Output Mode GPIO outputs will be either green or red depending on their state What's that BUFFER_IN - DAC_0 bridge that's always there? That gets added to power the probe LEDs , it's kinda weird, but to multiplex 3.3V, GND, LED data, 2 buttons, and a +-9V tolerant analog line over the 4 wires on a TRRS cable, the line powering those LEDs is shared. The connect / measure switch is a Dual Pole Dual Throw (DPDT) switch. The probe tip needs to be at a steady 3.3V to be read by the probe sense pads which is a big resistive divider sensed by a single ADC . When you have it in select mode, the probe tip is getting 3.3V from a GPIO on the RP2350B driven high , and the LEDs get their power from the analog line, which is ROUTABLE_BUFFER_IN connected to DAC 0 set to 3.3V. When you switch to measure mode, those roles get swapped, the LEDs are powered by that GPIO , and the probe tip is now ROUTABLE_BUFFER_IN . In the current firmware, that just stays at 3.3V so you can kinda sense pads in either mode (you may notice the sensing is a lot wonkier, that's because the DAC isn't perfectly calibrated to output exactly 3.3V.) But in the future, there will be some other stuff you can do in that mode treating it as an analog line (and of course, I'll forget to update this, if it's after like June 2025, double check this is still true.) Why am I using one of the precious two DACs and not another GPIO? The answer is switch position sensing. You may notice there's no obvious way for the Jumperless to know where the switch is set, so I had to get creative on this one. DAC 0 's output is hardwired to go through a current sense shunt resistor, so when DAC 0 is powering the probe LEDs , they'll be drawing some current I can measure with one of the INA219 s, and therefore I can be reasonably confident that the switch is in the select position. If you need both DAC s, you can just get rid of this connection and the probe LEDs won't light up, but other than aesthetics, it really has no effect on functionality. Or you connect ROUTABLE_BUFFER_IN to a GPIO and set it high and just lose the ability to sense where the switch is. AI Generated Wiki If you want to read a wiki generated by AI and ask it questions about how this thing works and how to use it, DeepWiki was surprisingly accurate (enough.) The docs on this site are more about how to use your Jumperless, this is more geared toward helping understand the circuitry and code. Onboard Help Use help or [ command ] ? for onboard documentation","title":"Odds and Ends"},{"location":"09-odds-and-ends/#odds-and-ends","text":"","title":"Odds and Ends"},{"location":"09-odds-and-ends/#animations","text":"The Jumperless uses LED animations to show the state of different components on the breadboard.","title":"Animations"},{"location":"09-odds-and-ends/#rail-animations","text":"If it's a rail, those are animated and should be a continuous slow pulsing toward the top or bottom depending on the rail.","title":"Rail Animations"},{"location":"09-odds-and-ends/#adc-animations","text":"ADCs are green at 0V, and go through the spectrum to red at +5V, and get whiter hot pink toward +8V. Negative voltages are kinda blue/icy and do that same thing with the \"cold\" colors towards -8V.","title":"ADC Animations"},{"location":"09-odds-and-ends/#gpio-animations","text":"","title":"GPIO Animations"},{"location":"09-odds-and-ends/#input-mode","text":"GPIO as inputs are animated with a white pulsing (this might be broken in that FW release, I'm fixing that right now actually, and will just be purple/white) when floating, red for high, green for low","title":"Input Mode"},{"location":"09-odds-and-ends/#output-mode","text":"GPIO outputs will be either green or red depending on their state","title":"Output Mode"},{"location":"09-odds-and-ends/#whats-that-buffer_in-dac_0-bridge-thats-always-there","text":"That gets added to power the probe LEDs , it's kinda weird, but to multiplex 3.3V, GND, LED data, 2 buttons, and a +-9V tolerant analog line over the 4 wires on a TRRS cable, the line powering those LEDs is shared. The connect / measure switch is a Dual Pole Dual Throw (DPDT) switch. The probe tip needs to be at a steady 3.3V to be read by the probe sense pads which is a big resistive divider sensed by a single ADC . When you have it in select mode, the probe tip is getting 3.3V from a GPIO on the RP2350B driven high , and the LEDs get their power from the analog line, which is ROUTABLE_BUFFER_IN connected to DAC 0 set to 3.3V. When you switch to measure mode, those roles get swapped, the LEDs are powered by that GPIO , and the probe tip is now ROUTABLE_BUFFER_IN . In the current firmware, that just stays at 3.3V so you can kinda sense pads in either mode (you may notice the sensing is a lot wonkier, that's because the DAC isn't perfectly calibrated to output exactly 3.3V.) But in the future, there will be some other stuff you can do in that mode treating it as an analog line (and of course, I'll forget to update this, if it's after like June 2025, double check this is still true.)","title":"What's that BUFFER_IN - DAC_0 bridge that's always there?"},{"location":"09-odds-and-ends/#why-am-i-using-one-of-the-precious-two-dacs-and-not-another-gpio","text":"The answer is switch position sensing. You may notice there's no obvious way for the Jumperless to know where the switch is set, so I had to get creative on this one. DAC 0 's output is hardwired to go through a current sense shunt resistor, so when DAC 0 is powering the probe LEDs , they'll be drawing some current I can measure with one of the INA219 s, and therefore I can be reasonably confident that the switch is in the select position. If you need both DAC s, you can just get rid of this connection and the probe LEDs won't light up, but other than aesthetics, it really has no effect on functionality. Or you connect ROUTABLE_BUFFER_IN to a GPIO and set it high and just lose the ability to sense where the switch is.","title":"Why am I using one of the precious two DACs and not another GPIO?"},{"location":"09-odds-and-ends/#ai-generated-wiki","text":"If you want to read a wiki generated by AI and ask it questions about how this thing works and how to use it, DeepWiki was surprisingly accurate (enough.) The docs on this site are more about how to use your Jumperless, this is more geared toward helping understand the circuitry and code.","title":"AI Generated Wiki"},{"location":"09-odds-and-ends/#onboard-help","text":"Use help or [ command ] ? for onboard documentation","title":"Onboard Help"},{"location":"09-odds-and-ends/#_1","text":"","title":""},{"location":"09.5-micropythonAPIreference/","text":"Jumperless MicroPython API Reference This document provides a comprehensive reference for the jumperless MicroPython module, which allows for direct control over the Jumperless hardware. A Note on Usage All functions and constants from the jumperless module are automatically imported into the global namespace. This means you can call them directly (e.g., connect ( 1 , 5 ) ) without needing the jumperless . prefix. There are three primary ways to specify nodes in functions: 1. By Number : Use the integer corresponding to the breadboard row (1-60). 2. By String Name : Use a case-insensitive string for any named node (e.g., \"d13\" , \"TOP_RAIL\" ). 3. By Constant : Use the predefined, case-sensitive constant for a node (e.g., D13 , TOP_RAIL ). DAC (Digital-to-Analog Converter) - Examples : dac_set ( channel , voltage ) - Set DAC output voltage dac_get ( channel ) - Get DAC output voltage set_dac ( channel , voltage ) - Alias for dac_set get_dac ( channel ) - Alias for dac_get channel : 0 - 3 , DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL channel 0 / DAC0 : DAC 0 channel 1 / DAC1 : DAC 1 channel 2 / TOP_RAIL : top rail channel 3 / BOTTOM_RAIL : bottom rail voltage : - 8.0 to 8.0 V ADC (Analog-to-Digital Converter) - Examples : adc_get ( channel ) - Read ADC input voltage get_adc ( channel ) - Alias for adc_get channel : 0 - 4 INA (Current/Power Monitor) - Examples : ina_get_current ( sensor ) - Read current in amps ina_get_voltage ( sensor ) - Read shunt voltage ina_get_bus_voltage ( sensor ) - Read bus voltage ina_get_power ( sensor ) - Read power in watts Aliases: get_current, get_voltage, get_bus_voltage, get_power sensor : 0 or 1 GPIO - Examples : gpio_set ( pin , value ) - Set GPIO pin state gpio_get ( pin ) - Read GPIO pin state gpio_set_dir ( pin , direction ) - Set GPIO pin direction gpio_get_dir ( pin ) - Get GPIO pin direction gpio_set_pull ( pin , pull ) - Set GPIO pull-up/down gpio_get_pull ( pin ) - Get GPIO pull-up/down Aliases: set_gpio, get_gpio, set_gpio_dir, get_gpio_dir, etc. pin 1 - 8 : GPIO 1 - 8 pin 9 : UART Tx pin 10 : UART Rx value : True / False for HIGH / LOW direction : True / False for OUTPUT / INPUT pull : - 1 / 0 / 1 for PULL_DOWN / NONE / PULL_UP PWM (Pulse Width Modulation) - Examples : pwm ( pin , [ frequency ], [ duty ]) - Setup PWM on GPIO pin pwm_set_duty_cycle ( pin , duty ) - Set PWM duty cycle pwm_set_frequency ( pin , freq ) - Set PWM frequency pwm_stop ( pin ) - Stop PWM on pin Pin: 1-8 (numeric) or GPIO_1-GPIO_8 (constants) Frequency: 10Hz to 62.5MHz, Duty: 0.0 to 1.0 Aliases: set_pwm, set_pwm_duty_cycle, set_pwm_frequency, stop_pwm pin : 1 - 8 GPIO pins only frequency : 1 - 62.5 MHz default 1000 Hz duty_cycle : 0.0 - 1.0 default 0.5 ( 50 % ) Node Connections - Examples : connect ( node1 , node2 ) - Connect two nodes disconnect ( node1 , node2 ) - Disconnect nodes is_connected ( node1 , node2 ) - Check if nodes are connected nodes_clear () - Clear all connections set node2 to -1 to disconnect everything connected to node1 OLED Display - Examples : oled_print ( \"text\" ) - Display text oled_clear () - Clear display oled_connect () - Connect OLED oled_disconnect () - Disconnect OLED Status - Examples : print_bridges () - Print all bridges print_paths () - Print path between nodes print_crossbars () - Print crossbar array print_nets () - Print nets print_chip_status () - Print chip status Probe Functions - Examples : probe_read_blocking () - Wait for probe touch (don't return until a pad is touched) probe_read_nonblocking () - Check probe immediately (return -1 if no pad is touched) get_button ([ blocking = True ]) - Get button state (default: blocking) probe_button ([ blocking = True ]) - Get button state (default: blocking) probe_button_blocking () - Wait for button press probe_button_nonblocking () - Check buttons immediately Non-blocking only: check_button, button_check Touch returns: ProbePad object (1-60, D13_PAD, TOP_RAIL_PAD, LOGO_PAD_TOP, etc.) Button returns: CONNECT, REMOVE, or NONE (front=connect, rear=remove) JFS (Jumperless File System): jfs . open ( path , mode ) - Opens file, returns file handle jfs . read ( file , size = 1024 ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . seek ( file , position , whence = 0 ) - Seek in file jfs . tell ( file ) - Get current position jfs . size ( file ) - Get file size jfs . available ( file ) - Get bytes available jfs . exists ( path ) - Check if path exists (returns True/False) jfs . listdir ( path ) - List directory contents (returns list) jfs . mkdir ( path ) - Create directory jfs . rmdir ( path ) - Remove directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename/move file jfs . info () - Returns (total, used, free) tuple Misc - Examples : arduino_reset () - Reset Arduino probe_tap ( node ) - Tap probe on node (unimplemented) run_app ( 'appName' ) - Run app Help - Examples : help () - Display this help nodes_help () - Show available nodes and how to address them Node Connections These functions manage the connections between nodes on the breadboard and special function pins. connect ( node1 , node2 , [ save = True ]) Creates a bridge between two nodes. node1 , node2 : The nodes to connect. Can be integers, strings, or constants. save (optional): If True (default), the connection is saved to the current slot's node file. If False , it's a temporary connection for the current session. Example: # Connect breadboard row 1 to row 30 connect ( 1 , 30 ) # Connect Arduino D13 to the top power rail connect ( D13 , TOP_RAIL ) # Connect GPIO 1 to ADC 0 using strings connect ( \"GPIO_1\" , \"ADC0\" ) disconnect ( node1 , node2 ) Removes a specific bridge between two nodes. node1 , node2 : The two nodes to disconnect. To remove all connections from a single node, set node2 to - 1 . Example: # Remove the bridge between rows 1 and 30 disconnect ( 1 , 30 ) # Remove all connections from GPIO_1 disconnect ( GPIO_1 , - 1 ) is_connected ( node1 , node2 ) Checks if a direct or indirect connection exists between two nodes. Returns a custom ConnectionState object which evaluates to True if connected ( CONNECTED ) and False if not ( DISCONNECTED ). Example: if is_connected ( D13 , TOP_RAIL ): print ( \"D13 is connected to the top rail.\" ) state = is_connected ( 1 , 2 ) print ( state ) # Prints \"CONNECTED\" or \"DISCONNECTED\" nodes_clear () Removes all connections from the board. Example: nodes_clear () print ( \"All connections cleared.\" ) node ( name_or_id ) Creates a node object from a string name or integer ID. This is useful for storing a node reference in a variable. Example: my_pin = node ( \"D7\" ) led_pin = node ( 15 ) connect ( my_pin , led_pin ) oled_print ( my_pin ) # Displays 'D7' on the OLED DAC (Digital-to-Analog Converter) Functions for controlling the analog voltage outputs. dac_set ( channel , voltage , [ save = True ]) Sets the output voltage for a specific DAC channel. channel : The DAC channel to set. Can be an integer (0-3) or a node constant ( DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL ). voltage : The desired voltage (from -8.0V to 8.0V). save (optional): If True (default), the setting is saved to the config file. Aliases : set_dac () Channels: * 0 or DAC0 : The 5V tolerant DAC output. * 1 or DAC1 : The 8V tolerant DAC output. * 2 or TOP_RAIL : The top power rail. * 3 or BOTTOM_RAIL : The bottom power rail. Example: # Set the top rail to 5V dac_set ( TOP_RAIL , 5.0 ) # Set DAC0 to 1.25V set_dac ( DAC0 , 1.25 ) dac_get ( channel ) Reads the currently set voltage for a DAC channel. channel : The DAC channel to read. Returns a float. Aliases : get_dac () Example: voltage = dac_get ( TOP_RAIL ) print ( \"Top Rail voltage: \" + str ( voltage )) ADC (Analog-to-Digital Converter) Functions for measuring analog voltages. adc_get ( channel ) Reads the voltage from a specific ADC channel. channel : The ADC channel to read (0-4). Returns a float. Aliases : get_adc () Channels: * 0 - 3 : 8V tolerant ADC inputs. * 4 : 5V tolerant ADC input. Example: voltage = adc_get ( 0 ) print ( \"ADC0 voltage: \" + str ( voltage )) GPIO (General Purpose Input/Output) Functions for controlling the digital I/O pins. gpio_set ( pin , value ) Sets the output state of a GPIO pin. pin : The GPIO pin number (1-10). value : True for HIGH, False for LOW. Aliases : set_gpio () gpio_get ( pin ) Reads the state of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIOState object ( HIGH , LOW , or FLOATING ). Aliases : get_gpio () gpio_set_dir ( pin , direction ) Sets the direction of a GPIO pin. pin : The GPIO pin number (1-10). direction : True for OUTPUT, False for INPUT. Aliases : set_gpio_dir () gpio_get_dir ( pin ) Reads the direction of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIODirection object ( INPUT or OUTPUT ). Aliases : get_gpio_dir () gpio_set_pull ( pin , pull ) Configures the internal pull resistor for a GPIO pin. pin : The GPIO pin number (1-10). pull : 1 for PULLUP, - 1 for PULLDOWN, 0 for NONE. Aliases : set_gpio_pull () gpio_get_pull ( pin ) Reads the pull resistor configuration of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIOPull object ( PULLUP , PULLDOWN , or NONE ). Aliases : get_gpio_pull () Pinout: * 1 - 8 : Routable GPIO pins GPIO_1 to GPIO_8 . * 9 : UART_TX . * 10 : UART_RX . Example: # Set GPIO 1 as an output and turn it on gpio_set_dir ( 1 , True ) gpio_set ( 1 , True ) # Set GPIO 2 as an input with a pull-up gpio_set_dir ( 2 , False ) gpio_set_pull ( 2 , 1 ) # Read the state of GPIO 2 state = gpio_get ( 2 ) if state == HIGH : print ( \"GPIO 2 is HIGH\" ) PWM (Pulse-Width Modulation) Functions for generating PWM signals on GPIO pins. pwm ( pin , [ frequency ], [ duty_cycle ]) Sets up and starts a PWM signal on a GPIO pin. pin : The GPIO pin to use (1-8). frequency (optional): The PWM frequency in Hz (10.0 to 62,500,000.0). Defaults to 1000. duty_cycle (optional): The duty cycle from 0.0 to 1.0. Defaults to 0.5. Aliases : set_pwm () pwm_set_duty_cycle ( pin , duty_cycle ) Changes the duty cycle of an existing PWM signal. pin : The GPIO pin number (1-8). duty_cycle : The new duty cycle (0.0 to 1.0). Aliases : set_pwm_duty_cycle () pwm_set_frequency ( pin , frequency ) Changes the frequency of an existing PWM signal. pin : The GPIO pin number (1-8). frequency : The new frequency in Hz. Aliases : set_pwm_frequency () pwm_stop ( pin ) Stops the PWM signal on a GPIO pin. pin : The GPIO pin number (1-8). Aliases : stop_pwm () Example: # Start a 1kHz, 25% duty cycle PWM on GPIO_1 pwm ( GPIO_1 , 1000 , 0.25 ) # Change the duty cycle to 75% pwm_set_duty_cycle ( GPIO_1 , 0.75 ) # Stop the PWM signal pwm_stop ( GPIO_1 ) INA (Current/Power Monitor) Functions for reading data from the INA219 current sensors. ina_get_current ( sensor ) Reads the current in Amps. * sensor : The sensor to read (0 or 1). * Aliases : get_current () ina_get_voltage ( sensor ) Reads the shunt voltage in Volts. * sensor : The sensor to read (0 or 1). * Aliases : get_voltage () ina_get_bus_voltage ( sensor ) Reads the bus voltage in Volts. * sensor : The sensor to read (0 or 1). * Aliases : get_bus_voltage () ina_get_power ( sensor ) Reads the power in Watts. * sensor : The sensor to read (0 or 1). * Aliases : get_power () Example: current_mA = ina_get_current ( 0 ) * 1000 print ( \"Current: \" + str ( current_mA ) + \" mA\" ) OLED Display Functions for controlling the onboard OLED display. oled_print ( text , [ size = 2 ]) Displays text on the OLED screen. It can print strings, numbers, and custom Jumperless types. text : The content to display. size (optional): The font size (1 or 2). Defaults to 2. oled_clear () Clears the OLED display. oled_show () Refreshes the OLED display to show the latest changes. (Note: Often not needed as oled_print handles this). oled_connect () Connects the I2C lines to the OLED display. oled_disconnect () Disconnects the I2C lines from the OLED display. Example: oled_connect () oled_print ( \"Hello!\" ) time . sleep ( 2 ) oled_clear () oled_disconnect () Probe Functions for interacting with the physical probe. probe_read ([ blocking = True ]) Reads the pad currently being touched by the probe. blocking (optional): If True (default), the function will wait until a pad is touched. If False , it returns immediately. Returns a ProbePad object (e.g., 25 , D13_PAD , NO_PAD ). Aliases : read_probe () , probe_read_blocking () , probe_read_nonblocking () , probe_wait () , wait_probe () , probe_touch () , wait_touch () probe_button ([ blocking = True ]) Reads the state of the buttons on the probe. blocking (optional): If True (default), waits for a button press. If False , returns the current state immediately. Returns a ProbeButton object ( CONNECT_BUTTON , REMOVE_BUTTON , or BUTTON_NONE ). Aliases : get_button () , button_read () , read_button () , probe_button_blocking () , probe_button_nonblocking () , check_button () , button_check () Example: print ( \"Touch a pad...\" ) pad = probe_read () print ( \"You touched: \" + str ( pad )) if pad == D13_PAD : print ( \"That's the Arduino LED pin!\" ) print ( \"Press a probe button...\" ) button = get_button () if button == CONNECT_BUTTON : print ( \"Connect button pressed.\" ) System Functions arduino_reset () Resets the connected Arduino Nano. run_app ( appName ) Launches a built-in Jumperless application. appName : The name of the app to run (e.g., \"File Manager\", \"I2C Scan\"). Status Functions These functions print detailed status information to the serial console. print_bridges () : Prints all active bridges. print_paths () : Prints all resolved paths between nodes. print_crossbars () : Prints the raw state of the crossbar matrix. print_nets () : Prints the current net list. print_chip_status () : Prints the status of the CH446Q chips. Help Functions help () Displays a comprehensive list of all available functions and constants in the jumperless module. nodes_help () Displays a detailed reference for all available node names and their aliases.","title":"Jumperless MicroPython API Reference"},{"location":"09.5-micropythonAPIreference/#jumperless-micropython-api-reference","text":"This document provides a comprehensive reference for the jumperless MicroPython module, which allows for direct control over the Jumperless hardware.","title":"Jumperless MicroPython API Reference"},{"location":"09.5-micropythonAPIreference/#a-note-on-usage","text":"All functions and constants from the jumperless module are automatically imported into the global namespace. This means you can call them directly (e.g., connect ( 1 , 5 ) ) without needing the jumperless . prefix. There are three primary ways to specify nodes in functions: 1. By Number : Use the integer corresponding to the breadboard row (1-60). 2. By String Name : Use a case-insensitive string for any named node (e.g., \"d13\" , \"TOP_RAIL\" ). 3. By Constant : Use the predefined, case-sensitive constant for a node (e.g., D13 , TOP_RAIL ). DAC (Digital-to-Analog Converter) - Examples : dac_set ( channel , voltage ) - Set DAC output voltage dac_get ( channel ) - Get DAC output voltage set_dac ( channel , voltage ) - Alias for dac_set get_dac ( channel ) - Alias for dac_get channel : 0 - 3 , DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL channel 0 / DAC0 : DAC 0 channel 1 / DAC1 : DAC 1 channel 2 / TOP_RAIL : top rail channel 3 / BOTTOM_RAIL : bottom rail voltage : - 8.0 to 8.0 V ADC (Analog-to-Digital Converter) - Examples : adc_get ( channel ) - Read ADC input voltage get_adc ( channel ) - Alias for adc_get channel : 0 - 4 INA (Current/Power Monitor) - Examples : ina_get_current ( sensor ) - Read current in amps ina_get_voltage ( sensor ) - Read shunt voltage ina_get_bus_voltage ( sensor ) - Read bus voltage ina_get_power ( sensor ) - Read power in watts Aliases: get_current, get_voltage, get_bus_voltage, get_power sensor : 0 or 1 GPIO - Examples : gpio_set ( pin , value ) - Set GPIO pin state gpio_get ( pin ) - Read GPIO pin state gpio_set_dir ( pin , direction ) - Set GPIO pin direction gpio_get_dir ( pin ) - Get GPIO pin direction gpio_set_pull ( pin , pull ) - Set GPIO pull-up/down gpio_get_pull ( pin ) - Get GPIO pull-up/down Aliases: set_gpio, get_gpio, set_gpio_dir, get_gpio_dir, etc. pin 1 - 8 : GPIO 1 - 8 pin 9 : UART Tx pin 10 : UART Rx value : True / False for HIGH / LOW direction : True / False for OUTPUT / INPUT pull : - 1 / 0 / 1 for PULL_DOWN / NONE / PULL_UP PWM (Pulse Width Modulation) - Examples : pwm ( pin , [ frequency ], [ duty ]) - Setup PWM on GPIO pin pwm_set_duty_cycle ( pin , duty ) - Set PWM duty cycle pwm_set_frequency ( pin , freq ) - Set PWM frequency pwm_stop ( pin ) - Stop PWM on pin Pin: 1-8 (numeric) or GPIO_1-GPIO_8 (constants) Frequency: 10Hz to 62.5MHz, Duty: 0.0 to 1.0 Aliases: set_pwm, set_pwm_duty_cycle, set_pwm_frequency, stop_pwm pin : 1 - 8 GPIO pins only frequency : 1 - 62.5 MHz default 1000 Hz duty_cycle : 0.0 - 1.0 default 0.5 ( 50 % ) Node Connections - Examples : connect ( node1 , node2 ) - Connect two nodes disconnect ( node1 , node2 ) - Disconnect nodes is_connected ( node1 , node2 ) - Check if nodes are connected nodes_clear () - Clear all connections set node2 to -1 to disconnect everything connected to node1 OLED Display - Examples : oled_print ( \"text\" ) - Display text oled_clear () - Clear display oled_connect () - Connect OLED oled_disconnect () - Disconnect OLED Status - Examples : print_bridges () - Print all bridges print_paths () - Print path between nodes print_crossbars () - Print crossbar array print_nets () - Print nets print_chip_status () - Print chip status Probe Functions - Examples : probe_read_blocking () - Wait for probe touch (don't return until a pad is touched) probe_read_nonblocking () - Check probe immediately (return -1 if no pad is touched) get_button ([ blocking = True ]) - Get button state (default: blocking) probe_button ([ blocking = True ]) - Get button state (default: blocking) probe_button_blocking () - Wait for button press probe_button_nonblocking () - Check buttons immediately Non-blocking only: check_button, button_check Touch returns: ProbePad object (1-60, D13_PAD, TOP_RAIL_PAD, LOGO_PAD_TOP, etc.) Button returns: CONNECT, REMOVE, or NONE (front=connect, rear=remove) JFS (Jumperless File System): jfs . open ( path , mode ) - Opens file, returns file handle jfs . read ( file , size = 1024 ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . seek ( file , position , whence = 0 ) - Seek in file jfs . tell ( file ) - Get current position jfs . size ( file ) - Get file size jfs . available ( file ) - Get bytes available jfs . exists ( path ) - Check if path exists (returns True/False) jfs . listdir ( path ) - List directory contents (returns list) jfs . mkdir ( path ) - Create directory jfs . rmdir ( path ) - Remove directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename/move file jfs . info () - Returns (total, used, free) tuple Misc - Examples : arduino_reset () - Reset Arduino probe_tap ( node ) - Tap probe on node (unimplemented) run_app ( 'appName' ) - Run app Help - Examples : help () - Display this help nodes_help () - Show available nodes and how to address them","title":"A Note on Usage"},{"location":"09.5-micropythonAPIreference/#node-connections","text":"These functions manage the connections between nodes on the breadboard and special function pins.","title":"Node Connections"},{"location":"09.5-micropythonAPIreference/#connectnode1-node2-savetrue","text":"Creates a bridge between two nodes. node1 , node2 : The nodes to connect. Can be integers, strings, or constants. save (optional): If True (default), the connection is saved to the current slot's node file. If False , it's a temporary connection for the current session. Example: # Connect breadboard row 1 to row 30 connect ( 1 , 30 ) # Connect Arduino D13 to the top power rail connect ( D13 , TOP_RAIL ) # Connect GPIO 1 to ADC 0 using strings connect ( \"GPIO_1\" , \"ADC0\" )","title":"connect(node1, node2, [save=True])"},{"location":"09.5-micropythonAPIreference/#disconnectnode1-node2","text":"Removes a specific bridge between two nodes. node1 , node2 : The two nodes to disconnect. To remove all connections from a single node, set node2 to - 1 . Example: # Remove the bridge between rows 1 and 30 disconnect ( 1 , 30 ) # Remove all connections from GPIO_1 disconnect ( GPIO_1 , - 1 )","title":"disconnect(node1, node2)"},{"location":"09.5-micropythonAPIreference/#is_connectednode1-node2","text":"Checks if a direct or indirect connection exists between two nodes. Returns a custom ConnectionState object which evaluates to True if connected ( CONNECTED ) and False if not ( DISCONNECTED ). Example: if is_connected ( D13 , TOP_RAIL ): print ( \"D13 is connected to the top rail.\" ) state = is_connected ( 1 , 2 ) print ( state ) # Prints \"CONNECTED\" or \"DISCONNECTED\"","title":"is_connected(node1, node2)"},{"location":"09.5-micropythonAPIreference/#nodes_clear","text":"Removes all connections from the board. Example: nodes_clear () print ( \"All connections cleared.\" )","title":"nodes_clear()"},{"location":"09.5-micropythonAPIreference/#nodename_or_id","text":"Creates a node object from a string name or integer ID. This is useful for storing a node reference in a variable. Example: my_pin = node ( \"D7\" ) led_pin = node ( 15 ) connect ( my_pin , led_pin ) oled_print ( my_pin ) # Displays 'D7' on the OLED","title":"node(name_or_id)"},{"location":"09.5-micropythonAPIreference/#dac-digital-to-analog-converter","text":"Functions for controlling the analog voltage outputs.","title":"DAC (Digital-to-Analog Converter)"},{"location":"09.5-micropythonAPIreference/#dac_setchannel-voltage-savetrue","text":"Sets the output voltage for a specific DAC channel. channel : The DAC channel to set. Can be an integer (0-3) or a node constant ( DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL ). voltage : The desired voltage (from -8.0V to 8.0V). save (optional): If True (default), the setting is saved to the config file. Aliases : set_dac () Channels: * 0 or DAC0 : The 5V tolerant DAC output. * 1 or DAC1 : The 8V tolerant DAC output. * 2 or TOP_RAIL : The top power rail. * 3 or BOTTOM_RAIL : The bottom power rail. Example: # Set the top rail to 5V dac_set ( TOP_RAIL , 5.0 ) # Set DAC0 to 1.25V set_dac ( DAC0 , 1.25 )","title":"dac_set(channel, voltage, [save=True])"},{"location":"09.5-micropythonAPIreference/#dac_getchannel","text":"Reads the currently set voltage for a DAC channel. channel : The DAC channel to read. Returns a float. Aliases : get_dac () Example: voltage = dac_get ( TOP_RAIL ) print ( \"Top Rail voltage: \" + str ( voltage ))","title":"dac_get(channel)"},{"location":"09.5-micropythonAPIreference/#adc-analog-to-digital-converter","text":"Functions for measuring analog voltages.","title":"ADC (Analog-to-Digital Converter)"},{"location":"09.5-micropythonAPIreference/#adc_getchannel","text":"Reads the voltage from a specific ADC channel. channel : The ADC channel to read (0-4). Returns a float. Aliases : get_adc () Channels: * 0 - 3 : 8V tolerant ADC inputs. * 4 : 5V tolerant ADC input. Example: voltage = adc_get ( 0 ) print ( \"ADC0 voltage: \" + str ( voltage ))","title":"adc_get(channel)"},{"location":"09.5-micropythonAPIreference/#gpio-general-purpose-inputoutput","text":"Functions for controlling the digital I/O pins.","title":"GPIO (General Purpose Input/Output)"},{"location":"09.5-micropythonAPIreference/#gpio_setpin-value","text":"Sets the output state of a GPIO pin. pin : The GPIO pin number (1-10). value : True for HIGH, False for LOW. Aliases : set_gpio ()","title":"gpio_set(pin, value)"},{"location":"09.5-micropythonAPIreference/#gpio_getpin","text":"Reads the state of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIOState object ( HIGH , LOW , or FLOATING ). Aliases : get_gpio ()","title":"gpio_get(pin)"},{"location":"09.5-micropythonAPIreference/#gpio_set_dirpin-direction","text":"Sets the direction of a GPIO pin. pin : The GPIO pin number (1-10). direction : True for OUTPUT, False for INPUT. Aliases : set_gpio_dir ()","title":"gpio_set_dir(pin, direction)"},{"location":"09.5-micropythonAPIreference/#gpio_get_dirpin","text":"Reads the direction of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIODirection object ( INPUT or OUTPUT ). Aliases : get_gpio_dir ()","title":"gpio_get_dir(pin)"},{"location":"09.5-micropythonAPIreference/#gpio_set_pullpin-pull","text":"Configures the internal pull resistor for a GPIO pin. pin : The GPIO pin number (1-10). pull : 1 for PULLUP, - 1 for PULLDOWN, 0 for NONE. Aliases : set_gpio_pull ()","title":"gpio_set_pull(pin, pull)"},{"location":"09.5-micropythonAPIreference/#gpio_get_pullpin","text":"Reads the pull resistor configuration of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIOPull object ( PULLUP , PULLDOWN , or NONE ). Aliases : get_gpio_pull () Pinout: * 1 - 8 : Routable GPIO pins GPIO_1 to GPIO_8 . * 9 : UART_TX . * 10 : UART_RX . Example: # Set GPIO 1 as an output and turn it on gpio_set_dir ( 1 , True ) gpio_set ( 1 , True ) # Set GPIO 2 as an input with a pull-up gpio_set_dir ( 2 , False ) gpio_set_pull ( 2 , 1 ) # Read the state of GPIO 2 state = gpio_get ( 2 ) if state == HIGH : print ( \"GPIO 2 is HIGH\" )","title":"gpio_get_pull(pin)"},{"location":"09.5-micropythonAPIreference/#pwm-pulse-width-modulation","text":"Functions for generating PWM signals on GPIO pins.","title":"PWM (Pulse-Width Modulation)"},{"location":"09.5-micropythonAPIreference/#pwmpin-frequency-duty_cycle","text":"Sets up and starts a PWM signal on a GPIO pin. pin : The GPIO pin to use (1-8). frequency (optional): The PWM frequency in Hz (10.0 to 62,500,000.0). Defaults to 1000. duty_cycle (optional): The duty cycle from 0.0 to 1.0. Defaults to 0.5. Aliases : set_pwm ()","title":"pwm(pin, [frequency], [duty_cycle])"},{"location":"09.5-micropythonAPIreference/#pwm_set_duty_cyclepin-duty_cycle","text":"Changes the duty cycle of an existing PWM signal. pin : The GPIO pin number (1-8). duty_cycle : The new duty cycle (0.0 to 1.0). Aliases : set_pwm_duty_cycle ()","title":"pwm_set_duty_cycle(pin, duty_cycle)"},{"location":"09.5-micropythonAPIreference/#pwm_set_frequencypin-frequency","text":"Changes the frequency of an existing PWM signal. pin : The GPIO pin number (1-8). frequency : The new frequency in Hz. Aliases : set_pwm_frequency ()","title":"pwm_set_frequency(pin, frequency)"},{"location":"09.5-micropythonAPIreference/#pwm_stoppin","text":"Stops the PWM signal on a GPIO pin. pin : The GPIO pin number (1-8). Aliases : stop_pwm () Example: # Start a 1kHz, 25% duty cycle PWM on GPIO_1 pwm ( GPIO_1 , 1000 , 0.25 ) # Change the duty cycle to 75% pwm_set_duty_cycle ( GPIO_1 , 0.75 ) # Stop the PWM signal pwm_stop ( GPIO_1 )","title":"pwm_stop(pin)"},{"location":"09.5-micropythonAPIreference/#ina-currentpower-monitor","text":"Functions for reading data from the INA219 current sensors.","title":"INA (Current/Power Monitor)"},{"location":"09.5-micropythonAPIreference/#ina_get_currentsensor","text":"Reads the current in Amps. * sensor : The sensor to read (0 or 1). * Aliases : get_current ()","title":"ina_get_current(sensor)"},{"location":"09.5-micropythonAPIreference/#ina_get_voltagesensor","text":"Reads the shunt voltage in Volts. * sensor : The sensor to read (0 or 1). * Aliases : get_voltage ()","title":"ina_get_voltage(sensor)"},{"location":"09.5-micropythonAPIreference/#ina_get_bus_voltagesensor","text":"Reads the bus voltage in Volts. * sensor : The sensor to read (0 or 1). * Aliases : get_bus_voltage ()","title":"ina_get_bus_voltage(sensor)"},{"location":"09.5-micropythonAPIreference/#ina_get_powersensor","text":"Reads the power in Watts. * sensor : The sensor to read (0 or 1). * Aliases : get_power () Example: current_mA = ina_get_current ( 0 ) * 1000 print ( \"Current: \" + str ( current_mA ) + \" mA\" )","title":"ina_get_power(sensor)"},{"location":"09.5-micropythonAPIreference/#oled-display","text":"Functions for controlling the onboard OLED display.","title":"OLED Display"},{"location":"09.5-micropythonAPIreference/#oled_printtext-size2","text":"Displays text on the OLED screen. It can print strings, numbers, and custom Jumperless types. text : The content to display. size (optional): The font size (1 or 2). Defaults to 2.","title":"oled_print(text, [size=2])"},{"location":"09.5-micropythonAPIreference/#oled_clear","text":"Clears the OLED display.","title":"oled_clear()"},{"location":"09.5-micropythonAPIreference/#oled_show","text":"Refreshes the OLED display to show the latest changes. (Note: Often not needed as oled_print handles this).","title":"oled_show()"},{"location":"09.5-micropythonAPIreference/#oled_connect","text":"Connects the I2C lines to the OLED display.","title":"oled_connect()"},{"location":"09.5-micropythonAPIreference/#oled_disconnect","text":"Disconnects the I2C lines from the OLED display. Example: oled_connect () oled_print ( \"Hello!\" ) time . sleep ( 2 ) oled_clear () oled_disconnect ()","title":"oled_disconnect()"},{"location":"09.5-micropythonAPIreference/#probe","text":"Functions for interacting with the physical probe.","title":"Probe"},{"location":"09.5-micropythonAPIreference/#probe_readblockingtrue","text":"Reads the pad currently being touched by the probe. blocking (optional): If True (default), the function will wait until a pad is touched. If False , it returns immediately. Returns a ProbePad object (e.g., 25 , D13_PAD , NO_PAD ). Aliases : read_probe () , probe_read_blocking () , probe_read_nonblocking () , probe_wait () , wait_probe () , probe_touch () , wait_touch ()","title":"probe_read([blocking=True])"},{"location":"09.5-micropythonAPIreference/#probe_buttonblockingtrue","text":"Reads the state of the buttons on the probe. blocking (optional): If True (default), waits for a button press. If False , returns the current state immediately. Returns a ProbeButton object ( CONNECT_BUTTON , REMOVE_BUTTON , or BUTTON_NONE ). Aliases : get_button () , button_read () , read_button () , probe_button_blocking () , probe_button_nonblocking () , check_button () , button_check () Example: print ( \"Touch a pad...\" ) pad = probe_read () print ( \"You touched: \" + str ( pad )) if pad == D13_PAD : print ( \"That's the Arduino LED pin!\" ) print ( \"Press a probe button...\" ) button = get_button () if button == CONNECT_BUTTON : print ( \"Connect button pressed.\" )","title":"probe_button([blocking=True])"},{"location":"09.5-micropythonAPIreference/#system-functions","text":"","title":"System Functions"},{"location":"09.5-micropythonAPIreference/#arduino_reset","text":"Resets the connected Arduino Nano.","title":"arduino_reset()"},{"location":"09.5-micropythonAPIreference/#run_appappname","text":"Launches a built-in Jumperless application. appName : The name of the app to run (e.g., \"File Manager\", \"I2C Scan\").","title":"run_app(appName)"},{"location":"09.5-micropythonAPIreference/#status-functions","text":"These functions print detailed status information to the serial console. print_bridges () : Prints all active bridges. print_paths () : Prints all resolved paths between nodes. print_crossbars () : Prints the raw state of the crossbar matrix. print_nets () : Prints the current net list. print_chip_status () : Prints the status of the CH446Q chips.","title":"Status Functions"},{"location":"09.5-micropythonAPIreference/#help-functions","text":"","title":"Help Functions"},{"location":"09.5-micropythonAPIreference/#help","text":"Displays a comprehensive list of all available functions and constants in the jumperless module.","title":"help()"},{"location":"09.5-micropythonAPIreference/#nodes_help","text":"Displays a detailed reference for all available node names and their aliases.","title":"nodes_help()"},{"location":"10-3d-stand/","text":"3D Printable Stand Here are the 3D models for you to print your own stand for your Jumperless. It's extremely handy to have it propped up like this to read text on the breadboard. Printing Tips Yes, the model is at a weird angle, just drop it down in the slicer, if you want it to hold at a shallower angle, just drop the model through the bed a bit when you slice. Rubber Feet These stick-on rubber feet also make it a lot more solid on your desk (and having the different sizes lets you shim the angle by putting different ones on the front and back.)","title":"3D Printable Stand"},{"location":"10-3d-stand/#3d-printable-stand","text":"Here are the 3D models for you to print your own stand for your Jumperless. It's extremely handy to have it propped up like this to read text on the breadboard.","title":"3D Printable Stand"},{"location":"10-3d-stand/#printing-tips","text":"Yes, the model is at a weird angle, just drop it down in the slicer, if you want it to hold at a shallower angle, just drop the model through the bed a bit when you slice.","title":"Printing Tips"},{"location":"10-3d-stand/#rubber-feet","text":"These stick-on rubber feet also make it a lot more solid on your desk (and having the different sizes lets you shim the angle by putting different ones on the front and back.)","title":"Rubber Feet"},{"location":"11-WritingApps/","text":"Writing Apps Here's a the example app that should show the calls for most of the things you might want to do You can do literally anything the Jumperless can in an app, so if there's a specific thing, lmk and I'll write an example. Until I make this into a proper operating system, what you're doing when you write an App is just writing a function in the main firmware. There's really no guard rails, and the API is just any function in the firmware. First get it PlatformIO set up to flash code So fork the firmware here: https://github.com/Architeuthis-Flux/JumperlessV5 I'm using PlatformIO in VSCode. And it should just work to open the RP23V50firmware folder in that (you'll probably need to comment out upload_port = / dev / cu . usbmodem101 in Platformio . ini so it'll just automatically find it) You should just open the RP23V50firmware folder, not the entire JumperlessV5 repo, in VSCode. You should probably try to just load the firmware just to make sure everything works. To write an App Before you go writing your app, follow these steps to make it so it's listed in the App library and you can run it from the menus. Go to menuTree . h and add the name of your app under Apps \\ n \\ (shown as - Custom App \\ n \\ here, it needs to fit in 7x2 chars to show on the breadboard) Go to Apps . h and declare your function where you'll write your app Go to Apps . cpp and add a struct in the struct app apps [ 30 ] for your app { \"Name\" , index , ?? idk , name of the function ( unused )} Go to Apps . cpp > runApp () and add a case for your app's index (this is so you can also find it by index rather than exact matching the name \"Custom App\" Make a function that's the entirety of your app, I just pushed a demo function called customApp ( void ) with some (non exhaustive) examples of things you can do from an app. Run your app with the clickwheel, Apps > Custom App . The quick way run \"Custom App\" is to just enter 2 in the main menu, or just use the clickwheel and go Apps > Custom App. If you want to add your own shortcut, find an unused menu character and add a case '3' : { runApp ( 3 ); // the app index you set above break ; } in the big main menu switch statement in main . cpp . To actually write the app The code for Custom App is an example of the calls available with comments telling you what's going on. There are tons more, but what's shown there are the higher-level helper functions that should roughly do what they say they're doing.","title":"Writing Apps"},{"location":"11-WritingApps/#writing-apps","text":"","title":"Writing Apps"},{"location":"11-WritingApps/#heres-a-the-example-app-that-should-show-the-calls-for-most-of-the-things-you-might-want-to-do","text":"You can do literally anything the Jumperless can in an app, so if there's a specific thing, lmk and I'll write an example. Until I make this into a proper operating system, what you're doing when you write an App is just writing a function in the main firmware. There's really no guard rails, and the API is just any function in the firmware.","title":"Here's a the example app that should show the calls for most of the things you might want to do"},{"location":"11-WritingApps/#first-get-it-platformio-set-up-to-flash-code","text":"So fork the firmware here: https://github.com/Architeuthis-Flux/JumperlessV5 I'm using PlatformIO in VSCode. And it should just work to open the RP23V50firmware folder in that (you'll probably need to comment out upload_port = / dev / cu . usbmodem101 in Platformio . ini so it'll just automatically find it) You should just open the RP23V50firmware folder, not the entire JumperlessV5 repo, in VSCode. You should probably try to just load the firmware just to make sure everything works.","title":"First get it PlatformIO set up to flash code"},{"location":"11-WritingApps/#to-write-an-app","text":"Before you go writing your app, follow these steps to make it so it's listed in the App library and you can run it from the menus. Go to menuTree . h and add the name of your app under Apps \\ n \\ (shown as - Custom App \\ n \\ here, it needs to fit in 7x2 chars to show on the breadboard) Go to Apps . h and declare your function where you'll write your app Go to Apps . cpp and add a struct in the struct app apps [ 30 ] for your app { \"Name\" , index , ?? idk , name of the function ( unused )} Go to Apps . cpp > runApp () and add a case for your app's index (this is so you can also find it by index rather than exact matching the name \"Custom App\" Make a function that's the entirety of your app, I just pushed a demo function called customApp ( void ) with some (non exhaustive) examples of things you can do from an app. Run your app with the clickwheel, Apps > Custom App . The quick way run \"Custom App\" is to just enter 2 in the main menu, or just use the clickwheel and go Apps > Custom App. If you want to add your own shortcut, find an unused menu character and add a case '3' : { runApp ( 3 ); // the app index you set above break ; } in the big main menu switch statement in main . cpp .","title":"To write an App"},{"location":"11-WritingApps/#to-actually-write-the-app","text":"The code for Custom App is an example of the calls available with comments telling you what's going on. There are tons more, but what's shown there are the higher-level helper functions that should roughly do what they say they're doing.","title":"To actually write the app"},{"location":"99-glossary/","text":"Glossary of Terms net = a group of all the node s that are connected together (enter n to see the list {there's a colorful update to that I'm working on right now}) node = anything the crossbar array can connect to, which includes everything on the breadboard and Nano header, as well as the internal special function node s like routable GPIO , ADC s, DAC s row = kinda the same thing as node but I generally use it to mean stuff on the breadboard (so special function things like routable GPIO , ADC s, DAC s that don't have a set location are excluded) rail = I use this to refer to the 4 horizontal power rails on the top and bottom ( top_rail , bottom_rail , gnd ), I will never call a vertical row a rail . (I know they're columns but it's easier to say a lot) bridge = a pair of exactly two node s (this is what you're making when you connect stuff with the probe, enter s to print the (kinda misnamed) node file s to see a list of bridges) path = the set of crossbar connections needed to make a single bridge , so it can have multiple hop s if it doesn't have a direct connection and needs to make a bounce through an intermediate chip enter b to see them node file / slot file = this is an actual text file on the filesystem that stores the list of bridges, there's one of these for each slot (enter s to see all of them, they start with an f { to make it east to just copy paste them from the terminal) slot = one of the 8 node files stored that you can switch between with < / > or the menu s. Named nodeFileSlot [ 0 - 7 ] . txt (there's no actual limit, there's so much flash storage on this thing, but by default it's 8) menu = I generally mean the onboard clickwheel menu when I say this ( click the wheel to enter those and scroll around) chip = shorthand for the CH446Qs specifically, lettered A-L. The first 8 (A-H) are considered \"breadboard chips , and the last 4 are considered \"special function\" chips (enter c to see their connections) That's probably more than you need to worry about but that gives me a nice start on real docs","title":"Glossary of Terms"},{"location":"99-glossary/#glossary-of-terms","text":"net = a group of all the node s that are connected together (enter n to see the list {there's a colorful update to that I'm working on right now}) node = anything the crossbar array can connect to, which includes everything on the breadboard and Nano header, as well as the internal special function node s like routable GPIO , ADC s, DAC s row = kinda the same thing as node but I generally use it to mean stuff on the breadboard (so special function things like routable GPIO , ADC s, DAC s that don't have a set location are excluded) rail = I use this to refer to the 4 horizontal power rails on the top and bottom ( top_rail , bottom_rail , gnd ), I will never call a vertical row a rail . (I know they're columns but it's easier to say a lot) bridge = a pair of exactly two node s (this is what you're making when you connect stuff with the probe, enter s to print the (kinda misnamed) node file s to see a list of bridges) path = the set of crossbar connections needed to make a single bridge , so it can have multiple hop s if it doesn't have a direct connection and needs to make a bounce through an intermediate chip enter b to see them node file / slot file = this is an actual text file on the filesystem that stores the list of bridges, there's one of these for each slot (enter s to see all of them, they start with an f { to make it east to just copy paste them from the terminal) slot = one of the 8 node files stored that you can switch between with < / > or the menu s. Named nodeFileSlot [ 0 - 7 ] . txt (there's no actual limit, there's so much flash storage on this thing, but by default it's 8) menu = I generally mean the onboard clickwheel menu when I say this ( click the wheel to enter those and scroll around) chip = shorthand for the CH446Qs specifically, lettered A-L. The first 8 (A-H) are considered \"breadboard chips , and the last 4 are considered \"special function\" chips (enter c to see their connections) That's probably more than you need to worry about but that gives me a nice start on real docs","title":"Glossary of Terms"},{"location":"custom-syntax-highlighting/","text":"Custom Jumperless Python Syntax Highlighting This document demonstrates the custom syntax highlighting for Jumperless Python (Jython) code blocks and inline code. Code Blocks Use standard fenced code blocks with the language identifier jython , jumperless , or jumperless - python : # This is a Jumperless Python code block connect ( D2 , A0 ) # Connects digital pin 2 to analog pin 0 dac_set ( DAC0 , 2.5 ) # Sets DAC0 to 2.5 volts value = adc_get ( ADC0 ) # Reads voltage from ADC0 Inline Code Highlighting For inline code highlighting, use one of these special syntaxes: Using #! syntax (recommended) The #!jython syntax provides highlighting for inline code: Functions: connect ( D2 , A0 ) and dac_set ( DAC0 , 2.5 ) Constants: TOP_RAIL , BOTTOM_RAIL , GPIO_1 JFS functions: jfs . open ( \"file.txt\" , \"r\" ) Using ::: syntax (alternative) You can also use the ::: jython syntax: gpio_set ( GPIO_1 , 1 ) probe_read () Examples Here are some practical examples: To read the current flowing through the circuit, use ina_get_current () . You can also check the voltage with ina_get_voltage () . Connect two nodes with connect ( A0 , D13 ) and disconnect them using disconnect ( A0 , D13 ) . File operations are handled through JFS: jfs . write ( \"data.txt\" , content ) writes data to a file. Highlighted Elements Jumperless Functions (Pink) connect () , disconnect () dac_set () , dac_get () adc_get () , gpio_set () probe_read () , oled_print () Jumperless Constants (Purple) Rails: TOP_RAIL , BOTTOM_RAIL , GND Digital pins: D0 through D13 Analog pins: A0 through A7 GPIO: GPIO_1 through GPIO_8 DAC/ADC: DAC0 , DAC1 , ADC0 , etc. JFS Functions (Reddish Pink) jfs . open () , jfs . read () , jfs . write () jfs . close () , jfs . exists () , jfs . listdir () JFS Constants (Orange) SEEK_SET , SEEK_CUR , SEEK_END jfs , FatFS , vfs , LittleFS , SDFS Hardware Constants (Purple) Special hardware identifiers and constants Tips Always specify the language : Use jython , jumperless , or jumperless - python Use the shebang syntax : For inline code, always start with #!jython or ::: jython No spaces : Don't put spaces between the backtick and the language identifier Case sensitive : Function and constant names are case-sensitive Regular Python vs Jumperless Python Compare regular Python: print ( \"hello\" ) With Jumperless Python: oled_print ( \"hello\" ) The custom lexer provides specialized highlighting for Jumperless-specific functions and constants while maintaining compatibility with standard Python syntax.","title":"Custom Jumperless Python Syntax Highlighting"},{"location":"custom-syntax-highlighting/#custom-jumperless-python-syntax-highlighting","text":"This document demonstrates the custom syntax highlighting for Jumperless Python (Jython) code blocks and inline code.","title":"Custom Jumperless Python Syntax Highlighting"},{"location":"custom-syntax-highlighting/#code-blocks","text":"Use standard fenced code blocks with the language identifier jython , jumperless , or jumperless - python : # This is a Jumperless Python code block connect ( D2 , A0 ) # Connects digital pin 2 to analog pin 0 dac_set ( DAC0 , 2.5 ) # Sets DAC0 to 2.5 volts value = adc_get ( ADC0 ) # Reads voltage from ADC0","title":"Code Blocks"},{"location":"custom-syntax-highlighting/#inline-code-highlighting","text":"For inline code highlighting, use one of these special syntaxes:","title":"Inline Code Highlighting"},{"location":"custom-syntax-highlighting/#using-syntax-recommended","text":"The #!jython syntax provides highlighting for inline code: Functions: connect ( D2 , A0 ) and dac_set ( DAC0 , 2.5 ) Constants: TOP_RAIL , BOTTOM_RAIL , GPIO_1 JFS functions: jfs . open ( \"file.txt\" , \"r\" )","title":"Using #! syntax (recommended)"},{"location":"custom-syntax-highlighting/#using-syntax-alternative","text":"You can also use the ::: jython syntax: gpio_set ( GPIO_1 , 1 ) probe_read ()","title":"Using ::: syntax (alternative)"},{"location":"custom-syntax-highlighting/#examples","text":"Here are some practical examples: To read the current flowing through the circuit, use ina_get_current () . You can also check the voltage with ina_get_voltage () . Connect two nodes with connect ( A0 , D13 ) and disconnect them using disconnect ( A0 , D13 ) . File operations are handled through JFS: jfs . write ( \"data.txt\" , content ) writes data to a file.","title":"Examples"},{"location":"custom-syntax-highlighting/#highlighted-elements","text":"","title":"Highlighted Elements"},{"location":"custom-syntax-highlighting/#jumperless-functions-pink","text":"connect () , disconnect () dac_set () , dac_get () adc_get () , gpio_set () probe_read () , oled_print ()","title":"Jumperless Functions (Pink)"},{"location":"custom-syntax-highlighting/#jumperless-constants-purple","text":"Rails: TOP_RAIL , BOTTOM_RAIL , GND Digital pins: D0 through D13 Analog pins: A0 through A7 GPIO: GPIO_1 through GPIO_8 DAC/ADC: DAC0 , DAC1 , ADC0 , etc.","title":"Jumperless Constants (Purple)"},{"location":"custom-syntax-highlighting/#jfs-functions-reddish-pink","text":"jfs . open () , jfs . read () , jfs . write () jfs . close () , jfs . exists () , jfs . listdir ()","title":"JFS Functions (Reddish Pink)"},{"location":"custom-syntax-highlighting/#jfs-constants-orange","text":"SEEK_SET , SEEK_CUR , SEEK_END jfs , FatFS , vfs , LittleFS , SDFS","title":"JFS Constants (Orange)"},{"location":"custom-syntax-highlighting/#hardware-constants-purple","text":"Special hardware identifiers and constants","title":"Hardware Constants (Purple)"},{"location":"custom-syntax-highlighting/#tips","text":"Always specify the language : Use jython , jumperless , or jumperless - python Use the shebang syntax : For inline code, always start with #!jython or ::: jython No spaces : Don't put spaces between the backtick and the language identifier Case sensitive : Function and constant names are case-sensitive","title":"Tips"},{"location":"custom-syntax-highlighting/#regular-python-vs-jumperless-python","text":"Compare regular Python: print ( \"hello\" ) With Jumperless Python: oled_print ( \"hello\" ) The custom lexer provides specialized highlighting for Jumperless-specific functions and constants while maintaining compatibility with standard Python syntax.","title":"Regular Python vs Jumperless Python"},{"location":"test-lexer/","text":"Test Jumperless Python Lexer This page tests the custom Jumperless Python syntax highlighting. Standard Python Code def hello_world (): print ( \"Hello, World!\" ) return 42 Jumperless Python Code # Connect two points on the breadboard connect ( A0 , TOP_RAIL ) connect ( D13 , BOTTOM_RAIL ) # Set a DAC value dac_set ( DAC0 , 2.5 ) # Read an ADC value voltage = adc_get ( ADC0 ) # Control GPIO gpio_set ( GPIO_1 , 1 ) state = gpio_get ( GPIO_2 ) # OLED display oled_clear () oled_print ( \"Voltage:\" , voltage ) # Probe functions if probe_button () == CONNECT_BUTTON : arduino_reset () run_app ( \"blink\" ) Inline Code Highlighting Tests Regular inline code (no highlighting): CONNECT_BUTTON and get_adc () To get inline highlighting, use the pymdownx.inlinehilite syntax: Jumperless function: get_adc () Jumperless constant: CONNECT_BUTTON JFS function: jfs . read Hardware constant: DAC0 You can also use the syntax: {++ connect ( A0 , TOP_RAIL ) ++} Testing improved analyse_text method: These should now be automatically detected and highlighted: Function without parentheses: adc_get Function with parentheses: adc_get () JFS function: read (from JFS) Constants: TOP_RAIL , DAC0 , CONNECT_BUTTON Arduino pins: A0 , D13 Special functions: PROBE , ISENSE_PLUS Mixed inline references: The get_voltage function reads from ADC2 and the BOTTOM_RAIL constant. Use connect to link A0 to TOP_RAIL . Check if probe_button returns CONNECT_BUTTON state. Testing all constants mentioned by user: Explicit jython syntax tests: - Power Rails: TOP_RAIL , BOTTOM_RAIL , GND - DAC/ADC: DAC0 , DAC1 , ADC0 , ADC1 , ADC2 , ADC3 , ADC4 - Special: PROBE , UART_TX , UART_RX - GPIO: GPIO_1 , GPIO_2 , GPIO_3 , GPIO_4 - Arduino: D0 , D1 , D13 , A0 , A1 , A7 Regular inline code (should not highlight): - Power Rails: TOP_RAIL , BOTTOM_RAIL , GND - DAC/ADC: DAC0 , DAC1 , ADC0 , ADC1 , ADC2 , ADC3 , ADC4 - Special: PROBE , UART_TX , UART_RX - GPIO: GPIO_1 , GPIO_2 , GPIO_3 , GPIO_4 - Arduino: D0 , D1 , D13 , A0 , A1 , A7 Mixed Python with Jumperless Functions import time def monitor_voltage (): \"\"\"Monitor voltage on ADC0 and display on OLED\"\"\" while True : # Read voltage using Jumperless function voltage = adc_get ( ADC0 ) # Display on OLED oled_clear () oled_print ( f \"V: { voltage : .2f } \" ) # Check if voltage is too high if voltage > 3.3 : gpio_set ( GPIO_1 , 1 ) # Turn on warning LED else : gpio_set ( GPIO_1 , 0 ) # Turn off warning LED time . sleep ( 0.1 )","title":"Test Jumperless Python Lexer"},{"location":"test-lexer/#test-jumperless-python-lexer","text":"This page tests the custom Jumperless Python syntax highlighting.","title":"Test Jumperless Python Lexer"},{"location":"test-lexer/#standard-python-code","text":"def hello_world (): print ( \"Hello, World!\" ) return 42","title":"Standard Python Code"},{"location":"test-lexer/#jumperless-python-code","text":"# Connect two points on the breadboard connect ( A0 , TOP_RAIL ) connect ( D13 , BOTTOM_RAIL ) # Set a DAC value dac_set ( DAC0 , 2.5 ) # Read an ADC value voltage = adc_get ( ADC0 ) # Control GPIO gpio_set ( GPIO_1 , 1 ) state = gpio_get ( GPIO_2 ) # OLED display oled_clear () oled_print ( \"Voltage:\" , voltage ) # Probe functions if probe_button () == CONNECT_BUTTON : arduino_reset () run_app ( \"blink\" )","title":"Jumperless Python Code"},{"location":"test-lexer/#inline-code-highlighting-tests","text":"Regular inline code (no highlighting): CONNECT_BUTTON and get_adc () To get inline highlighting, use the pymdownx.inlinehilite syntax: Jumperless function: get_adc () Jumperless constant: CONNECT_BUTTON JFS function: jfs . read Hardware constant: DAC0 You can also use the syntax: {++ connect ( A0 , TOP_RAIL ) ++} Testing improved analyse_text method: These should now be automatically detected and highlighted: Function without parentheses: adc_get Function with parentheses: adc_get () JFS function: read (from JFS) Constants: TOP_RAIL , DAC0 , CONNECT_BUTTON Arduino pins: A0 , D13 Special functions: PROBE , ISENSE_PLUS Mixed inline references: The get_voltage function reads from ADC2 and the BOTTOM_RAIL constant. Use connect to link A0 to TOP_RAIL . Check if probe_button returns CONNECT_BUTTON state. Testing all constants mentioned by user: Explicit jython syntax tests: - Power Rails: TOP_RAIL , BOTTOM_RAIL , GND - DAC/ADC: DAC0 , DAC1 , ADC0 , ADC1 , ADC2 , ADC3 , ADC4 - Special: PROBE , UART_TX , UART_RX - GPIO: GPIO_1 , GPIO_2 , GPIO_3 , GPIO_4 - Arduino: D0 , D1 , D13 , A0 , A1 , A7 Regular inline code (should not highlight): - Power Rails: TOP_RAIL , BOTTOM_RAIL , GND - DAC/ADC: DAC0 , DAC1 , ADC0 , ADC1 , ADC2 , ADC3 , ADC4 - Special: PROBE , UART_TX , UART_RX - GPIO: GPIO_1 , GPIO_2 , GPIO_3 , GPIO_4 - Arduino: D0 , D1 , D13 , A0 , A1 , A7","title":"Inline Code Highlighting Tests"},{"location":"test-lexer/#mixed-python-with-jumperless-functions","text":"import time def monitor_voltage (): \"\"\"Monitor voltage on ADC0 and display on OLED\"\"\" while True : # Read voltage using Jumperless function voltage = adc_get ( ADC0 ) # Display on OLED oled_clear () oled_print ( f \"V: { voltage : .2f } \" ) # Check if voltage is too high if voltage > 3.3 : gpio_set ( GPIO_1 , 1 ) # Turn on warning LED else : gpio_set ( GPIO_1 , 0 ) # Turn off warning LED time . sleep ( 0.1 )","title":"Mixed Python with Jumperless Functions"}]}