{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is it? Jumperless V5 lets you prototype like a nerdy wizard who can see electricity and conjure jumpers with a magic wand. It\u2019s an Integrated Development Environment (IDE) for hardware, with an analog-by-nature RP2350B dev board, a drawer full of wires, and a workbench full of test equipment (including a power supply, a multimeter, an oscilloscope, a function generator, and a logic analyzer) all crammed inside a breadboard. You can connect any point to any other using software-defined jumpers, so the four individually programmable \u00b18 V power supplies; ten GPIO; and seven management channels for voltage, current, and resistance can all be connected anywhere on the breadboard or the Arduino Nano header. RGB LEDs under each hole turn the breadboard itself into a display that provides real-time information about whatever\u2019s happening in your circuit. It's not just about being too lazy to plug in some jumpers. With software controlled wiring, the circuit itself is now scriptable , which opens up a world of infinite crazy new things you could never do on a regular breadboard. Have a script try out every combination of parts until it does what you want ( \u00e0 la evolvable hardware ), automatically switch around audio effects on the fly, characterize some unknown chip with the part numbers sanded off, or don't bother with any of that and just play Doom on it . But more likely, you'll be using it to get circuits from your brain into hardware with so little friction it feels like you're just thinking them into existence. So yeah, wizard shit. These are the docs where you will learn how to wield your new powers If you don't already have one Get the new Jumperless V5 rev 7 Or if you want to save some money and get a refurbished one, Jumperless V5 offcuts Get a Jumperless V5 on Crowd Supply Preorder the ALASKAN BULL WORM! PSRAM Mod Kit Getting Started Documentation Sections Basic Controls - Learn how to use the probe, click wheel, and slot system The App - For talking to your Jumperless, importing from Wokwi, and flashing Arduino sketches OLED - Add a better display Arduino - UART passthrough and automatic flashing Configuration - Persistent settings Debugging - Crossbar, bridge, and net list views File Manager - Filesystem access, YAML slot file editing, and text editor MicroPython - Use the onboard MicroPython interpreter MicroPython API Reference - All the Jumperless-specific hardware calls Odds and Ends - Stuff I couldn't think of a good category for 3D Printable Stand - Print your own stand Glossary - Key terms including slots, nodes, bridges, and the W command (You should turn off Dark Reader for this site if you have it, it messes up the sidebar colors) Find Me On The Internet Join the Discord for pretty much instant answers to your questions See what Zack Freedman had to say about it: Apparently he didn't find this site, which makes sense, he was an early backer and at the time, the QR code on the box didn't take you here. Watch Alex Glow and David Groom screw around with their Jumperlesses for a few hours: This also serves as a cautionary tale for what happens if you don't skim these docs first (which is a completely valid approach, you do you.) Me talking to Ian Buckley about Jumperless V5: The hardware was so rudimentary at this point that I would barely even call the thing I was showing there a \"V5\", it was revision 1 and a lot has been done since then. Chillin' with Alex Lynd We're talking about an even earlier set of prototypes, this was shot at both Teardown 2024 and Hackaday Supercon 2024 so it's rev 1 and 2 shown here. The OG Jumperless video: Most of the stuff here is relevant as a subset of what Jumperless V5 does. For AI/LLM tools: This documentation is available as llms.txt (index) and llms-full.txt (complete text) for easy ingestion.","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"#what-is-it","text":"Jumperless V5 lets you prototype like a nerdy wizard who can see electricity and conjure jumpers with a magic wand. It\u2019s an Integrated Development Environment (IDE) for hardware, with an analog-by-nature RP2350B dev board, a drawer full of wires, and a workbench full of test equipment (including a power supply, a multimeter, an oscilloscope, a function generator, and a logic analyzer) all crammed inside a breadboard. You can connect any point to any other using software-defined jumpers, so the four individually programmable \u00b18 V power supplies; ten GPIO; and seven management channels for voltage, current, and resistance can all be connected anywhere on the breadboard or the Arduino Nano header. RGB LEDs under each hole turn the breadboard itself into a display that provides real-time information about whatever\u2019s happening in your circuit. It's not just about being too lazy to plug in some jumpers. With software controlled wiring, the circuit itself is now scriptable , which opens up a world of infinite crazy new things you could never do on a regular breadboard. Have a script try out every combination of parts until it does what you want ( \u00e0 la evolvable hardware ), automatically switch around audio effects on the fly, characterize some unknown chip with the part numbers sanded off, or don't bother with any of that and just play Doom on it . But more likely, you'll be using it to get circuits from your brain into hardware with so little friction it feels like you're just thinking them into existence. So yeah, wizard shit. These are the docs where you will learn how to wield your new powers","title":"What is it?"},{"location":"#if-you-dont-already-have-one","text":"","title":"If you don't already have one"},{"location":"#get-the-new-jumperless-v5-rev-7","text":"Or if you want to save some money and get a refurbished one,","title":"Get the new Jumperless V5 rev 7"},{"location":"#jumperless-v5-offcuts","text":"","title":"Jumperless V5 offcuts"},{"location":"#get-a-jumperless-v5-on-crowd-supply","text":"","title":"Get a Jumperless V5 on Crowd Supply"},{"location":"#preorder-the-alaskan-bull-worm-psram-mod-kit","text":"","title":"Preorder the ALASKAN BULL WORM! PSRAM Mod Kit"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#documentation-sections","text":"Basic Controls - Learn how to use the probe, click wheel, and slot system The App - For talking to your Jumperless, importing from Wokwi, and flashing Arduino sketches OLED - Add a better display Arduino - UART passthrough and automatic flashing Configuration - Persistent settings Debugging - Crossbar, bridge, and net list views File Manager - Filesystem access, YAML slot file editing, and text editor MicroPython - Use the onboard MicroPython interpreter MicroPython API Reference - All the Jumperless-specific hardware calls Odds and Ends - Stuff I couldn't think of a good category for 3D Printable Stand - Print your own stand Glossary - Key terms including slots, nodes, bridges, and the W command (You should turn off Dark Reader for this site if you have it, it messes up the sidebar colors)","title":"Documentation Sections"},{"location":"#find-me-on-the-internet","text":"Join the Discord for pretty much instant answers to your questions See what Zack Freedman had to say about it: Apparently he didn't find this site, which makes sense, he was an early backer and at the time, the QR code on the box didn't take you here. Watch Alex Glow and David Groom screw around with their Jumperlesses for a few hours: This also serves as a cautionary tale for what happens if you don't skim these docs first (which is a completely valid approach, you do you.) Me talking to Ian Buckley about Jumperless V5: The hardware was so rudimentary at this point that I would barely even call the thing I was showing there a \"V5\", it was revision 1 and a lot has been done since then. Chillin' with Alex Lynd We're talking about an even earlier set of prototypes, this was shot at both Teardown 2024 and Hackaday Supercon 2024 so it's rev 1 and 2 shown here. The OG Jumperless video: Most of the stuff here is relevant as a subset of what Jumperless V5 does. For AI/LLM tools: This documentation is available as llms.txt (index) and llms-full.txt (complete text) for easy ingestion.","title":"Find Me On The Internet"},{"location":"01-basic-controls/","text":"Basic Controls The Probe First, keep the switch on the probe set to Select Why Select mode? Measure mode allows the probe tip to be \u00b19V tolerant and routable like any other node, but as of yet, the code to actually do anything with it is unwritten so it just connects to DAC 0 and outputs 3.3V just like it was in Select mode. But the DAC is much worse at matching the RP2350B's idea of what 3.3V is exactly , so probing will be flaky and may be off from the rows you're tapping in Measure . Connecting Rows Click the Connect button on the probe The logo should turn blue and the LEDs on the probe should also change Now any pair of nodes you tap should get connected as you make them. In connect mode, you're creating bridges (see the glossary ), so connections are made in pairs. When you've tapped the first node in a pair, the logo and Connect text on the probe will brighten to show that you're \" holding \" a connection, and the next thing you tap will connect to that first node . If you make a mistake while holding a connection, click the Connect button and it will clear it and take you back to the first node . If you click the Connect button while you're not holding a node , it will leave probe mode and bring you back into idle mode (rainbowy logo , all 3 probe LED s on.) To get out of Connect mode, press the button again. Encoder Connections You can also make connections using just the clickwheel, without needing to touch the probe to the breadboard: To activate: - Navigate to: Click > Connect > Add (or Remove ) - OR just turn the clickwheel while already in probe mode How it works: 1. Turn the clickwheel to scroll through all available nodes: - Breadboard rows (1-60) - Nano header pins (D0-A7) - Rails (Top, Bottom, GND) - DAC (0, 1) - ADC (0-4, Probe) - GPIO (1-8) - UART (TX, RX) - Current sense (I+, I-) Click the encoder button to select the highlighted node Hold the encoder button to exit The cursor will automatically hide after 5 seconds of inactivity. This is especially useful when you need precise control or want to access special functions without tapping pads. Removing Rows Click the Remove button and the logo should turn reddish Now you can swipe along the pad s or tap them one at a time. Remember it only disconnects that node and anything connected to it directly, not everything on the net . So tapping say, row 25 that's connected to GND won't clear everything connected to GND , but tapping the - on the rails (for GND ) would. The special functions work the same way, tap the pad, pick one, and it will remove it. Click the button again to get out. Probe Notes Remember the probe is read by a resistive voltage divider , so putting your fingers on the pads (or the back sides of the 4 risers that connect those probe sense boards to the main board), or anything causing the probe tip not to be at a steady 3.3V will give you weird readings. If you can't seem to stop playing with the switch on the probe, run the app probe calib and tap around on the board while turning the clickweel until the place you tapped is always spot on (do this with the switch in both modes), and hold the clickwheel button to save. This adjusts the nominal 3.3V measure mode puts out should be fairly accurate enough for probing. The Click Wheel There are two kinds of presses, click (short press) and hold (long press). In general, a click (short) is a yes , and a hold (long) is a no / back / exit / whatever . When I say click , it's more of a diagonal slide toward the center of the board ( these encoders were meant to poke out just a little bit from the side of a tablet or whatever.) To get to the menu, click the button and scroll through the menus, click will bring you into that menu, hold will take you back one level. If you have trouble reading stuff on the breadboard LEDs, everything is copied to the Serial terminal and the OLED (talked about in OLED Section ), and adjusting the brightness may help; in the menus, it's Display Options > Bright > Menu and then scroll around until you find a level you like, then click to confirm. Special Functions To connect to special functions , tap the corresponding pad near the logo, it will show you a menu on the breadboard and terminal to choose them. You can think of special functions just like any other node , the only difference is they're in a sort of \"folder\" so I didn't need to put a dedicated pad for each of them. DAC Pad \u2514\u2500 0 1 [ Tap pads below selection ] \u00b9 \u2514\u2500 - 8 V ! : . : ! + 8 V [ Tap bottom pads or use clickwheel to select a voltage ] > [ click probe Connect button to confirm ] \u00b2 \u2514\u2500 [ Tap a row to connect it to ] ( or if you were already \"holding\" a node , it 'll connect there)\u00b3 (This is an ASCII version of what will show on the breadboard LEDs) \u00b9 \u00b2 \u00b3 GPIO Pad \u2514\u2500 \u20711 \u2070 \u20712 \u2070 \u20713 \u2070 \u20714 \u2070 \u2081 5 \u2080 \u2081 6 \u2080 \u2081 7 \u2080 \u2081 8 \u2080 [ Tap pads to choose which ` GPIO ` ( left side for input , right side for output )] \u2514\u2500 [ Tap a row to connect it to ] ( or if you were already \"holding\" a node , it 'll connect there) \u00b9 The 4 user pads will be remappable in the future, but for now, top_guy is routable UART Tx and bottom_guy is routable UART Rx , and buiding pads are Current sense + and -. The building pads have multiple functions: - In idle mode : Override colors for net highlighting (see Idle Mode Interactions ) - In connect / remove mode: Access Current Sense (I+/I-) with marching ants visualization! Current Sensing with Marching Ants When you tap either building pad in connect or remove mode, you'll get access to the current sense inputs (I+ and I-). When both I+ and I- are connected to different nets in your circuit: A virtual wire appears between the two nets containing the I Sense nodes Animated \"marching ants\" flow along this wire showing current direction The animation automatically picks the where to put the virtual \"wire\". It will search other nodes on the same nets that I sense + and I sense - are on it prefers places where they're on the same level so it can actually draw a connecting wire and not just be vertical lines. Your browser does not support the video tag. !!! warning I Sense + and I Sense - go on different nets but they're shorted internally They're two ends of a 2\u03a9 shunt resistor, so remember that these will be shorted together. You measure current in series so this is expected, but it's super easy to forget. Take this warning as the equivalent of your multimeter yelling at you when you have the probes in the current holes and have it set to voltage. Idle Mode Net Highlighting The main thing is that there's a lot more interaction that can be done outside of any particular mode (like not probing and the logo is rainbowy, I'm gonna call this idle mode here until I think of a good name) Here's what's new (all of this is in idle mode): Basic Interactions Tapping nets highlights them as before, but there's a slightly different animation on the row you have selected from the whole net The click wheel scrolls through highlighting rows as if you tapped each one Row Selection Actions With a row selected, here's what you can do: Connect Button connect button will bring you into probing mode with the highlighted row already selected and then spit you back out to idle mode once you've made a connection to another row, or click connect again to exit Remove Button remove will remove the highlighted node Measurement Display if the highlighted row is a measurement ( gpio input or adc ) it will print the state to serial and the oled Output Toggle if the highlighted row is an output ( gpio output , I'll eventually do dacs too) clicking the connect button will toggle it high / low . The remove button will just unhighlight the net (there were some choices here, like make each button assigned to high / low or allow removing them, but this felt like the best way after trying them all). I will eventually add a setting for the toggle repeat rate (set to 500ms now) and a way to set it freewheeling as a clock.","title":"Basic Controls"},{"location":"01-basic-controls/#basic-controls","text":"","title":"Basic Controls"},{"location":"01-basic-controls/#the-probe","text":"First, keep the switch on the probe set to Select Why Select mode? Measure mode allows the probe tip to be \u00b19V tolerant and routable like any other node, but as of yet, the code to actually do anything with it is unwritten so it just connects to DAC 0 and outputs 3.3V just like it was in Select mode. But the DAC is much worse at matching the RP2350B's idea of what 3.3V is exactly , so probing will be flaky and may be off from the rows you're tapping in Measure .","title":"The Probe"},{"location":"01-basic-controls/#connecting-rows","text":"Click the Connect button on the probe The logo should turn blue and the LEDs on the probe should also change Now any pair of nodes you tap should get connected as you make them. In connect mode, you're creating bridges (see the glossary ), so connections are made in pairs. When you've tapped the first node in a pair, the logo and Connect text on the probe will brighten to show that you're \" holding \" a connection, and the next thing you tap will connect to that first node . If you make a mistake while holding a connection, click the Connect button and it will clear it and take you back to the first node . If you click the Connect button while you're not holding a node , it will leave probe mode and bring you back into idle mode (rainbowy logo , all 3 probe LED s on.) To get out of Connect mode, press the button again.","title":"Connecting Rows"},{"location":"01-basic-controls/#encoder-connections","text":"You can also make connections using just the clickwheel, without needing to touch the probe to the breadboard: To activate: - Navigate to: Click > Connect > Add (or Remove ) - OR just turn the clickwheel while already in probe mode How it works: 1. Turn the clickwheel to scroll through all available nodes: - Breadboard rows (1-60) - Nano header pins (D0-A7) - Rails (Top, Bottom, GND) - DAC (0, 1) - ADC (0-4, Probe) - GPIO (1-8) - UART (TX, RX) - Current sense (I+, I-) Click the encoder button to select the highlighted node Hold the encoder button to exit The cursor will automatically hide after 5 seconds of inactivity. This is especially useful when you need precise control or want to access special functions without tapping pads.","title":"Encoder Connections"},{"location":"01-basic-controls/#removing-rows","text":"Click the Remove button and the logo should turn reddish Now you can swipe along the pad s or tap them one at a time. Remember it only disconnects that node and anything connected to it directly, not everything on the net . So tapping say, row 25 that's connected to GND won't clear everything connected to GND , but tapping the - on the rails (for GND ) would. The special functions work the same way, tap the pad, pick one, and it will remove it. Click the button again to get out.","title":"Removing Rows"},{"location":"01-basic-controls/#probe-notes","text":"Remember the probe is read by a resistive voltage divider , so putting your fingers on the pads (or the back sides of the 4 risers that connect those probe sense boards to the main board), or anything causing the probe tip not to be at a steady 3.3V will give you weird readings. If you can't seem to stop playing with the switch on the probe, run the app probe calib and tap around on the board while turning the clickweel until the place you tapped is always spot on (do this with the switch in both modes), and hold the clickwheel button to save. This adjusts the nominal 3.3V measure mode puts out should be fairly accurate enough for probing.","title":"Probe Notes"},{"location":"01-basic-controls/#the-click-wheel","text":"There are two kinds of presses, click (short press) and hold (long press). In general, a click (short) is a yes , and a hold (long) is a no / back / exit / whatever . When I say click , it's more of a diagonal slide toward the center of the board ( these encoders were meant to poke out just a little bit from the side of a tablet or whatever.) To get to the menu, click the button and scroll through the menus, click will bring you into that menu, hold will take you back one level. If you have trouble reading stuff on the breadboard LEDs, everything is copied to the Serial terminal and the OLED (talked about in OLED Section ), and adjusting the brightness may help; in the menus, it's Display Options > Bright > Menu and then scroll around until you find a level you like, then click to confirm.","title":"The Click Wheel"},{"location":"01-basic-controls/#special-functions","text":"To connect to special functions , tap the corresponding pad near the logo, it will show you a menu on the breadboard and terminal to choose them. You can think of special functions just like any other node , the only difference is they're in a sort of \"folder\" so I didn't need to put a dedicated pad for each of them. DAC Pad \u2514\u2500 0 1 [ Tap pads below selection ] \u00b9 \u2514\u2500 - 8 V ! : . : ! + 8 V [ Tap bottom pads or use clickwheel to select a voltage ] > [ click probe Connect button to confirm ] \u00b2 \u2514\u2500 [ Tap a row to connect it to ] ( or if you were already \"holding\" a node , it 'll connect there)\u00b3 (This is an ASCII version of what will show on the breadboard LEDs) \u00b9 \u00b2 \u00b3 GPIO Pad \u2514\u2500 \u20711 \u2070 \u20712 \u2070 \u20713 \u2070 \u20714 \u2070 \u2081 5 \u2080 \u2081 6 \u2080 \u2081 7 \u2080 \u2081 8 \u2080 [ Tap pads to choose which ` GPIO ` ( left side for input , right side for output )] \u2514\u2500 [ Tap a row to connect it to ] ( or if you were already \"holding\" a node , it 'll connect there) \u00b9 The 4 user pads will be remappable in the future, but for now, top_guy is routable UART Tx and bottom_guy is routable UART Rx , and buiding pads are Current sense + and -. The building pads have multiple functions: - In idle mode : Override colors for net highlighting (see Idle Mode Interactions ) - In connect / remove mode: Access Current Sense (I+/I-) with marching ants visualization!","title":"Special Functions"},{"location":"01-basic-controls/#current-sensing-with-marching-ants","text":"When you tap either building pad in connect or remove mode, you'll get access to the current sense inputs (I+ and I-). When both I+ and I- are connected to different nets in your circuit: A virtual wire appears between the two nets containing the I Sense nodes Animated \"marching ants\" flow along this wire showing current direction The animation automatically picks the where to put the virtual \"wire\". It will search other nodes on the same nets that I sense + and I sense - are on it prefers places where they're on the same level so it can actually draw a connecting wire and not just be vertical lines. Your browser does not support the video tag. !!! warning I Sense + and I Sense - go on different nets but they're shorted internally They're two ends of a 2\u03a9 shunt resistor, so remember that these will be shorted together. You measure current in series so this is expected, but it's super easy to forget. Take this warning as the equivalent of your multimeter yelling at you when you have the probes in the current holes and have it set to voltage.","title":"Current Sensing with Marching Ants"},{"location":"01-basic-controls/#idle-mode-net-highlighting","text":"The main thing is that there's a lot more interaction that can be done outside of any particular mode (like not probing and the logo is rainbowy, I'm gonna call this idle mode here until I think of a good name) Here's what's new (all of this is in idle mode):","title":"Idle Mode Net Highlighting"},{"location":"01-basic-controls/#basic-interactions","text":"Tapping nets highlights them as before, but there's a slightly different animation on the row you have selected from the whole net The click wheel scrolls through highlighting rows as if you tapped each one","title":"Basic Interactions"},{"location":"01-basic-controls/#row-selection-actions","text":"With a row selected, here's what you can do:","title":"Row Selection Actions"},{"location":"01-basic-controls/#connect-button","text":"connect button will bring you into probing mode with the highlighted row already selected and then spit you back out to idle mode once you've made a connection to another row, or click connect again to exit","title":"Connect Button"},{"location":"01-basic-controls/#remove-button","text":"remove will remove the highlighted node","title":"Remove Button"},{"location":"01-basic-controls/#measurement-display","text":"if the highlighted row is a measurement ( gpio input or adc ) it will print the state to serial and the oled","title":"Measurement Display"},{"location":"01-basic-controls/#output-toggle","text":"if the highlighted row is an output ( gpio output , I'll eventually do dacs too) clicking the connect button will toggle it high / low . The remove button will just unhighlight the net (there were some choices here, like make each button assigned to high / low or allow removing them, but this felt like the best way after trying them all). I will eventually add a setting for the toggle repeat rate (set to 500ms now) and a way to set it freewheeling as a clock.","title":"Output Toggle"},{"location":"03-app/","text":"The App Installation guide The Jumperless App is now on PyPi! The easiest way to get started is with pip: pip install jumperless Then run it with: jumperless Note: If the app version shows less than the latest release, pip defaults to a local version if it's available. In that case, run: pip install --no-cache-dir --upgrade jumperless to make sure it grabs the latest version. The app repo is at https://github.com/Architeuthis-Flux/Jumperless-App Alternative: Download Pre-built Binaries Find the latest release https://github.com/Architeuthis-Flux/JumperlessV5/releases/latest The link above will magically lead you to the latest version, and will look something like https : // github . com / Architeuthis - Flux / JumperlessV5 / releases / tag / 5.2.0.0 At the bottom under Assets, download the Jumperless App for your OS Windows Jumperless . exe Jumperless - Windows - x64 . zip macOS Jumperless_Installer . dmg Jumperless_macOS . zip Linux x86 Jumperless - linux - x86_64 . tar . gz (if you're not sure which flavor of Linux, use this one) arm64 Jumperless - linux - arm64 . tar . gz Python download JumperlessWokwiBridge . py and requirements . txt open your favorite terminal, navigate to the folder where you downloaded the two files above. pip install - r requirements . txt # run this command to install the needed Python libraries python3 JumperlessWokwiBridge . py # open the app, will update firmware if there's a newer version Now that I've lifted my self-imposed ban on VT100 commands (for compatibility and me-spending-too-much-time-on-them reasons, but, YOLO), we've got colors now! But that's like the least cool thing the new app can do, here's a list of what's new: What It Does Firmware updating should be pretty reliable when there's a new version (falls back to instructions for how to do it manually) Command history and tab completion , up arrows will go through past commands and are persistent after closing Properly detects which port is the main Jumperless Serial and which is routable UART Arduino flashing from Wokwi works once again and is a lot more solid It installs arduino-cli on first startup and uses it pull in libraries, compile, and flash an arduino Nano in the header If the routable UART lines aren't connected when the app detects a change in the sketch file, it will connect them to flash the new code and then return them to how they were avrdude output is shown in real time (you'd be amazed how difficult this was) Direct Wokwi circuit import - Copy diagram.json from Wokwi and import it with the W command (see below) No longer a janky pile of garbage Local Arduino Sketch Support You can set a slot to point to a local Arduino sketch.ino file and it will flash if it detects a change If you don't like using Arduino IDE or Wokwi and prefer using vim or emacs or whatever, now you can let the app handle the flashing stuff and just edit an .ino file. In the app, type menu then slots and instead of entering a link to a Wokwi project, just give it a path to a file (this will be saved so you can unassign it and pick it later by name) (This one is so fucking sick) Launch Scripts Launch scripts included to easily run it from your favorite terminal emulator and not just the system default (terminal.app on macOS, Powershell on Windows, idk on Linux), just go to the directory in a terminal and run the script in tabby or whatever The launcher should kill other instances (and close their windows) that happen to be open because it's such a common issue for me at least Linux people are no longer red-headed stepchildren, there are proper tar.gz packages now for you nerds Importing Circuits from Wokwi You can design circuits in the Wokwi online simulator and import them directly to your Jumperless with the W command, or use the Jumperless App and it'll pull it from your project automatically and live update. Direct Link Import You can now just dump a Wokwi link into the app at any time and it'll work: Menu ~~~~~ x = clear all connections + = add connections - = remove connections https : // wokwi . com / projects / 424432011346848769 Enter a name for this new project : cool project zone \u2713 Saved 'cool project zone' to project library \u2713 'cool project zone' assigned to active slot 0 URL : https : // wokwi . com / projects / 424432011346848769 The project will start updating automatically How to manually Import from Wokwi Design your circuit on wokwi.com Click on the diagram . json tab in the Wokwi editor Copy all the JSON content (Ctrl+A, Ctrl+C or Cmd+A, Cmd+C) In Jumperless, type W and press Enter Paste the JSON (Ctrl+V or right-click \u2192 Paste) The parser automatically detects when the JSON is complete and imports it! Supported Wokwi Components Half breadboard - Wokwi's breadboard maps directly to Jumperless rows Arduino Nano - All pins (D0-D13, A0-A7) (GND, 5V, 3.3V, and RST pins are hardwired and don't do anything) Logic Analyzer - Channels map to GPIO: D0-7 \u2192 GPIO 1-8 Wire colors - Wokwi wire colors preserved Rail voltages - Detected from text labels in Wokwi VCC and GND Nodes - VCC maps to the TOP_RAIL Note: The app still works with the OG Jumperless and those original mappings remain the same. Wire Color Mapping Wire colors will match the ones you set in Wokwi! The new Wokwi parser sends the entire diagram . json from Wokwi and parses it on the Jumperless, which means color information gets preserved. All Wokwi wire colors are preserved and displayed on the breadboard LEDs: red , orange , yellow , green , blue , violet , purple , magenta , cyan , white , gray , black , brown , limegreen , gold Note: Black wires let the Jumperless auto-assign a color. If you leave all the wires green (the default in Wokwi) or make a wire black, it'll just auto assign colors. About color assignment: There is some weirdness because colors in Wokwi are applied to bridges (a pair of nodes ) while color in the Jumperless gets assigned to nets (a collection of connected nodes ). So if you have a bunch of things electrically connected together with different wire colors, it'll just pick one. It tries to pick unique colors first (no other nets with that same color), but if it can't, it'll shift the hue a bit so it's still that color but you can hopefully tell them apart. Rail Voltage Detection Add a text label in your Wokwi diagram to specify rail voltages: top rail 5.5 V bottom rail 3.5 V The Jumperless parser will automatically detect these values and set the rails accordingly Command Variants W # Paste JSON, save to active slot W 5 # Paste JSON, save to slot 5 W / file . json # Load from file, save to active slot After Import Use < to cycle through slots to activate your imported circuit, or it will be active immediately if imported to the current slot. Terminal Compatibility Or you can use any terminal emulator you like, iTerm2 , xTerm , Tabby , Arduino IDE 's Serial Monitor, whatever. The TUI is all handled from the Jumperless itself so it just needs something to print text.","title":"The App"},{"location":"03-app/#the-app","text":"","title":"The App"},{"location":"03-app/#installation-guide","text":"","title":"Installation guide"},{"location":"03-app/#the-jumperless-app-is-now-on-pypi","text":"The easiest way to get started is with pip: pip install jumperless Then run it with: jumperless Note: If the app version shows less than the latest release, pip defaults to a local version if it's available. In that case, run: pip install --no-cache-dir --upgrade jumperless to make sure it grabs the latest version. The app repo is at https://github.com/Architeuthis-Flux/Jumperless-App","title":"The Jumperless App is now on PyPi!"},{"location":"03-app/#alternative-download-pre-built-binaries","text":"","title":"Alternative: Download Pre-built Binaries"},{"location":"03-app/#find-the-latest-release","text":"https://github.com/Architeuthis-Flux/JumperlessV5/releases/latest The link above will magically lead you to the latest version, and will look something like https : // github . com / Architeuthis - Flux / JumperlessV5 / releases / tag / 5.2.0.0 At the bottom under Assets, download the Jumperless App for your OS","title":"Find the latest release"},{"location":"03-app/#windows","text":"Jumperless . exe Jumperless - Windows - x64 . zip","title":"Windows"},{"location":"03-app/#macos","text":"Jumperless_Installer . dmg Jumperless_macOS . zip","title":"macOS"},{"location":"03-app/#linux","text":"x86 Jumperless - linux - x86_64 . tar . gz (if you're not sure which flavor of Linux, use this one) arm64 Jumperless - linux - arm64 . tar . gz","title":"Linux"},{"location":"03-app/#python","text":"download JumperlessWokwiBridge . py and requirements . txt open your favorite terminal, navigate to the folder where you downloaded the two files above. pip install - r requirements . txt # run this command to install the needed Python libraries python3 JumperlessWokwiBridge . py # open the app, will update firmware if there's a newer version Now that I've lifted my self-imposed ban on VT100 commands (for compatibility and me-spending-too-much-time-on-them reasons, but, YOLO), we've got colors now! But that's like the least cool thing the new app can do, here's a list of what's new:","title":"Python"},{"location":"03-app/#what-it-does","text":"Firmware updating should be pretty reliable when there's a new version (falls back to instructions for how to do it manually) Command history and tab completion , up arrows will go through past commands and are persistent after closing Properly detects which port is the main Jumperless Serial and which is routable UART Arduino flashing from Wokwi works once again and is a lot more solid It installs arduino-cli on first startup and uses it pull in libraries, compile, and flash an arduino Nano in the header If the routable UART lines aren't connected when the app detects a change in the sketch file, it will connect them to flash the new code and then return them to how they were avrdude output is shown in real time (you'd be amazed how difficult this was) Direct Wokwi circuit import - Copy diagram.json from Wokwi and import it with the W command (see below) No longer a janky pile of garbage","title":"What It Does"},{"location":"03-app/#local-arduino-sketch-support","text":"You can set a slot to point to a local Arduino sketch.ino file and it will flash if it detects a change If you don't like using Arduino IDE or Wokwi and prefer using vim or emacs or whatever, now you can let the app handle the flashing stuff and just edit an .ino file. In the app, type menu then slots and instead of entering a link to a Wokwi project, just give it a path to a file (this will be saved so you can unassign it and pick it later by name) (This one is so fucking sick)","title":"Local Arduino Sketch Support"},{"location":"03-app/#launch-scripts","text":"Launch scripts included to easily run it from your favorite terminal emulator and not just the system default (terminal.app on macOS, Powershell on Windows, idk on Linux), just go to the directory in a terminal and run the script in tabby or whatever The launcher should kill other instances (and close their windows) that happen to be open because it's such a common issue for me at least Linux people are no longer red-headed stepchildren, there are proper tar.gz packages now for you nerds","title":"Launch Scripts"},{"location":"03-app/#importing-circuits-from-wokwi","text":"You can design circuits in the Wokwi online simulator and import them directly to your Jumperless with the W command, or use the Jumperless App and it'll pull it from your project automatically and live update.","title":"Importing Circuits from Wokwi"},{"location":"03-app/#direct-link-import","text":"You can now just dump a Wokwi link into the app at any time and it'll work: Menu ~~~~~ x = clear all connections + = add connections - = remove connections https : // wokwi . com / projects / 424432011346848769 Enter a name for this new project : cool project zone \u2713 Saved 'cool project zone' to project library \u2713 'cool project zone' assigned to active slot 0 URL : https : // wokwi . com / projects / 424432011346848769 The project will start updating automatically","title":"Direct Link Import"},{"location":"03-app/#how-to-manually-import-from-wokwi","text":"Design your circuit on wokwi.com Click on the diagram . json tab in the Wokwi editor Copy all the JSON content (Ctrl+A, Ctrl+C or Cmd+A, Cmd+C) In Jumperless, type W and press Enter Paste the JSON (Ctrl+V or right-click \u2192 Paste) The parser automatically detects when the JSON is complete and imports it!","title":"How to manually Import from Wokwi"},{"location":"03-app/#supported-wokwi-components","text":"Half breadboard - Wokwi's breadboard maps directly to Jumperless rows Arduino Nano - All pins (D0-D13, A0-A7) (GND, 5V, 3.3V, and RST pins are hardwired and don't do anything) Logic Analyzer - Channels map to GPIO: D0-7 \u2192 GPIO 1-8 Wire colors - Wokwi wire colors preserved Rail voltages - Detected from text labels in Wokwi VCC and GND Nodes - VCC maps to the TOP_RAIL Note: The app still works with the OG Jumperless and those original mappings remain the same.","title":"Supported Wokwi Components"},{"location":"03-app/#wire-color-mapping","text":"Wire colors will match the ones you set in Wokwi! The new Wokwi parser sends the entire diagram . json from Wokwi and parses it on the Jumperless, which means color information gets preserved. All Wokwi wire colors are preserved and displayed on the breadboard LEDs: red , orange , yellow , green , blue , violet , purple , magenta , cyan , white , gray , black , brown , limegreen , gold Note: Black wires let the Jumperless auto-assign a color. If you leave all the wires green (the default in Wokwi) or make a wire black, it'll just auto assign colors. About color assignment: There is some weirdness because colors in Wokwi are applied to bridges (a pair of nodes ) while color in the Jumperless gets assigned to nets (a collection of connected nodes ). So if you have a bunch of things electrically connected together with different wire colors, it'll just pick one. It tries to pick unique colors first (no other nets with that same color), but if it can't, it'll shift the hue a bit so it's still that color but you can hopefully tell them apart.","title":"Wire Color Mapping"},{"location":"03-app/#rail-voltage-detection","text":"Add a text label in your Wokwi diagram to specify rail voltages: top rail 5.5 V bottom rail 3.5 V The Jumperless parser will automatically detect these values and set the rails accordingly","title":"Rail Voltage Detection"},{"location":"03-app/#command-variants","text":"W # Paste JSON, save to active slot W 5 # Paste JSON, save to slot 5 W / file . json # Load from file, save to active slot","title":"Command Variants"},{"location":"03-app/#after-import","text":"Use < to cycle through slots to activate your imported circuit, or it will be active immediately if imported to the current slot.","title":"After Import"},{"location":"03-app/#terminal-compatibility","text":"Or you can use any terminal emulator you like, iTerm2 , xTerm , Tabby , Arduino IDE 's Serial Monitor, whatever. The TUI is all handled from the Jumperless itself so it just needs something to print text.","title":"Terminal Compatibility"},{"location":"04-oled/","text":"OLED Support First, get yourself one of these bad boys (literally any of these are fine.) https://www.amazon.com/MakerFocus-Display-SSD1306-3-3V-5V-Arduino/dp/B079BN2J8V Ignore the really cool LEDs. Installation They should friction fit into the SBC/SMD/OLED board included with your Jumperless V5. Yo This should copy basically any text printed on the breadboard, some people have trouble reading text on the breadboard LEDs, which is why I added all this. Connection To connect the data lines to the Jumperless' GPIO 7 and 8, just use the menu option . (that's a period). It will try to find the OLED on the I2C bus, after a few failed attempts, it'll automatically disconnect to free up GPIO 7 and 8. Auto-Connect on Boot If you want to use this all the time, there's a config option to connect the OLED on startup. You can just paste this into the main menu: ` [ top_oled ] connect_on_boot = true ; Lock Connection Locking the connection to the OLED ensures that it stays connected even when you enter a complete node list. So if you're using Wokwi or manually adding connections in a file, you don't need to add GPIO_7 - D2 and GPIO_8 - D3 to keep the I2C connected to the OLED. ` [ top_oled ] lock_connection = true ; Custom Startup Message You can customize what appears on the OLED when your Jumperless boots up. There are two options: text messages or custom bitmap images. Text Message Set a custom text message to display on the OLED at startup (max 32 characters): ` [ top_oled ] startup_message = Your Message Here ; This message will appear after the Jumperless logo on boot. Bitmap Image Display a custom bitmap image at startup by just giving it a path on the filesystem. ` [ top_oled ] startup_message = / images / mylogo . bin ; Requirements: - Image must be a bitmap file ( . bin format) with 4-byte header - Recommended size: 128\u00d732 pixels (standard OLED size) - Use the built-in Bitmap Editor to create or edit images - Store images in the / images / directory on the Jumperless filesystem Display Dimensions If you have a different sized OLED (like 128x64), you can set the dimensions: ` [ top_oled ] width = 128 ; ` [ top_oled ] height = 64 ; Advanced GPIO Configuration You can change both the GPIO used for the display or the rows it connects to with the config options: ` [ top_oled ] sda_pin = 26 ; ` [ top_oled ] scl_pin = 27 ; ` [ top_oled ] gpio_sda = GP_7 ; ` [ top_oled ] gpio_scl = GP_8 ; ` [ top_oled ] sda_row = D2 ; ` [ top_oled ] scl_row = D3 ; Connection type ` [ top_oled ] connection_type = rp6_rp7 ; Bitmap Editor The built-in bitmap editor lets you create and edit OLED images directly on your Jumperless using your terminal and the clickwheel. Your browser does not support the video tag. Accessing the Bitmap Editor From File Manager Open the file manager from the main menu Navigate to a . bin bitmap file Select the file to open it in the editor Creating a New Image You can create a new bitmap file from the file manager: 1. Navigate to where you want to create the file (e.g., / images / ) 2. Pess n for \"new file\" 3. Name it with a . bin extension (e.g., mylogo . bin ) 4. The editor will automatically create a blank 128\u00d732 bitmap (or whatever your OLED dimensions are set to in config) Editor Interface The bitmap editor displays your image in the terminal and on the OLED (if connected). You'll see: Main canvas : Your bitmap rendered using block characters Status bar : Filename, dimensions, cursor position, and save status Menu bar : Quick access to View, Encoder, Draw modes, Save, and Quit Help panel : Keyboard shortcuts and hardware control reference View Modes Press m to cycle through three display modes: Full Block Mode (1:1 pixel mapping) Each character = 1 pixel Half Block Mode (2:1 vertical compression) Each character = 2 pixels vertically Fits 128\u00d732 images on smaller terminals Quarter Block Mode (2\u00d72 compression) Each character = 2\u00d72 pixels (4 pixels total) Fits larger images on screen Navigation Moving the Cursor Keyboard: - Arrow keys or W / A / S / D keys - Vim keys: j (down), k (up), l (right) Hardware: - Clickwheel encoder : Rotate to move cursor - Probe switch : - Select position \u2192 Horizontal movement - Measure position \u2192 Vertical movement - Press / to toggle encoder direction (H/V) independently Editing Pixels Editing Methods The editor has three draw modes (cycle with . key) to pick what happens when you press enter / space / encoder click : Toggle Mode (default): Flips pixel state (ON\u2194OFF) Set Mode : Always turns pixels ON (draw) Clear Mode : Always turns pixels OFF (erase) Or just use these keys to do it directly and not worry about the mode: z = Set pixel (turn ON) x = Clear pixel (turn OFF) c = Toggle pixel Menu Bar Navigation When the cursor reaches the bottom edge and you press down, you enter the menu bar: Navigation: - Left/Right arrows: Move between menu items - Enter/Space: Activate selected item - Up: Exit menu bar Menu Items: - View : Cycle display modes (Full/Half/Quarter) - Enc : Toggle encoder direction (H/V) - Draw : Cycle draw modes (Toggle/Set/Clear) - \u00abSave\u00bb : Save file and return to editing - \u00abQuit\u00bb : Exit editor (prompts if modified) Saving and Quitting Ctrl+S : Quick save Ctrl+Q : Quit (prompts to save if modified) h or ? : Show help screen The editor automatically adds the 4-byte header (width and height) when saving, making the file compatible as a startup image. Example Workflow: Creating a Startup Logo Open file manager, navigate to / images / Create new file: mylogo . bin Editor opens with blank 128\u00d732 canvas Switch to Half Block mode ( m ) for better overview Use clickwheel to navigate, Connect button to draw Save with Ctrl+S Set as startup image: By editing the config file: ` [ top_oled ] startup_image = / images / mylogo . bin Or use the click menus OLED > Startup message > image > (scroll through all the images and click to select) Reboot or enter/exit the click menu to see your custom logo Editor Screenshots Full size view (1:1 pixel mapping): \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 / images / bubbleJump . bin | 128 x32 | ( 64 , 16 ) | Saved View : Full | Enc : V | Draw : CLR | \u00ab Save \u00bb | \u00ab Quit \u00bb \u27e8 Clickwheel > \u21ba / \u21bb : move H / V | Click : toggle pixel \u27e9 \u27e8 Probe Buttons > Connect : set | Remove : clear | Switch > Select : H | Measure : V \u27e9 \u27e8 Terminal > [ z ]: set [ x ]: clear [ c ]: toggle pixel | [ m ]: Cycle View | [ / ]: Enc H / V | ctrl + S : Save | ctrl + Q : Quit | [ ? ]: Help \u27e9 Half Block view (2:1 vertical compression - each character is 2 pixels tall): \u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2580\u2580\u2580\u2580\u2580\u2580\u2588\u2584 \u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2580\u2580\u2580\u2580\u2580\u2588\u2584 \u2584\u2588\u2580\u2580\u2580\u2588\u2584 \u2584\u2588\u2580\u2580 \u2580\u2588 \u2584\u2580\u2580 \u2580\u2588\u2584\u2584\u2580 \u2588\u2584 \u2584\u2588\u2580\u2580\u2580\u2588 \u2584\u2584\u2584\u2584 \u2584\u2580\u2580\u2588\u2584 \u2584\u2584\u2584 \u2584\u2588\u2580\u2580\u2588\u2584\u2584\u2580\u2580\u2580\u2580 \u2580\u2588\u2584\u2584\u2580\u2580\u2580\u2580 \u2580\u2584\u2580 \u2580\u2588\u2584\u2580 \u2588\u2584 \u2584\u2580 \u2588\u2588 \u2588\u2580 \u2584\u2584 \u2588 \u2584\u2588\u2580 \u2588\u2580 \u2580\u2588\u2584\u2580 \u2588\u2588\u2580 \u2580\u2588 \u2588 \u2588 \u2580\u2588\u2580 \u2588 \u2584\u2584\u2584\u2584\u2584 \u2580\u2588 \u2588\u2588 \u2588\u2580 \u2584\u2584\u2588\u2588 \u2584\u2588\u2588\u2584 \u2588 \u2588\u2588\u2588\u2588 \u2584\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2584\u2588 \u2588 \u2584\u2588\u2588\u2588\u2588 \u2588 \u2584\u2584\u2584\u2584\u2584\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2584\u2588\u2588\u2588\u2580\u2580 \u2580\u2588 \u2588\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588 \u2580\u2588\u2588\u2588\u2588\u2588\u2580\u2580 \u2588\u2588 \u2588 \u2588\u2588\u2584 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2580\u2580\u2588\u2588 \u2588 \u2588\u2588\u2588\u2580\u2580 \u2588\u2584 \u2588 \u2580\u2588 \u2588 \u2588\u2588\u2580 \u2588 \u2588\u2588\u2584\u2584\u2584\u2584\u2584 \u2588\u2584 \u2580\u2588\u2588\u2588 \u2580\u2580\u2580\u2588 \u2580\u2580\u2588\u2584 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2580 \u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2584\u2584\u2584\u2584 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2580\u2580 \u2580\u2588\u2580\u2588\u2584 \u2580\u2580\u2588\u2584 \u2580\u2588\u2584\u2584 \u2588\u2584 \u2580\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2580\u2584 \u2584\u2588 \u2588 \u2580\u2580 \u2580\u2588\u2580\u2588 \u2588\u2584\u2584\u2588\u2580 \u2584\u2588\u2584 \u2588\u2580 \u2588\u2588 \u2584\u2588 \u2580\u2580\u2588\u2584\u2584\u2584 \u2588\u2584 \u2580\u2588\u2588\u2588\u2584 \u2580\u2588 \u2588\u2584 \u2580\u2588 \u2588\u2588\u2588 \u2588 \u2584 \u2588 \u2588\u2588\u2588\u2580 \u2588 \u2584\u2588 \u2584\u2588 \u2580\u2580\u2580 \u2584\u2588\u2588\u2588 \u2588 \u2588 \u2584\u2588\u2588\u2588\u2580\u2580 \u2580\u2588\u2588\u2588 \u2588\u2584\u2588\u2580\u2580\u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2584\u2588 \u2588\u2588 \u2588\u2588 \u2584\u2588\u2588\u2580\u2580 \u2580\u2588 \u2588\u2588\u2580 \u2588 \u2588 \u2584\u2584\u2584\u2588 \u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2584\u2584\u2588\u2580\u2580\u2580\u2588\u2588\u2580 \u2588\u2580 \u2580\u2580 \u2588 \u2584\u2588\u2580\u2580\u2588\u2584 \u2588 \u2588\u2584 \u2580 \u2588\u2588 \u2588\u2588\u2584\u2588\u2588 \u2588 \u2584\u2584\u2584\u2584\u2584\u2588\u2580\u2588\u2588 \u2588\u2588\u2584\u2584\u2584\u2584\u2584 \u2588 \u2588\u2588\u2584 \u2580\u2588\u2584\u2588 \u2588\u2588\u2580\u2580 \u2580\u2588 \u2580\u2580 \u2588\u2588 \u2588 \u2588\u2580 \u2588 \u2580\u2588\u2580 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2580\u2588\u2588 \u2588 \u2580\u2588\u2588\u2580\u2580 \u2588\u2588 \u2580\u2580 \u2580\u2588\u2588 \u2588\u2588\u2584 \u2580\u2588 \u2588 \u2584\u2588\u2588\u2584 \u2588\u2588\u2588\u2584 \u2584\u2588\u2580 \u2588 \u2588\u2580\u2588\u2588 \u2584\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2580\u2588\u2584 \u2584\u2588\u2588\u2584 \u2588\u2588\u2588\u2584 \u2584\u2588\u2588\u2584 \u2584\u2584\u2588\u2588\u2588\u2584\u2584\u2584\u2584\u2584\u2584\u2588\u2588\u2588\u2580\u2588\u2588\u2588\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2584 \u2588\u2588 \u2588\u2588\u2584 \u2584\u2588\u2580 \u2588\u2584 \u2584\u2588 \u2588\u2588\u2584\u2584\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588 \u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588 \u2580\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2588\u2588\u2584 \u2584\u2588\u2588 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580 \u2580\u2580\u2580 \u2580\u2580\u2580 \u2580\u2580\u2580\u2580\u2580\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2580\u2580\u2580 \u2580\u2580 / images / bubbleJump . bin | 128 x32 | ( 64 , 16 ) | Saved View : Half | Enc : V | Draw : CLR | \u00ab Save \u00bb | \u00ab Quit \u00bb \u27e8 Clickwheel > \u21ba / \u21bb : move H / V | Click : toggle pixel \u27e9 \u27e8 Probe Buttons > Connect : set | Remove : clear | Switch > Select : H | Measure : V \u27e9 \u27e8 Terminal > [ z ]: set [ x ]: clear [ c ]: toggle pixel | [ m ]: Cycle View | [ / ]: Enc H / V | ctrl + S : Save | ctrl + Q : Quit | [ ? ]: Help \u27e9 Quarter Block view (2\u00d72 compression - each character is 4 pixels): \u2584\u2584\u2584 \u2584\u2584\u2584\u2596 \u2597\u259e\u2580\u2580\u259c\u2596 \u2584\u2584\u2584 \u2597\u2584\u2584\u2596\u2597\u2584\u259e\u2580\u2580\u2599 \u259f\u2580\u259c\u2596 \u2597\u259b\u2598 \u259d\u258c\u2597\u2580 \u259c\u2584\u2598 \u2599 \u259f\u2580\u259c\u2597\u2584\u2596 \u259e\u259c\u2596\u2597\u2584 \u2597\u259b\u259c\u2584\u2580\u2580 \u259d\u2599\u259e\u2580\u2598 \u259a\u2598 \u259d\u2599\u2598 \u2599 \u2597\u2598 \u2590\u258c \u259b \u2584 \u2590 \u2597\u259b \u259b \u259c\u259e \u2588\u2598\u259d\u258c\u2590 \u258c \u259c\u2598 \u2590 \u2597\u2584\u2584 \u259c \u2588 \u259b \u2584\u2588 \u259f\u2599 \u258c \u2590\u2588\u258c \u259f \u2590\u258c \u258c \u2590\u258c \u2590 \u258c\u259f \u258c \u259f\u2588\u258c \u2590 \u2597\u2584\u2584\u2588 \u2588\u2588\u258c \u2590 \u2588 \u258c \u2597\u2588\u259b\u2598\u259c \u2588\u2588\u2584\u259f\u258c \u259d\u2588\u2588\u259b\u2598 \u2588 \u258c \u2590\u2599 \u2590 \u2590\u258c \u258c \u2588\u2580\u2588 \u2590 \u2588\u259b\u2598\u2590\u2596 \u258c \u259c \u2590 \u2590\u259b \u258c \u2590\u2599\u2584\u2584\u2590\u2596 \u259d\u2588\u258c\u2580\u259c \u2580\u2599 \u2590\u258c \u258c \u2590\u2588 \u2590 \u2598 \u258c \u258c \u2590 \u2590 \u2588\u2584\u2584\u2590\u258c \u2590 \u2590 \u2590 \u2590\u258c \u2588 \u259d\u2598 \u259d\u259b\u2599 \u2580\u2599\u259d\u2599\u2596 \u2590\u2596 \u259d\u258c \u258c \u2590\u2588\u258c \u2590 \u258c \u259a \u259f \u2590 \u2580 \u259d\u259b\u258c \u2590\u2584\u259b \u259f\u2596 \u2590\u2598 \u2588 \u2597\u258c\u259d\u259c\u2584\u2596 \u2590\u2596\u259d\u2588\u2599 \u259c \u2599 \u259c \u2588\u258c \u2590 \u2596 \u258c \u2590\u2588\u2598 \u2590 \u2597\u258c\u259f \u259d\u2580 \u2597\u2588\u258c \u2590 \u2590 \u259f\u2588\u2580 \u259c\u2588 \u2599\u259b\u259c\u2588\u258c \u2590 \u2590 \u2590 \u2588\u258c \u2590\u258c \u258c\u2597\u258c \u2588 \u2588 \u2597\u2588\u2580 \u259c \u2588\u2598\u258c \u2590 \u2584\u259f \u2588\u2588\u2580\u2599\u259f\u2580\u259c\u259b \u259b \u2580 \u2590 \u259f\u2580\u2599\u2590 \u2590\u2596 \u259d \u2590\u258c \u2588\u259f\u258c \u2590 \u2584\u2584\u259f\u259c\u258c \u2590\u2599\u2584\u2584\u2590 \u2590\u2599 \u259d\u2599\u258c \u2590\u259b\u2598\u259d\u258c \u259d\u2598 \u2590\u258c \u258c \u259b \u258c \u259d\u259b \u2590\u258c \u2588\u258c \u2590\u259c\u258c \u2590 \u259c\u259b\u2598\u2590\u258c \u2580 \u259d\u2588 \u2588\u2596 \u259d\u258c \u258c \u259f\u2599 \u2590\u2588\u2596 \u259f\u2598 \u258c \u259b\u2588 \u2597\u258c\u258c \u2590 \u258c \u2590 \u2590 \u259d\u2599 \u2597\u2588\u2596 \u2588\u2599 \u2597\u2588\u2596 \u2597\u259f\u2588\u2584\u2584\u2584\u2588\u259b\u2588\u2599\u2584\u2584\u2584\u259b\u259d\u2588\u2588\u2588\u2588\u258c \u2599 \u2590\u258c\u2590\u2599 \u259f\u2598\u2599 \u259f \u2588\u2584\u2588\u2599\u2584\u2588 \u259c\u2599\u2584\u2584\u2588\u2588\u2580\u2588\u2588\u258c\u259c\u2588\u2588\u2580\u2588\u2588\u2588\u2588\u259b\u259d\u2588\u2588\u2588\u2598 \u259d\u259c\u2588\u2588\u259b \u259d\u2580\u2580\u2580 \u2590\u2599 \u2597\u2588 \u259c\u2588\u2588\u259b \u259c\u2588\u259b \u259c\u2588\u2598\u259c\u2588\u2598 \u259d\u2588\u2588\u259b\u2580 \u259d\u2580 \u2580\u2598 \u259d\u2580\u2580\u2598 \u259c\u2588\u2588\u2588\u2598 \u2580\u2580 \u2580 / images / bubbleJump . bin | 128 x32 | ( 64 , 16 ) | Saved View : Qtr | Enc : V | Draw : CLR | \u00ab Save \u00bb | \u00ab Quit \u00bb \u27e8 Clickwheel > \u21ba / \u21bb : move H / V | Click : toggle pixel \u27e9 \u27e8 Probe Buttons > Connect : set | Remove : clear | Switch > Select : H | Measure : V \u27e9 \u27e8 Terminal > [ z ]: set [ x ]: clear [ c ]: toggle pixel | [ m ]: Cycle View | [ / ]: Enc H / V | ctrl + S : Save | ctrl + Q : Quit | [ ? ]: Help \u27e9 The output of ? === Bitmap Editor Help === Navigation : Encoder wheel - Move cursor ( H or V mode ) Arrow keys / WASD - Move cursor j / k / l ( vim ) - Move cursor Down at bottom edge - Enter menu bar Editing : Encoder click - Apply current draw mode at cursor Enter / Space - Apply current draw mode at cursor Connect button HOLD - Set pixels while held ( draw lines ) Remove button HOLD - Clear pixels while held ( erase lines ) Direct Pixel Actions ( keyboard ): z - Set pixel at cursor ( draw ) x - Clear pixel at cursor ( erase ) c - Toggle pixel at cursor Draw Mode Control : . - Cycle draw modes ( Toggle / Set / Clear ) Hardware Controls : Probe switch SELECT - Encoder horizontal movement Probe switch MEASURE - Encoder vertical movement Display : m - Cycle view mode ( Full / Half / Quarter ) / - Toggle encoder H / V movement Menu Bar ( Down at bottom edge ): Left / Right arrows - Navigate menu items Enter / Space - Activate menu item ( cycle / Save / Quit ) Up / Escape - Exit menu bar Menu Bar Items : View - Cycle display mode ( Full / Half / Quarter ) Enc - Toggle encoder direction ( H / V ) Draw - Cycle draw mode ( Toggle / Set / Clear ) \u00ab Save \u00bb - [ Button ] Save file and exit menu \u00ab Quit \u00bb - [ Button ] Quit editor ( prompts if modified ) File : Ctrl + S - Save file Ctrl + Q / ESC - Quit ( prompts if modified ) h / ? - Show this help Cursor Colors : Green background - Pixel is OFF Red background - Pixel is ON Bitmap File Format The editor works with . bin files in two formats: With Header (Recommended): - 4 bytes: Width (16-bit little-endian) - 2 bytes: Height (16-bit little-endian) - Remaining: Bitmap data (MSB-first, row-major) - Example: 128\u00d732 = 4 header + 512 data = 516 bytes total Raw Format: - Just bitmap data, dimensions inferred from file size - 512 bytes \u2192 128\u00d732, 1024 bytes \u2192 128\u00d764, etc. The editor automatically adds headers when saving, making files ready to use as startup images. Converting External Images Want to use your own images? The JumperlOS repository includes Python scripts to convert PNG/JPG images to OLED bitmaps: Location: JumperlOS / scripts / image_to_oled_bitmap . py Usage: python image_to_oled_bitmap.py input.png output.bin --width 128 --height 32 The script will: Resize your image to fit the OLED dimensions Convert to 1-bit (black/white) format Save with proper header format Output is ready to use as a startup image or edit in the bitmap editor Then you can mount your Jumperless's filesystem as a mass storage device with U and drop it into the / images / folder. Check out the / scripts folder in the JumperlOS repo , there are a few other scripts related to dealing with bitmaps. Using the OLED from MicroPython The OLED display has a comprehensive MicroPython API for programmatic control. You can display text with multiple fonts and sizes, show bitmaps, manipulate pixels directly, and even redirect Python's print () output to the OLED. Quick Start import jumperless as j import time # Basic text display j . oled_connect () j . oled_print ( \"Hello!\" , 2 ) time . sleep ( 2 ) j . oled_clear () Text Sizes and Scrolling The OLED supports three text size modes: Size 0 : Small scrolling text - perfect for terminal-like output with multiple lines Size 1 : Normal centered text Size 2 : Large centered text (default) import jumperless as j import time # Set default text size j . oled_set_text_size ( 0 ) # Small scrolling text # Display multiple lines for i in range ( 10 ): j . oled_print ( f \"Line { i + 1 } \" ) time . sleep ( 0.3 ) # Switch to large text j . oled_set_text_size ( 2 ) j . oled_print ( \"BIG TEXT\" ) Print Redirection for Debugging One of the most useful features is print redirection - all print () statements can automatically appear on both the serial console and the OLED: import jumperless as j # Enable print copying j . oled_copy_print ( True ) # These appear on both serial AND OLED print ( \"Starting test...\" ) voltage = j . adc_get ( 0 ) print ( f \"Voltage: { voltage : .2f } V\" ) print ( \"Test complete!\" ) # Disable when done j . oled_copy_print ( False ) This is perfect for debugging projects where you don't have easy access to the serial console. Multiple Fonts Choose from 11 different font families: import jumperless as j # List all available fonts fonts = j . oled_get_fonts () print ( fonts ) # Set a fun font j . oled_set_font ( \"Jokerman\" ) j . oled_print ( \"Fun!\" , 2 ) # Switch to monospace for code j . oled_set_font ( \"Courier New\" ) j . oled_print ( \"Monospace\" , 2 ) Display Bitmaps Show bitmap images stored on the filesystem: import jumperless as j # One-liner to display a bitmap j . oled_show_bitmap_file ( \"/images/jogo32h.bin\" , 0 , 0 ) # Or load and display separately j . oled_load_bitmap ( \"/images/logo.bin\" ) j . oled_display_bitmap ( 0 , 0 , 0 , 0 ) Graphics and Pixel Control For custom graphics, you can manipulate individual pixels: import jumperless as j # Draw a box j . oled_clear () for x in range ( 20 , 108 ): j . oled_set_pixel ( x , 10 , 1 ) # Top j . oled_set_pixel ( x , 22 , 1 ) # Bottom for y in range ( 10 , 23 ): j . oled_set_pixel ( 20 , y , 1 ) # Left j . oled_set_pixel ( 107 , y , 1 ) # Right j . oled_show () Advanced: Direct Framebuffer Access For maximum control, you can read and write the entire framebuffer: import jumperless as j # Get display dimensions width , height , size = j . oled_get_framebuffer_size () print ( f \"Display: { width } x { height } , { size } bytes\" ) # Capture the screen fb = j . oled_get_framebuffer () # Save to file with open ( \"/screen_capture.bin\" , \"wb\" ) as f : f . write ( fb ) # Restore later with open ( \"/screen_capture.bin\" , \"rb\" ) as f : fb_data = f . read () j . oled_set_framebuffer ( fb_data ) Complete API Reference For the full API documentation with all functions, parameters, and examples, see: MicroPython API Reference - OLED Display Section The API includes: - Text size control ( oled_set_text_size , oled_get_text_size ) - Print redirection ( oled_copy_print ) - Font system ( oled_get_fonts , oled_set_font , oled_get_current_font ) - Bitmap functions ( oled_load_bitmap , oled_display_bitmap , oled_show_bitmap_file ) - Framebuffer access ( oled_get_framebuffer , oled_set_framebuffer , oled_get_framebuffer_size ) - Pixel manipulation ( oled_set_pixel , oled_get_pixel ) Example Projects Animated Sine Wave: import jumperless as j import math import time width , height , _ = j . oled_get_framebuffer_size () for offset in range ( 100 ): j . oled_clear ( False ) # Don't show() after clear to avoid flashing for x in range ( width ): y = int ( height // 2 + 10 * math . sin (( x + offset ) / 10 )) if 0 <= y < height : j . oled_set_pixel ( x , y , 1 ) j . oled_show () time . sleep ( 0.05 ) Sensor Monitor: import jumperless as j import time # Monitor voltage with print redirection j . oled_copy_print ( True ) j . oled_clear () while True : voltage = j . adc_get ( 0 ) current = j . ina_get_current ( 0 ) print ( f \"V: { voltage : .2f } V\" ) print ( f \"I: { current * 1000 : .1f } mA\" ) time . sleep ( 1 )","title":"OLED Support"},{"location":"04-oled/#oled-support","text":"First, get yourself one of these bad boys (literally any of these are fine.) https://www.amazon.com/MakerFocus-Display-SSD1306-3-3V-5V-Arduino/dp/B079BN2J8V Ignore the really cool LEDs.","title":"OLED Support"},{"location":"04-oled/#installation","text":"They should friction fit into the SBC/SMD/OLED board included with your Jumperless V5. Yo This should copy basically any text printed on the breadboard, some people have trouble reading text on the breadboard LEDs, which is why I added all this.","title":"Installation"},{"location":"04-oled/#connection","text":"To connect the data lines to the Jumperless' GPIO 7 and 8, just use the menu option . (that's a period). It will try to find the OLED on the I2C bus, after a few failed attempts, it'll automatically disconnect to free up GPIO 7 and 8.","title":"Connection"},{"location":"04-oled/#auto-connect-on-boot","text":"If you want to use this all the time, there's a config option to connect the OLED on startup. You can just paste this into the main menu: ` [ top_oled ] connect_on_boot = true ;","title":"Auto-Connect on Boot"},{"location":"04-oled/#lock-connection","text":"Locking the connection to the OLED ensures that it stays connected even when you enter a complete node list. So if you're using Wokwi or manually adding connections in a file, you don't need to add GPIO_7 - D2 and GPIO_8 - D3 to keep the I2C connected to the OLED. ` [ top_oled ] lock_connection = true ;","title":"Lock Connection"},{"location":"04-oled/#custom-startup-message","text":"You can customize what appears on the OLED when your Jumperless boots up. There are two options: text messages or custom bitmap images.","title":"Custom Startup Message"},{"location":"04-oled/#text-message","text":"Set a custom text message to display on the OLED at startup (max 32 characters): ` [ top_oled ] startup_message = Your Message Here ; This message will appear after the Jumperless logo on boot.","title":"Text Message"},{"location":"04-oled/#bitmap-image","text":"Display a custom bitmap image at startup by just giving it a path on the filesystem. ` [ top_oled ] startup_message = / images / mylogo . bin ; Requirements: - Image must be a bitmap file ( . bin format) with 4-byte header - Recommended size: 128\u00d732 pixels (standard OLED size) - Use the built-in Bitmap Editor to create or edit images - Store images in the / images / directory on the Jumperless filesystem","title":"Bitmap Image"},{"location":"04-oled/#display-dimensions","text":"If you have a different sized OLED (like 128x64), you can set the dimensions: ` [ top_oled ] width = 128 ; ` [ top_oled ] height = 64 ;","title":"Display Dimensions"},{"location":"04-oled/#advanced-gpio-configuration","text":"You can change both the GPIO used for the display or the rows it connects to with the config options: ` [ top_oled ] sda_pin = 26 ; ` [ top_oled ] scl_pin = 27 ; ` [ top_oled ] gpio_sda = GP_7 ; ` [ top_oled ] gpio_scl = GP_8 ; ` [ top_oled ] sda_row = D2 ; ` [ top_oled ] scl_row = D3 ;","title":"Advanced GPIO Configuration"},{"location":"04-oled/#connection-type","text":"` [ top_oled ] connection_type = rp6_rp7 ;","title":"Connection type"},{"location":"04-oled/#bitmap-editor","text":"The built-in bitmap editor lets you create and edit OLED images directly on your Jumperless using your terminal and the clickwheel. Your browser does not support the video tag.","title":"Bitmap Editor"},{"location":"04-oled/#accessing-the-bitmap-editor","text":"","title":"Accessing the Bitmap Editor"},{"location":"04-oled/#from-file-manager","text":"Open the file manager from the main menu Navigate to a . bin bitmap file Select the file to open it in the editor","title":"From File Manager"},{"location":"04-oled/#creating-a-new-image","text":"You can create a new bitmap file from the file manager: 1. Navigate to where you want to create the file (e.g., / images / ) 2. Pess n for \"new file\" 3. Name it with a . bin extension (e.g., mylogo . bin ) 4. The editor will automatically create a blank 128\u00d732 bitmap (or whatever your OLED dimensions are set to in config)","title":"Creating a New Image"},{"location":"04-oled/#editor-interface","text":"The bitmap editor displays your image in the terminal and on the OLED (if connected). You'll see: Main canvas : Your bitmap rendered using block characters Status bar : Filename, dimensions, cursor position, and save status Menu bar : Quick access to View, Encoder, Draw modes, Save, and Quit Help panel : Keyboard shortcuts and hardware control reference","title":"Editor Interface"},{"location":"04-oled/#view-modes","text":"Press m to cycle through three display modes: Full Block Mode (1:1 pixel mapping) Each character = 1 pixel Half Block Mode (2:1 vertical compression) Each character = 2 pixels vertically Fits 128\u00d732 images on smaller terminals Quarter Block Mode (2\u00d72 compression) Each character = 2\u00d72 pixels (4 pixels total) Fits larger images on screen","title":"View Modes"},{"location":"04-oled/#navigation","text":"","title":"Navigation"},{"location":"04-oled/#moving-the-cursor","text":"Keyboard: - Arrow keys or W / A / S / D keys - Vim keys: j (down), k (up), l (right) Hardware: - Clickwheel encoder : Rotate to move cursor - Probe switch : - Select position \u2192 Horizontal movement - Measure position \u2192 Vertical movement - Press / to toggle encoder direction (H/V) independently","title":"Moving the Cursor"},{"location":"04-oled/#editing-pixels","text":"","title":"Editing Pixels"},{"location":"04-oled/#editing-methods","text":"The editor has three draw modes (cycle with . key) to pick what happens when you press enter / space / encoder click : Toggle Mode (default): Flips pixel state (ON\u2194OFF) Set Mode : Always turns pixels ON (draw) Clear Mode : Always turns pixels OFF (erase) Or just use these keys to do it directly and not worry about the mode: z = Set pixel (turn ON) x = Clear pixel (turn OFF) c = Toggle pixel","title":"Editing Methods"},{"location":"04-oled/#menu-bar-navigation","text":"When the cursor reaches the bottom edge and you press down, you enter the menu bar: Navigation: - Left/Right arrows: Move between menu items - Enter/Space: Activate selected item - Up: Exit menu bar Menu Items: - View : Cycle display modes (Full/Half/Quarter) - Enc : Toggle encoder direction (H/V) - Draw : Cycle draw modes (Toggle/Set/Clear) - \u00abSave\u00bb : Save file and return to editing - \u00abQuit\u00bb : Exit editor (prompts if modified)","title":"Menu Bar Navigation"},{"location":"04-oled/#saving-and-quitting","text":"Ctrl+S : Quick save Ctrl+Q : Quit (prompts to save if modified) h or ? : Show help screen The editor automatically adds the 4-byte header (width and height) when saving, making the file compatible as a startup image.","title":"Saving and Quitting"},{"location":"04-oled/#example-workflow-creating-a-startup-logo","text":"Open file manager, navigate to / images / Create new file: mylogo . bin Editor opens with blank 128\u00d732 canvas Switch to Half Block mode ( m ) for better overview Use clickwheel to navigate, Connect button to draw Save with Ctrl+S Set as startup image: By editing the config file: ` [ top_oled ] startup_image = / images / mylogo . bin Or use the click menus OLED > Startup message > image > (scroll through all the images and click to select) Reboot or enter/exit the click menu to see your custom logo","title":"Example Workflow: Creating a Startup Logo"},{"location":"04-oled/#editor-screenshots","text":"Full size view (1:1 pixel mapping): \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 / images / bubbleJump . bin | 128 x32 | ( 64 , 16 ) | Saved View : Full | Enc : V | Draw : CLR | \u00ab Save \u00bb | \u00ab Quit \u00bb \u27e8 Clickwheel > \u21ba / \u21bb : move H / V | Click : toggle pixel \u27e9 \u27e8 Probe Buttons > Connect : set | Remove : clear | Switch > Select : H | Measure : V \u27e9 \u27e8 Terminal > [ z ]: set [ x ]: clear [ c ]: toggle pixel | [ m ]: Cycle View | [ / ]: Enc H / V | ctrl + S : Save | ctrl + Q : Quit | [ ? ]: Help \u27e9 Half Block view (2:1 vertical compression - each character is 2 pixels tall): \u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2580\u2580\u2580\u2580\u2580\u2580\u2588\u2584 \u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2580\u2580\u2580\u2580\u2580\u2588\u2584 \u2584\u2588\u2580\u2580\u2580\u2588\u2584 \u2584\u2588\u2580\u2580 \u2580\u2588 \u2584\u2580\u2580 \u2580\u2588\u2584\u2584\u2580 \u2588\u2584 \u2584\u2588\u2580\u2580\u2580\u2588 \u2584\u2584\u2584\u2584 \u2584\u2580\u2580\u2588\u2584 \u2584\u2584\u2584 \u2584\u2588\u2580\u2580\u2588\u2584\u2584\u2580\u2580\u2580\u2580 \u2580\u2588\u2584\u2584\u2580\u2580\u2580\u2580 \u2580\u2584\u2580 \u2580\u2588\u2584\u2580 \u2588\u2584 \u2584\u2580 \u2588\u2588 \u2588\u2580 \u2584\u2584 \u2588 \u2584\u2588\u2580 \u2588\u2580 \u2580\u2588\u2584\u2580 \u2588\u2588\u2580 \u2580\u2588 \u2588 \u2588 \u2580\u2588\u2580 \u2588 \u2584\u2584\u2584\u2584\u2584 \u2580\u2588 \u2588\u2588 \u2588\u2580 \u2584\u2584\u2588\u2588 \u2584\u2588\u2588\u2584 \u2588 \u2588\u2588\u2588\u2588 \u2584\u2588 \u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2588 \u2584\u2588 \u2588 \u2584\u2588\u2588\u2588\u2588 \u2588 \u2584\u2584\u2584\u2584\u2584\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2588 \u2584\u2588\u2588\u2588\u2580\u2580 \u2580\u2588 \u2588\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588 \u2580\u2588\u2588\u2588\u2588\u2588\u2580\u2580 \u2588\u2588 \u2588 \u2588\u2588\u2584 \u2588 \u2588\u2588 \u2588 \u2588\u2588\u2580\u2580\u2588\u2588 \u2588 \u2588\u2588\u2588\u2580\u2580 \u2588\u2584 \u2588 \u2580\u2588 \u2588 \u2588\u2588\u2580 \u2588 \u2588\u2588\u2584\u2584\u2584\u2584\u2584 \u2588\u2584 \u2580\u2588\u2588\u2588 \u2580\u2580\u2580\u2588 \u2580\u2580\u2588\u2584 \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2580 \u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2584\u2584\u2584\u2584 \u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588 \u2588\u2588 \u2580\u2580 \u2580\u2588\u2580\u2588\u2584 \u2580\u2580\u2588\u2584 \u2580\u2588\u2584\u2584 \u2588\u2584 \u2580\u2588 \u2588 \u2588\u2588\u2588\u2588 \u2588 \u2588 \u2580\u2584 \u2584\u2588 \u2588 \u2580\u2580 \u2580\u2588\u2580\u2588 \u2588\u2584\u2584\u2588\u2580 \u2584\u2588\u2584 \u2588\u2580 \u2588\u2588 \u2584\u2588 \u2580\u2580\u2588\u2584\u2584\u2584 \u2588\u2584 \u2580\u2588\u2588\u2588\u2584 \u2580\u2588 \u2588\u2584 \u2580\u2588 \u2588\u2588\u2588 \u2588 \u2584 \u2588 \u2588\u2588\u2588\u2580 \u2588 \u2584\u2588 \u2584\u2588 \u2580\u2580\u2580 \u2584\u2588\u2588\u2588 \u2588 \u2588 \u2584\u2588\u2588\u2588\u2580\u2580 \u2580\u2588\u2588\u2588 \u2588\u2584\u2588\u2580\u2580\u2588\u2588\u2588\u2588 \u2588 \u2588 \u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588 \u2584\u2588 \u2588\u2588 \u2588\u2588 \u2584\u2588\u2588\u2580\u2580 \u2580\u2588 \u2588\u2588\u2580 \u2588 \u2588 \u2584\u2584\u2584\u2588 \u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2584\u2584\u2588\u2580\u2580\u2580\u2588\u2588\u2580 \u2588\u2580 \u2580\u2580 \u2588 \u2584\u2588\u2580\u2580\u2588\u2584 \u2588 \u2588\u2584 \u2580 \u2588\u2588 \u2588\u2588\u2584\u2588\u2588 \u2588 \u2584\u2584\u2584\u2584\u2584\u2588\u2580\u2588\u2588 \u2588\u2588\u2584\u2584\u2584\u2584\u2584 \u2588 \u2588\u2588\u2584 \u2580\u2588\u2584\u2588 \u2588\u2588\u2580\u2580 \u2580\u2588 \u2580\u2580 \u2588\u2588 \u2588 \u2588\u2580 \u2588 \u2580\u2588\u2580 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2580\u2588\u2588 \u2588 \u2580\u2588\u2588\u2580\u2580 \u2588\u2588 \u2580\u2580 \u2580\u2588\u2588 \u2588\u2588\u2584 \u2580\u2588 \u2588 \u2584\u2588\u2588\u2584 \u2588\u2588\u2588\u2584 \u2584\u2588\u2580 \u2588 \u2588\u2580\u2588\u2588 \u2584\u2588 \u2588 \u2588 \u2588 \u2588 \u2588 \u2580\u2588\u2584 \u2584\u2588\u2588\u2584 \u2588\u2588\u2588\u2584 \u2584\u2588\u2588\u2584 \u2584\u2584\u2588\u2588\u2588\u2584\u2584\u2584\u2584\u2584\u2584\u2588\u2588\u2588\u2580\u2588\u2588\u2588\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2584 \u2588\u2588 \u2588\u2588\u2584 \u2584\u2588\u2580 \u2588\u2584 \u2584\u2588 \u2588\u2588\u2584\u2584\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588 \u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588 \u2580\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2588\u2588\u2584 \u2584\u2588\u2588 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2580 \u2580\u2580\u2580 \u2580\u2580\u2580 \u2580\u2580\u2580\u2580\u2580\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2580\u2580\u2580 \u2580\u2580 / images / bubbleJump . bin | 128 x32 | ( 64 , 16 ) | Saved View : Half | Enc : V | Draw : CLR | \u00ab Save \u00bb | \u00ab Quit \u00bb \u27e8 Clickwheel > \u21ba / \u21bb : move H / V | Click : toggle pixel \u27e9 \u27e8 Probe Buttons > Connect : set | Remove : clear | Switch > Select : H | Measure : V \u27e9 \u27e8 Terminal > [ z ]: set [ x ]: clear [ c ]: toggle pixel | [ m ]: Cycle View | [ / ]: Enc H / V | ctrl + S : Save | ctrl + Q : Quit | [ ? ]: Help \u27e9 Quarter Block view (2\u00d72 compression - each character is 4 pixels): \u2584\u2584\u2584 \u2584\u2584\u2584\u2596 \u2597\u259e\u2580\u2580\u259c\u2596 \u2584\u2584\u2584 \u2597\u2584\u2584\u2596\u2597\u2584\u259e\u2580\u2580\u2599 \u259f\u2580\u259c\u2596 \u2597\u259b\u2598 \u259d\u258c\u2597\u2580 \u259c\u2584\u2598 \u2599 \u259f\u2580\u259c\u2597\u2584\u2596 \u259e\u259c\u2596\u2597\u2584 \u2597\u259b\u259c\u2584\u2580\u2580 \u259d\u2599\u259e\u2580\u2598 \u259a\u2598 \u259d\u2599\u2598 \u2599 \u2597\u2598 \u2590\u258c \u259b \u2584 \u2590 \u2597\u259b \u259b \u259c\u259e \u2588\u2598\u259d\u258c\u2590 \u258c \u259c\u2598 \u2590 \u2597\u2584\u2584 \u259c \u2588 \u259b \u2584\u2588 \u259f\u2599 \u258c \u2590\u2588\u258c \u259f \u2590\u258c \u258c \u2590\u258c \u2590 \u258c\u259f \u258c \u259f\u2588\u258c \u2590 \u2597\u2584\u2584\u2588 \u2588\u2588\u258c \u2590 \u2588 \u258c \u2597\u2588\u259b\u2598\u259c \u2588\u2588\u2584\u259f\u258c \u259d\u2588\u2588\u259b\u2598 \u2588 \u258c \u2590\u2599 \u2590 \u2590\u258c \u258c \u2588\u2580\u2588 \u2590 \u2588\u259b\u2598\u2590\u2596 \u258c \u259c \u2590 \u2590\u259b \u258c \u2590\u2599\u2584\u2584\u2590\u2596 \u259d\u2588\u258c\u2580\u259c \u2580\u2599 \u2590\u258c \u258c \u2590\u2588 \u2590 \u2598 \u258c \u258c \u2590 \u2590 \u2588\u2584\u2584\u2590\u258c \u2590 \u2590 \u2590 \u2590\u258c \u2588 \u259d\u2598 \u259d\u259b\u2599 \u2580\u2599\u259d\u2599\u2596 \u2590\u2596 \u259d\u258c \u258c \u2590\u2588\u258c \u2590 \u258c \u259a \u259f \u2590 \u2580 \u259d\u259b\u258c \u2590\u2584\u259b \u259f\u2596 \u2590\u2598 \u2588 \u2597\u258c\u259d\u259c\u2584\u2596 \u2590\u2596\u259d\u2588\u2599 \u259c \u2599 \u259c \u2588\u258c \u2590 \u2596 \u258c \u2590\u2588\u2598 \u2590 \u2597\u258c\u259f \u259d\u2580 \u2597\u2588\u258c \u2590 \u2590 \u259f\u2588\u2580 \u259c\u2588 \u2599\u259b\u259c\u2588\u258c \u2590 \u2590 \u2590 \u2588\u258c \u2590\u258c \u258c\u2597\u258c \u2588 \u2588 \u2597\u2588\u2580 \u259c \u2588\u2598\u258c \u2590 \u2584\u259f \u2588\u2588\u2580\u2599\u259f\u2580\u259c\u259b \u259b \u2580 \u2590 \u259f\u2580\u2599\u2590 \u2590\u2596 \u259d \u2590\u258c \u2588\u259f\u258c \u2590 \u2584\u2584\u259f\u259c\u258c \u2590\u2599\u2584\u2584\u2590 \u2590\u2599 \u259d\u2599\u258c \u2590\u259b\u2598\u259d\u258c \u259d\u2598 \u2590\u258c \u258c \u259b \u258c \u259d\u259b \u2590\u258c \u2588\u258c \u2590\u259c\u258c \u2590 \u259c\u259b\u2598\u2590\u258c \u2580 \u259d\u2588 \u2588\u2596 \u259d\u258c \u258c \u259f\u2599 \u2590\u2588\u2596 \u259f\u2598 \u258c \u259b\u2588 \u2597\u258c\u258c \u2590 \u258c \u2590 \u2590 \u259d\u2599 \u2597\u2588\u2596 \u2588\u2599 \u2597\u2588\u2596 \u2597\u259f\u2588\u2584\u2584\u2584\u2588\u259b\u2588\u2599\u2584\u2584\u2584\u259b\u259d\u2588\u2588\u2588\u2588\u258c \u2599 \u2590\u258c\u2590\u2599 \u259f\u2598\u2599 \u259f \u2588\u2584\u2588\u2599\u2584\u2588 \u259c\u2599\u2584\u2584\u2588\u2588\u2580\u2588\u2588\u258c\u259c\u2588\u2588\u2580\u2588\u2588\u2588\u2588\u259b\u259d\u2588\u2588\u2588\u2598 \u259d\u259c\u2588\u2588\u259b \u259d\u2580\u2580\u2580 \u2590\u2599 \u2597\u2588 \u259c\u2588\u2588\u259b \u259c\u2588\u259b \u259c\u2588\u2598\u259c\u2588\u2598 \u259d\u2588\u2588\u259b\u2580 \u259d\u2580 \u2580\u2598 \u259d\u2580\u2580\u2598 \u259c\u2588\u2588\u2588\u2598 \u2580\u2580 \u2580 / images / bubbleJump . bin | 128 x32 | ( 64 , 16 ) | Saved View : Qtr | Enc : V | Draw : CLR | \u00ab Save \u00bb | \u00ab Quit \u00bb \u27e8 Clickwheel > \u21ba / \u21bb : move H / V | Click : toggle pixel \u27e9 \u27e8 Probe Buttons > Connect : set | Remove : clear | Switch > Select : H | Measure : V \u27e9 \u27e8 Terminal > [ z ]: set [ x ]: clear [ c ]: toggle pixel | [ m ]: Cycle View | [ / ]: Enc H / V | ctrl + S : Save | ctrl + Q : Quit | [ ? ]: Help \u27e9 The output of ? === Bitmap Editor Help === Navigation : Encoder wheel - Move cursor ( H or V mode ) Arrow keys / WASD - Move cursor j / k / l ( vim ) - Move cursor Down at bottom edge - Enter menu bar Editing : Encoder click - Apply current draw mode at cursor Enter / Space - Apply current draw mode at cursor Connect button HOLD - Set pixels while held ( draw lines ) Remove button HOLD - Clear pixels while held ( erase lines ) Direct Pixel Actions ( keyboard ): z - Set pixel at cursor ( draw ) x - Clear pixel at cursor ( erase ) c - Toggle pixel at cursor Draw Mode Control : . - Cycle draw modes ( Toggle / Set / Clear ) Hardware Controls : Probe switch SELECT - Encoder horizontal movement Probe switch MEASURE - Encoder vertical movement Display : m - Cycle view mode ( Full / Half / Quarter ) / - Toggle encoder H / V movement Menu Bar ( Down at bottom edge ): Left / Right arrows - Navigate menu items Enter / Space - Activate menu item ( cycle / Save / Quit ) Up / Escape - Exit menu bar Menu Bar Items : View - Cycle display mode ( Full / Half / Quarter ) Enc - Toggle encoder direction ( H / V ) Draw - Cycle draw mode ( Toggle / Set / Clear ) \u00ab Save \u00bb - [ Button ] Save file and exit menu \u00ab Quit \u00bb - [ Button ] Quit editor ( prompts if modified ) File : Ctrl + S - Save file Ctrl + Q / ESC - Quit ( prompts if modified ) h / ? - Show this help Cursor Colors : Green background - Pixel is OFF Red background - Pixel is ON","title":"Editor Screenshots"},{"location":"04-oled/#bitmap-file-format","text":"The editor works with . bin files in two formats: With Header (Recommended): - 4 bytes: Width (16-bit little-endian) - 2 bytes: Height (16-bit little-endian) - Remaining: Bitmap data (MSB-first, row-major) - Example: 128\u00d732 = 4 header + 512 data = 516 bytes total Raw Format: - Just bitmap data, dimensions inferred from file size - 512 bytes \u2192 128\u00d732, 1024 bytes \u2192 128\u00d764, etc. The editor automatically adds headers when saving, making files ready to use as startup images.","title":"Bitmap File Format"},{"location":"04-oled/#converting-external-images","text":"Want to use your own images? The JumperlOS repository includes Python scripts to convert PNG/JPG images to OLED bitmaps: Location: JumperlOS / scripts / image_to_oled_bitmap . py Usage: python image_to_oled_bitmap.py input.png output.bin --width 128 --height 32 The script will: Resize your image to fit the OLED dimensions Convert to 1-bit (black/white) format Save with proper header format Output is ready to use as a startup image or edit in the bitmap editor Then you can mount your Jumperless's filesystem as a mass storage device with U and drop it into the / images / folder.","title":"Converting External Images"},{"location":"04-oled/#check-out-the-scripts-folder-in-the-jumperlos-repo-there-are-a-few-other-scripts-related-to-dealing-with-bitmaps","text":"","title":"Check out the /scripts folder in the JumperlOS repo, there are a few other scripts related to dealing with bitmaps."},{"location":"04-oled/#using-the-oled-from-micropython","text":"The OLED display has a comprehensive MicroPython API for programmatic control. You can display text with multiple fonts and sizes, show bitmaps, manipulate pixels directly, and even redirect Python's print () output to the OLED.","title":"Using the OLED from MicroPython"},{"location":"04-oled/#quick-start","text":"import jumperless as j import time # Basic text display j . oled_connect () j . oled_print ( \"Hello!\" , 2 ) time . sleep ( 2 ) j . oled_clear ()","title":"Quick Start"},{"location":"04-oled/#text-sizes-and-scrolling","text":"The OLED supports three text size modes: Size 0 : Small scrolling text - perfect for terminal-like output with multiple lines Size 1 : Normal centered text Size 2 : Large centered text (default) import jumperless as j import time # Set default text size j . oled_set_text_size ( 0 ) # Small scrolling text # Display multiple lines for i in range ( 10 ): j . oled_print ( f \"Line { i + 1 } \" ) time . sleep ( 0.3 ) # Switch to large text j . oled_set_text_size ( 2 ) j . oled_print ( \"BIG TEXT\" )","title":"Text Sizes and Scrolling"},{"location":"04-oled/#print-redirection-for-debugging","text":"One of the most useful features is print redirection - all print () statements can automatically appear on both the serial console and the OLED: import jumperless as j # Enable print copying j . oled_copy_print ( True ) # These appear on both serial AND OLED print ( \"Starting test...\" ) voltage = j . adc_get ( 0 ) print ( f \"Voltage: { voltage : .2f } V\" ) print ( \"Test complete!\" ) # Disable when done j . oled_copy_print ( False ) This is perfect for debugging projects where you don't have easy access to the serial console.","title":"Print Redirection for Debugging"},{"location":"04-oled/#multiple-fonts","text":"Choose from 11 different font families: import jumperless as j # List all available fonts fonts = j . oled_get_fonts () print ( fonts ) # Set a fun font j . oled_set_font ( \"Jokerman\" ) j . oled_print ( \"Fun!\" , 2 ) # Switch to monospace for code j . oled_set_font ( \"Courier New\" ) j . oled_print ( \"Monospace\" , 2 )","title":"Multiple Fonts"},{"location":"04-oled/#display-bitmaps","text":"Show bitmap images stored on the filesystem: import jumperless as j # One-liner to display a bitmap j . oled_show_bitmap_file ( \"/images/jogo32h.bin\" , 0 , 0 ) # Or load and display separately j . oled_load_bitmap ( \"/images/logo.bin\" ) j . oled_display_bitmap ( 0 , 0 , 0 , 0 )","title":"Display Bitmaps"},{"location":"04-oled/#graphics-and-pixel-control","text":"For custom graphics, you can manipulate individual pixels: import jumperless as j # Draw a box j . oled_clear () for x in range ( 20 , 108 ): j . oled_set_pixel ( x , 10 , 1 ) # Top j . oled_set_pixel ( x , 22 , 1 ) # Bottom for y in range ( 10 , 23 ): j . oled_set_pixel ( 20 , y , 1 ) # Left j . oled_set_pixel ( 107 , y , 1 ) # Right j . oled_show ()","title":"Graphics and Pixel Control"},{"location":"04-oled/#advanced-direct-framebuffer-access","text":"For maximum control, you can read and write the entire framebuffer: import jumperless as j # Get display dimensions width , height , size = j . oled_get_framebuffer_size () print ( f \"Display: { width } x { height } , { size } bytes\" ) # Capture the screen fb = j . oled_get_framebuffer () # Save to file with open ( \"/screen_capture.bin\" , \"wb\" ) as f : f . write ( fb ) # Restore later with open ( \"/screen_capture.bin\" , \"rb\" ) as f : fb_data = f . read () j . oled_set_framebuffer ( fb_data )","title":"Advanced: Direct Framebuffer Access"},{"location":"04-oled/#complete-api-reference","text":"For the full API documentation with all functions, parameters, and examples, see: MicroPython API Reference - OLED Display Section The API includes: - Text size control ( oled_set_text_size , oled_get_text_size ) - Print redirection ( oled_copy_print ) - Font system ( oled_get_fonts , oled_set_font , oled_get_current_font ) - Bitmap functions ( oled_load_bitmap , oled_display_bitmap , oled_show_bitmap_file ) - Framebuffer access ( oled_get_framebuffer , oled_set_framebuffer , oled_get_framebuffer_size ) - Pixel manipulation ( oled_set_pixel , oled_get_pixel )","title":"Complete API Reference"},{"location":"04-oled/#example-projects","text":"Animated Sine Wave: import jumperless as j import math import time width , height , _ = j . oled_get_framebuffer_size () for offset in range ( 100 ): j . oled_clear ( False ) # Don't show() after clear to avoid flashing for x in range ( width ): y = int ( height // 2 + 10 * math . sin (( x + offset ) / 10 )) if 0 <= y < height : j . oled_set_pixel ( x , y , 1 ) j . oled_show () time . sleep ( 0.05 ) Sensor Monitor: import jumperless as j import time # Monitor voltage with print redirection j . oled_copy_print ( True ) j . oled_clear () while True : voltage = j . adc_get ( 0 ) current = j . ina_get_current ( 0 ) print ( f \"V: { voltage : .2f } V\" ) print ( f \"I: { current * 1000 : .1f } mA\" ) time . sleep ( 1 )","title":"Example Projects"},{"location":"05-arduino/","text":"Arduino Stuff UART Passthrough With an Arduino Nano in the header and the UART lines connected, anything on those lines should be passed through to the second serial port that shows up when you plug in your Jumperless. (You can also set the config option [ serial_1 ] print_passthrough = true ; and have it print on both. Don't worry about the baud rate, the Jumperless senses what the host computer is set to and changes the speed accordingly. Quick Connection Shortcuts The shortcuts to connect D0 and D1 to the Jumperless's UART Tx and Rx is A to connect, and a to disconnect. Automatic Flashing It will even sense when Arduino IDE is trying to upload code and twiddle the reset lines to allow you to flash code with just a single USB cable going to your Jumperless. Tip: You can also use Wokwi with the Jumperless Bridge app for flashing - no need to even have the Arduino IDE open! Commands from Routable UART You can send commands to the Jumperless from your Arduino (or anything connected to the routable UART) by wrapping them in XML-style tags. The tags are stripped out and the command is executed - the Arduino never sees them come back. Two Types of Tags There are two flavors of command tags, depending on what you want to do: < j > Tags - Raw Commands These run exactly like you typed them in the main Jumperless menu. Use these for things like making connections with f , loading files, or any single-character menu command. < p > Tags - Python Commands These run MicroPython commands directly. Perfect for connect () , disconnect () , adc_get () , dac_set () , and all the other Python hardware functions. The < p > tag automatically prepends the > that normally tells the Jumperless \"this is a Python command.\" Supported Tag Names Any of these work (use matching opening and closing tags): Tag Example < j > < j > f 1 - 30 </ j > < jumperless > < jumperless > x </ jumperless > < jumperlessCommand > < jumperlessCommand > n </ jumperlessCommand > < p > < p > adc_get ( 0 ) </ p > Python Commands with < p > Tags The < p > tag is the most powerful way to control your Jumperless from Arduino code. It gives you direct access to all the MicroPython hardware functions. Basic Example #define OPENJCOMMAND Serial.print(\"<p>\"); #define CLOSEJCOMMAND Serial.println(\"</p>\"); void setup () { Serial . begin ( 115200 ); delay ( 1500 ); // Give Jumperless time to boot } void loop () { // Read voltage on ADC channel 0 OPENJCOMMAND Serial . print ( \"adc_get(0)\" ); CLOSEJCOMMAND delay ( 100 ); // Read the response while ( Serial . available () > 0 ) { char c = Serial . read (); // Process the voltage reading... } } Full Example - ADC Scanning Your browser does not support the video tag. This sketch connects ADC0 to different breadboard rows and reads the voltage at each one: #define OPENJCOMMAND Serial.print(\"<p>\"); #define CLOSEJCOMMAND Serial.println(\"</p>\"); void setup () { pinMode ( LED_BUILTIN , OUTPUT ); Serial . begin ( 115200 ); delay ( 1500 ); } int lastNode = 8 ; int node = 8 ; unsigned long delayTime = 60 ; void loop () { digitalWrite ( LED_BUILTIN , HIGH ); delay ( delayTime ); node ++ ; if ( node > 60 ) { node = 1 ; } // Disconnect from previous node OPENJCOMMAND Serial . print ( \"disconnect( ADC0,\" + String ( lastNode ) + \")\" ); CLOSEJCOMMAND delay ( delayTime ); // Connect to new node OPENJCOMMAND Serial . print ( \"connect(ADC0 ,\" + String ( node ) + \")\" ); CLOSEJCOMMAND delay ( delayTime ); // Read the voltage OPENJCOMMAND Serial . print ( \"adc_get(0)\" ); CLOSEJCOMMAND delay ( delayTime ); // Read response from Jumperless char response [ 30 ] = { 0 }; int idx = 0 ; while ( Serial . available () > 0 && idx < 29 ) { response [ idx ++ ] = Serial . read (); delay ( 5 ); } Serial . println ( response ); Serial . print ( \"num chars read = \" ); Serial . println ( idx ); Serial . flush (); lastNode = node ; digitalWrite ( LED_BUILTIN , LOW ); } Available Python Functions Here are the most useful functions you can call with < p > tags: // Connections \"connect(1, 30)\" // Connect breadboard rows \"connect(D13, TOP_RAIL)\" // Connect Arduino pin to power \"disconnect(ADC0, 15)\" // Remove a connection \"nodes_clear()\" // Clear ALL connections // Analog I/O \"adc_get(0)\" // Read voltage (channels 0-4) \"dac_set(0, 3.3)\" // Set DAC output voltage \"dac_set(TOP_RAIL, 5.0)\" // Set rail voltage // Digital I/O \"gpio_set(1, True)\" // Set GPIO high \"gpio_set(1, False)\" // Set GPIO low \"gpio_get(2)\" // Read GPIO state // Current sensing \"ina_get_current(0)\" // Read current in amps \"ina_get_voltage(0)\" // Read shunt voltage See the MicroPython API Reference for the complete list. Raw Commands with < j > Tags Use < j > tags when you want to send menu commands - the same ones you'd type in the serial terminal. Example - Making Connections #define OPENJCOMMAND Serial.print(\"<j>\"); #define CLOSEJCOMMAND Serial.println(\"</j>\"); void setup () { pinMode ( LED_BUILTIN , OUTPUT ); Serial . begin ( 115200 ); delay ( 1500 ); } int node1 = 1 ; int node2 = 8 ; unsigned long delayTime = 60 ; void loop () { digitalWrite ( LED_BUILTIN , HIGH ); delay ( delayTime ); node1 ++ ; node2 ++ ; if ( node1 > 60 ) node1 = 1 ; if ( node2 > 60 ) node2 = 1 ; // Use the 'f' command to make a connection // Format: f <node1>-<node2> OPENJCOMMAND Serial . print ( \"f \" + String ( node1 ) + \"-\" + String ( node2 ) + \" \\n \" ); CLOSEJCOMMAND delay ( delayTime ); // Read any response char response [ 30 ] = { 0 }; int idx = 0 ; while ( Serial . available () > 0 && idx < 29 ) { response [ idx ++ ] = Serial . read (); delay ( 5 ); } Serial . println ( response ); digitalWrite ( LED_BUILTIN , LOW ); } Useful Raw Commands Command What it does f 1 - 30 Connect nodes 1 and 30 + D13 - GND Add connection (alternate syntax) - 1 - 30 Remove connection x Clear all connections n Show net list s Save current state Tips and Gotchas Timing The Jumperless needs a little time to process each command. A delay of 40-100ms between commands is usually safe. If you're seeing weird behavior, try increasing the delay. Response Reading Commands often return data (like adc_get () returning a voltage). Make sure to read the Serial buffer after sending commands, or it'll fill up and cause issues. Startup Delay Add a delay ( 1500 ) in your setup () to give the Jumperless time to fully boot before sending commands. Flashing Your Arduino Just use the Arduino IDE normally - select the second serial port that shows up (the one labeled with \"port3\" or similar), and upload. The Jumperless automatically handles the reset timing. Which Tag to Use? Use < p > for anything that's a Python function: connect () , adc_get () , dac_set () , etc. Use < j > for menu commands: f , x , n , s , etc. Wokwi Integration If you're using the Jumperless Wokwi Bridge , you can flash your Arduino directly from Wokwi simulations - the bridge handles all the communication for you.","title":"Arduino Stuff"},{"location":"05-arduino/#arduino-stuff","text":"","title":"Arduino Stuff"},{"location":"05-arduino/#uart-passthrough","text":"With an Arduino Nano in the header and the UART lines connected, anything on those lines should be passed through to the second serial port that shows up when you plug in your Jumperless. (You can also set the config option [ serial_1 ] print_passthrough = true ; and have it print on both. Don't worry about the baud rate, the Jumperless senses what the host computer is set to and changes the speed accordingly.","title":"UART Passthrough"},{"location":"05-arduino/#quick-connection-shortcuts","text":"The shortcuts to connect D0 and D1 to the Jumperless's UART Tx and Rx is A to connect, and a to disconnect.","title":"Quick Connection Shortcuts"},{"location":"05-arduino/#automatic-flashing","text":"It will even sense when Arduino IDE is trying to upload code and twiddle the reset lines to allow you to flash code with just a single USB cable going to your Jumperless. Tip: You can also use Wokwi with the Jumperless Bridge app for flashing - no need to even have the Arduino IDE open!","title":"Automatic Flashing"},{"location":"05-arduino/#commands-from-routable-uart","text":"You can send commands to the Jumperless from your Arduino (or anything connected to the routable UART) by wrapping them in XML-style tags. The tags are stripped out and the command is executed - the Arduino never sees them come back.","title":"Commands from Routable UART"},{"location":"05-arduino/#two-types-of-tags","text":"There are two flavors of command tags, depending on what you want to do:","title":"Two Types of Tags"},{"location":"05-arduino/#j-tags-raw-commands","text":"These run exactly like you typed them in the main Jumperless menu. Use these for things like making connections with f , loading files, or any single-character menu command.","title":"&lt;j&gt; Tags - Raw Commands"},{"location":"05-arduino/#p-tags-python-commands","text":"These run MicroPython commands directly. Perfect for connect () , disconnect () , adc_get () , dac_set () , and all the other Python hardware functions. The < p > tag automatically prepends the > that normally tells the Jumperless \"this is a Python command.\"","title":"&lt;p&gt; Tags - Python Commands"},{"location":"05-arduino/#supported-tag-names","text":"Any of these work (use matching opening and closing tags): Tag Example < j > < j > f 1 - 30 </ j > < jumperless > < jumperless > x </ jumperless > < jumperlessCommand > < jumperlessCommand > n </ jumperlessCommand > < p > < p > adc_get ( 0 ) </ p >","title":"Supported Tag Names"},{"location":"05-arduino/#python-commands-with-p-tags","text":"The < p > tag is the most powerful way to control your Jumperless from Arduino code. It gives you direct access to all the MicroPython hardware functions.","title":"Python Commands with &lt;p&gt; Tags"},{"location":"05-arduino/#basic-example","text":"#define OPENJCOMMAND Serial.print(\"<p>\"); #define CLOSEJCOMMAND Serial.println(\"</p>\"); void setup () { Serial . begin ( 115200 ); delay ( 1500 ); // Give Jumperless time to boot } void loop () { // Read voltage on ADC channel 0 OPENJCOMMAND Serial . print ( \"adc_get(0)\" ); CLOSEJCOMMAND delay ( 100 ); // Read the response while ( Serial . available () > 0 ) { char c = Serial . read (); // Process the voltage reading... } }","title":"Basic Example"},{"location":"05-arduino/#full-example-adc-scanning","text":"Your browser does not support the video tag. This sketch connects ADC0 to different breadboard rows and reads the voltage at each one: #define OPENJCOMMAND Serial.print(\"<p>\"); #define CLOSEJCOMMAND Serial.println(\"</p>\"); void setup () { pinMode ( LED_BUILTIN , OUTPUT ); Serial . begin ( 115200 ); delay ( 1500 ); } int lastNode = 8 ; int node = 8 ; unsigned long delayTime = 60 ; void loop () { digitalWrite ( LED_BUILTIN , HIGH ); delay ( delayTime ); node ++ ; if ( node > 60 ) { node = 1 ; } // Disconnect from previous node OPENJCOMMAND Serial . print ( \"disconnect( ADC0,\" + String ( lastNode ) + \")\" ); CLOSEJCOMMAND delay ( delayTime ); // Connect to new node OPENJCOMMAND Serial . print ( \"connect(ADC0 ,\" + String ( node ) + \")\" ); CLOSEJCOMMAND delay ( delayTime ); // Read the voltage OPENJCOMMAND Serial . print ( \"adc_get(0)\" ); CLOSEJCOMMAND delay ( delayTime ); // Read response from Jumperless char response [ 30 ] = { 0 }; int idx = 0 ; while ( Serial . available () > 0 && idx < 29 ) { response [ idx ++ ] = Serial . read (); delay ( 5 ); } Serial . println ( response ); Serial . print ( \"num chars read = \" ); Serial . println ( idx ); Serial . flush (); lastNode = node ; digitalWrite ( LED_BUILTIN , LOW ); }","title":"Full Example - ADC Scanning"},{"location":"05-arduino/#available-python-functions","text":"Here are the most useful functions you can call with < p > tags: // Connections \"connect(1, 30)\" // Connect breadboard rows \"connect(D13, TOP_RAIL)\" // Connect Arduino pin to power \"disconnect(ADC0, 15)\" // Remove a connection \"nodes_clear()\" // Clear ALL connections // Analog I/O \"adc_get(0)\" // Read voltage (channels 0-4) \"dac_set(0, 3.3)\" // Set DAC output voltage \"dac_set(TOP_RAIL, 5.0)\" // Set rail voltage // Digital I/O \"gpio_set(1, True)\" // Set GPIO high \"gpio_set(1, False)\" // Set GPIO low \"gpio_get(2)\" // Read GPIO state // Current sensing \"ina_get_current(0)\" // Read current in amps \"ina_get_voltage(0)\" // Read shunt voltage See the MicroPython API Reference for the complete list.","title":"Available Python Functions"},{"location":"05-arduino/#raw-commands-with-j-tags","text":"Use < j > tags when you want to send menu commands - the same ones you'd type in the serial terminal.","title":"Raw Commands with &lt;j&gt; Tags"},{"location":"05-arduino/#example-making-connections","text":"#define OPENJCOMMAND Serial.print(\"<j>\"); #define CLOSEJCOMMAND Serial.println(\"</j>\"); void setup () { pinMode ( LED_BUILTIN , OUTPUT ); Serial . begin ( 115200 ); delay ( 1500 ); } int node1 = 1 ; int node2 = 8 ; unsigned long delayTime = 60 ; void loop () { digitalWrite ( LED_BUILTIN , HIGH ); delay ( delayTime ); node1 ++ ; node2 ++ ; if ( node1 > 60 ) node1 = 1 ; if ( node2 > 60 ) node2 = 1 ; // Use the 'f' command to make a connection // Format: f <node1>-<node2> OPENJCOMMAND Serial . print ( \"f \" + String ( node1 ) + \"-\" + String ( node2 ) + \" \\n \" ); CLOSEJCOMMAND delay ( delayTime ); // Read any response char response [ 30 ] = { 0 }; int idx = 0 ; while ( Serial . available () > 0 && idx < 29 ) { response [ idx ++ ] = Serial . read (); delay ( 5 ); } Serial . println ( response ); digitalWrite ( LED_BUILTIN , LOW ); }","title":"Example - Making Connections"},{"location":"05-arduino/#useful-raw-commands","text":"Command What it does f 1 - 30 Connect nodes 1 and 30 + D13 - GND Add connection (alternate syntax) - 1 - 30 Remove connection x Clear all connections n Show net list s Save current state","title":"Useful Raw Commands"},{"location":"05-arduino/#tips-and-gotchas","text":"","title":"Tips and Gotchas"},{"location":"05-arduino/#timing","text":"The Jumperless needs a little time to process each command. A delay of 40-100ms between commands is usually safe. If you're seeing weird behavior, try increasing the delay.","title":"Timing"},{"location":"05-arduino/#response-reading","text":"Commands often return data (like adc_get () returning a voltage). Make sure to read the Serial buffer after sending commands, or it'll fill up and cause issues.","title":"Response Reading"},{"location":"05-arduino/#startup-delay","text":"Add a delay ( 1500 ) in your setup () to give the Jumperless time to fully boot before sending commands.","title":"Startup Delay"},{"location":"05-arduino/#flashing-your-arduino","text":"Just use the Arduino IDE normally - select the second serial port that shows up (the one labeled with \"port3\" or similar), and upload. The Jumperless automatically handles the reset timing.","title":"Flashing Your Arduino"},{"location":"05-arduino/#which-tag-to-use","text":"Use < p > for anything that's a Python function: connect () , adc_get () , dac_set () , etc. Use < j > for menu commands: f , x , n , s , etc.","title":"Which Tag to Use?"},{"location":"05-arduino/#wokwi-integration","text":"If you're using the Jumperless Wokwi Bridge , you can flash your Arduino directly from Wokwi simulations - the bridge handles all the communication for you.","title":"Wokwi Integration"},{"location":"06-config/","text":"Config File To change any persistent settings that apply to the Jumperless as a whole, there's a config file. You can read it with ~ and edit settings by copying any of those lines, pasting it back, and changing the value to whatever you want it to be. Viewing Config.txt You can enter ~ to print the config. ~ copy / edit / paste any of these lines into the main menu to change a setting Jumperless Config : ` [ config ] firmware_version = 5.6.0.0 ; ` [ hardware ] generation = 5 ; ` [ hardware ] revision = 5 ; ` [ hardware ] probe_revision = 5 ; ` [ dacs ] set_dacs_on_boot = false ; ` [ dacs ] set_rails_on_boot = true ; ` [ dacs ] probe_power_dac = 0 ; ` [ dacs ] limit_max = 8.00 ; ` [ dacs ] limit_min = - 8.00 ; ` [ debug ] file_parsing = false ; ` [ debug ] net_manager = false ; ` [ debug ] nets_to_chips = false ; ` [ debug ] nets_to_chips_alt = false ; ` [ debug ] leds = false ; ` [ debug ] logic_analyzer = true ; ` [ debug ] arduino = 0 ; ` [ routing ] stack_paths = 2 ; ` [ routing ] stack_rails = 3 ; ` [ routing ] stack_dacs = 0 ; ` [ routing ] rail_priority = 1 ; ` [ calibration ] top_rail_zero = 1626 ; ` [ calibration ] top_rail_spread = 19.83 ; ` [ calibration ] bottom_rail_zero = 1638 ; ` [ calibration ] bottom_rail_spread = 19.64 ; ` [ calibration ] dac_0_zero = 1629 ; ` [ calibration ] dac_0_spread = 19.90 ; ` [ calibration ] dac_1_zero = 1629 ; ` [ calibration ] dac_1_spread = 19.53 ; ` [ calibration ] adc_0_zero = 8.98 ; ` [ calibration ] adc_0_spread = 18.08 ; ` [ calibration ] adc_1_zero = 9.01 ; ` [ calibration ] adc_1_spread = 18.15 ; ` [ calibration ] adc_2_zero = 8.98 ; ` [ calibration ] adc_2_spread = 18.06 ; ` [ calibration ] adc_3_zero = 8.96 ; ` [ calibration ] adc_3_spread = 18.05 ; ` [ calibration ] adc_4_zero = 0.00 ; ` [ calibration ] adc_4_spread = 4.92 ; ` [ calibration ] adc_7_zero = 10.52 ; ` [ calibration ] adc_7_spread = 20.66 ; ` [ calibration ] probe_max = 4040 ; ` [ calibration ] probe_min = 11 ; ` [ calibration ] probe_switch_threshold_high = 0.35 ; ` [ calibration ] probe_switch_threshold_low = 0.10 ; ` [ calibration ] probe_switch_threshold = 0.40 ; ` [ calibration ] measure_mode_output_voltage = 3.30 ; ` [ calibration ] probe_current_zero = 2.72 ; ` [ logo_pads ] top_guy = uart_tx ; ` [ logo_pads ] bottom_guy = uart_rx ; ` [ logo_pads ] building_pad_top = isense_pos ; ` [ logo_pads ] building_pad_bottom = isense - ; ` [ display ] lines_wires = wires ; ` [ display ] menu_brightness = - 10 ; ` [ display ] led_brightness = 10 ; ` [ display ] rail_brightness = 55 ; ` [ display ] special_net_brightness = 20 ; ` [ display ] net_color_mode = rainbow ; ` [ display ] dump_leds = ; ` [ display ] dump_format = image ; ` [ display ] terminal_line_buffering = 0 ; ` [ serial_1 ] function = passthrough ; ` [ serial_1 ] baud_rate = 115200 ; ` [ serial_1 ] print_passthrough = false ; ` [ serial_1 ] connect_on_boot = false ; ` [ serial_1 ] lock_connection = false ; ` [ serial_1 ] autoconnect_flashing = true ; ` [ serial_1 ] async_passthrough = true ; ` [ top_oled ] enabled = true ; ` [ top_oled ] i2c_address = 0x3C ; ` [ top_oled ] width = 128 ; ` [ top_oled ] height = 32 ; ` [ top_oled ] connection_type = rp6_rp7 ; ` [ top_oled ] sda_pin = 6 ; ` [ top_oled ] scl_pin = 7 ; ` [ top_oled ] gpio_sda = GP_6 ; ` [ top_oled ] gpio_scl = GP_7 ; ` [ top_oled ] sda_row = - 1 ; ` [ top_oled ] scl_row = - 1 ; ` [ top_oled ] connect_on_boot = false ; ` [ top_oled ] lock_connection = false ; ` [ top_oled ] show_in_terminal = false ; ` [ top_oled ] font = Eurostl ; ` [ top_oled ] startup_message = images / bubbleJumpThin . bin This is just a file on your filesystem called config . txt and just editing that file directly works too. Config Help There's also a help you can get to by entering ~ ? ~? Help for command : ~ Read config ~ = show current config ~ names = show names for settings ~ numbers = show numbers for settings ~ [ section ] = show specific section ( e . g . ~ [ routing ]) Write config ` [ section ] setting = value ; = enter config settings ( pro tip : copy / paste setting from ~ output and just change the value ) Reset config ` reset = reset to defaults ( keeps calibration and hardware version ) ` reset_hardware = reset hardware settings ( keeps calibration ) ` reset_calibration = reset calibration settings ( keeps hardware version ) ` reset_all = reset to defaults and clear all settings ` force_first_start = clears everything to factory settings and runs first startup calibration Help ~? = show this help State File States vs Config States are now saved as YAML and we did away with the old text file format. globalState holds all connections, paths, and other circuit configuration in a single object that most of the code uses now. State vs Config - What's the Difference? State stores things relevant to the currently loaded slot - connections, wire colors, rail voltages, GPIO settings. These change when you switch slots. Config (config.txt) contains hardware-wide settings that apply to the entire Jumperless regardless of which slot is active. Rail voltages, GPIO settings, and other circuit-specific parameters now go with the state (in the YAML file) rather than config, so each slot can have its own power supply and GPIO configuration. State File Structure For things specific to the current state of the Jumperless, there's a YAML file that contains all the connections, colors (optional), rail / DAC voltages, GPIO directions and pulls, stuff like that. The idea is this defines a complete setup of a particular circuit that can be switched between in different slots . The Jumperless always boots at Slot 0 , and you can switch to other slots with < (cycle through them) or selecting one with the click menu with Slots > Load > 0 - 7 (it will show a preview of each one.) To save a copy of the currently active slot ; Slots > Save > 0 - 7 will save a copy of the active slot to another slot and also make that target slot the active . \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Current YAML State ( RAM ) \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Active Slot : 0 Dirty Flag : NO ( saved ) \u2500\u2500\u2500 YAML Output \u2500\u2500\u2500 version : 2 sourceOfTruth : bridges bridges : - { n1 : 38 , n2 : 44 , dup : 2 } - { n1 : 21 , n2 : 28 , dup : 2 } - { n1 : 48 , n2 : 55 , dup : 2 } - { n1 : 4 , n2 : 2 , dup : 2 } - { n1 : BUFFER_IN , n2 : DAC0 , dup : 1 } nets : - { num : 4 , nodes : [ DAC_0 , BUF_IN ], name : \"DAC 0\" , anim : true } - { num : 6 , nodes : [ 38 , 44 ], color : pink } - { num : 7 , nodes : [ 21 , 28 ], color : blue } - { num : 8 , nodes : [ 48 , 55 ], color : green } - { num : 9 , nodes : [ 4 , 2 ], color : amber } power : topRail : 3.30 bottomRail : 2.50 dac0 : 3.30 dac1 : 0.00 config : routing : { stackPaths : 2 , stackRails : 3 , stackDacs : 0 , railPriority : 1 } gpio : direction : [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] pulls : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] pwmFrequency : [ 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 ] pwmDutyCycle : [ 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 ] pwmEnabled : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] uart : { txFunction : 0 , rxFunction : 1 } oled : { connected : false , lockConnection : false } \u2500\u2500\u2500 Memory Usage \u2500\u2500\u2500 Connections : 5 State RAM : ~ 58048 bytes Source of Truth Because the information in here is sort of redundant (the connections could be computed from just the bridges or the nets section on their own), there's a field called sourceOfTruth which is the section that actually gets parsed and then the other section is written with the computed values. (I haven't done much testing on changing this to nets so I'd probably just leave it on bridges for now.) There's some weirdness with how colors are applied, since the source of truth is the bridges, and the things that actually get colored are the nets , it'll take the colors from the bridges (if specified) and try to apply them to the nets . But since nets always have a single color (to show that they're connected), if you have bridges with different colors in the same net , it'll just pick one (don't ask me exactly how the logic chooses, idk.) If you specify a color to a net even with sourceOfTruth : bridges it should respect the net assignment over the bridge assignment. Switching Between Saved Circuits (Slots) The Jumperless has 8 slots (0-7) where you can save different circuit configurations. Think of them like presets or save files. Quick slot cycling: - Type < in the terminal to cycle to the next slot Other slot commands: - l 5 - Load slot 5 specifically - Q - Query which slot is currently active - s - Show a list of all saved slots When you make connections with the probe, they're automatically saved to whichever slot is currently active. See the Glossary for more details about slots. Live Editing State Files You can edit the YAML slot files and they will live update to the board! Whether you're editing them in the onboard eKilo editor or as a mounted USB MSC device on your computer, changes will be reflected immediately on your Jumperless.","title":"Config File"},{"location":"06-config/#config-file","text":"To change any persistent settings that apply to the Jumperless as a whole, there's a config file. You can read it with ~ and edit settings by copying any of those lines, pasting it back, and changing the value to whatever you want it to be.","title":"Config File"},{"location":"06-config/#viewing-configtxt","text":"You can enter ~ to print the config. ~ copy / edit / paste any of these lines into the main menu to change a setting Jumperless Config : ` [ config ] firmware_version = 5.6.0.0 ; ` [ hardware ] generation = 5 ; ` [ hardware ] revision = 5 ; ` [ hardware ] probe_revision = 5 ; ` [ dacs ] set_dacs_on_boot = false ; ` [ dacs ] set_rails_on_boot = true ; ` [ dacs ] probe_power_dac = 0 ; ` [ dacs ] limit_max = 8.00 ; ` [ dacs ] limit_min = - 8.00 ; ` [ debug ] file_parsing = false ; ` [ debug ] net_manager = false ; ` [ debug ] nets_to_chips = false ; ` [ debug ] nets_to_chips_alt = false ; ` [ debug ] leds = false ; ` [ debug ] logic_analyzer = true ; ` [ debug ] arduino = 0 ; ` [ routing ] stack_paths = 2 ; ` [ routing ] stack_rails = 3 ; ` [ routing ] stack_dacs = 0 ; ` [ routing ] rail_priority = 1 ; ` [ calibration ] top_rail_zero = 1626 ; ` [ calibration ] top_rail_spread = 19.83 ; ` [ calibration ] bottom_rail_zero = 1638 ; ` [ calibration ] bottom_rail_spread = 19.64 ; ` [ calibration ] dac_0_zero = 1629 ; ` [ calibration ] dac_0_spread = 19.90 ; ` [ calibration ] dac_1_zero = 1629 ; ` [ calibration ] dac_1_spread = 19.53 ; ` [ calibration ] adc_0_zero = 8.98 ; ` [ calibration ] adc_0_spread = 18.08 ; ` [ calibration ] adc_1_zero = 9.01 ; ` [ calibration ] adc_1_spread = 18.15 ; ` [ calibration ] adc_2_zero = 8.98 ; ` [ calibration ] adc_2_spread = 18.06 ; ` [ calibration ] adc_3_zero = 8.96 ; ` [ calibration ] adc_3_spread = 18.05 ; ` [ calibration ] adc_4_zero = 0.00 ; ` [ calibration ] adc_4_spread = 4.92 ; ` [ calibration ] adc_7_zero = 10.52 ; ` [ calibration ] adc_7_spread = 20.66 ; ` [ calibration ] probe_max = 4040 ; ` [ calibration ] probe_min = 11 ; ` [ calibration ] probe_switch_threshold_high = 0.35 ; ` [ calibration ] probe_switch_threshold_low = 0.10 ; ` [ calibration ] probe_switch_threshold = 0.40 ; ` [ calibration ] measure_mode_output_voltage = 3.30 ; ` [ calibration ] probe_current_zero = 2.72 ; ` [ logo_pads ] top_guy = uart_tx ; ` [ logo_pads ] bottom_guy = uart_rx ; ` [ logo_pads ] building_pad_top = isense_pos ; ` [ logo_pads ] building_pad_bottom = isense - ; ` [ display ] lines_wires = wires ; ` [ display ] menu_brightness = - 10 ; ` [ display ] led_brightness = 10 ; ` [ display ] rail_brightness = 55 ; ` [ display ] special_net_brightness = 20 ; ` [ display ] net_color_mode = rainbow ; ` [ display ] dump_leds = ; ` [ display ] dump_format = image ; ` [ display ] terminal_line_buffering = 0 ; ` [ serial_1 ] function = passthrough ; ` [ serial_1 ] baud_rate = 115200 ; ` [ serial_1 ] print_passthrough = false ; ` [ serial_1 ] connect_on_boot = false ; ` [ serial_1 ] lock_connection = false ; ` [ serial_1 ] autoconnect_flashing = true ; ` [ serial_1 ] async_passthrough = true ; ` [ top_oled ] enabled = true ; ` [ top_oled ] i2c_address = 0x3C ; ` [ top_oled ] width = 128 ; ` [ top_oled ] height = 32 ; ` [ top_oled ] connection_type = rp6_rp7 ; ` [ top_oled ] sda_pin = 6 ; ` [ top_oled ] scl_pin = 7 ; ` [ top_oled ] gpio_sda = GP_6 ; ` [ top_oled ] gpio_scl = GP_7 ; ` [ top_oled ] sda_row = - 1 ; ` [ top_oled ] scl_row = - 1 ; ` [ top_oled ] connect_on_boot = false ; ` [ top_oled ] lock_connection = false ; ` [ top_oled ] show_in_terminal = false ; ` [ top_oled ] font = Eurostl ; ` [ top_oled ] startup_message = images / bubbleJumpThin . bin This is just a file on your filesystem called config . txt and just editing that file directly works too.","title":"Viewing Config.txt"},{"location":"06-config/#config-help","text":"There's also a help you can get to by entering ~ ? ~? Help for command : ~ Read config ~ = show current config ~ names = show names for settings ~ numbers = show numbers for settings ~ [ section ] = show specific section ( e . g . ~ [ routing ]) Write config ` [ section ] setting = value ; = enter config settings ( pro tip : copy / paste setting from ~ output and just change the value ) Reset config ` reset = reset to defaults ( keeps calibration and hardware version ) ` reset_hardware = reset hardware settings ( keeps calibration ) ` reset_calibration = reset calibration settings ( keeps hardware version ) ` reset_all = reset to defaults and clear all settings ` force_first_start = clears everything to factory settings and runs first startup calibration Help ~? = show this help","title":"Config Help"},{"location":"06-config/#state-file","text":"","title":"State File"},{"location":"06-config/#states-vs-config","text":"States are now saved as YAML and we did away with the old text file format. globalState holds all connections, paths, and other circuit configuration in a single object that most of the code uses now. State vs Config - What's the Difference? State stores things relevant to the currently loaded slot - connections, wire colors, rail voltages, GPIO settings. These change when you switch slots. Config (config.txt) contains hardware-wide settings that apply to the entire Jumperless regardless of which slot is active. Rail voltages, GPIO settings, and other circuit-specific parameters now go with the state (in the YAML file) rather than config, so each slot can have its own power supply and GPIO configuration.","title":"States vs Config"},{"location":"06-config/#state-file-structure","text":"For things specific to the current state of the Jumperless, there's a YAML file that contains all the connections, colors (optional), rail / DAC voltages, GPIO directions and pulls, stuff like that. The idea is this defines a complete setup of a particular circuit that can be switched between in different slots . The Jumperless always boots at Slot 0 , and you can switch to other slots with < (cycle through them) or selecting one with the click menu with Slots > Load > 0 - 7 (it will show a preview of each one.) To save a copy of the currently active slot ; Slots > Save > 0 - 7 will save a copy of the active slot to another slot and also make that target slot the active . \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Current YAML State ( RAM ) \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Active Slot : 0 Dirty Flag : NO ( saved ) \u2500\u2500\u2500 YAML Output \u2500\u2500\u2500 version : 2 sourceOfTruth : bridges bridges : - { n1 : 38 , n2 : 44 , dup : 2 } - { n1 : 21 , n2 : 28 , dup : 2 } - { n1 : 48 , n2 : 55 , dup : 2 } - { n1 : 4 , n2 : 2 , dup : 2 } - { n1 : BUFFER_IN , n2 : DAC0 , dup : 1 } nets : - { num : 4 , nodes : [ DAC_0 , BUF_IN ], name : \"DAC 0\" , anim : true } - { num : 6 , nodes : [ 38 , 44 ], color : pink } - { num : 7 , nodes : [ 21 , 28 ], color : blue } - { num : 8 , nodes : [ 48 , 55 ], color : green } - { num : 9 , nodes : [ 4 , 2 ], color : amber } power : topRail : 3.30 bottomRail : 2.50 dac0 : 3.30 dac1 : 0.00 config : routing : { stackPaths : 2 , stackRails : 3 , stackDacs : 0 , railPriority : 1 } gpio : direction : [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] pulls : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] pwmFrequency : [ 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 ] pwmDutyCycle : [ 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 , 0.50 ] pwmEnabled : [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] uart : { txFunction : 0 , rxFunction : 1 } oled : { connected : false , lockConnection : false } \u2500\u2500\u2500 Memory Usage \u2500\u2500\u2500 Connections : 5 State RAM : ~ 58048 bytes","title":"State File Structure"},{"location":"06-config/#source-of-truth","text":"Because the information in here is sort of redundant (the connections could be computed from just the bridges or the nets section on their own), there's a field called sourceOfTruth which is the section that actually gets parsed and then the other section is written with the computed values. (I haven't done much testing on changing this to nets so I'd probably just leave it on bridges for now.) There's some weirdness with how colors are applied, since the source of truth is the bridges, and the things that actually get colored are the nets , it'll take the colors from the bridges (if specified) and try to apply them to the nets . But since nets always have a single color (to show that they're connected), if you have bridges with different colors in the same net , it'll just pick one (don't ask me exactly how the logic chooses, idk.) If you specify a color to a net even with sourceOfTruth : bridges it should respect the net assignment over the bridge assignment.","title":"Source of Truth"},{"location":"06-config/#switching-between-saved-circuits-slots","text":"The Jumperless has 8 slots (0-7) where you can save different circuit configurations. Think of them like presets or save files. Quick slot cycling: - Type < in the terminal to cycle to the next slot Other slot commands: - l 5 - Load slot 5 specifically - Q - Query which slot is currently active - s - Show a list of all saved slots When you make connections with the probe, they're automatically saved to whichever slot is currently active. See the Glossary for more details about slots.","title":"Switching Between Saved Circuits (Slots)"},{"location":"06-config/#live-editing-state-files","text":"You can edit the YAML slot files and they will live update to the board! Whether you're editing them in the onboard eKilo editor or as a mounted USB MSC device on your computer, changes will be reflected immediately on your Jumperless.","title":"Live Editing State Files"},{"location":"07-debugging/","text":"Debug Views Look Inside your Jumperless Crossbar Array There's a new way to see what the 12 analog crossbar switches are up to, just enter C in the menu Lowercase c will show a compact version You can also set it to live updating mode with c ! Your browser does not support the video tag. Bridge Array Enter b in the menu. This is generally the most helpful one for me to troubleshoot what's going on if your issue has anything to do with routing or connections. It probably looks like nonsense to you but I've been in it so long it makes perfect sense to me. Net List Enter n in the menu to show this one. If you have anything that's doing any measurement ( gpio input or ADC s), it'll stay up and live update if any of them change. (And just like basically any menu not asking for input, entering anything will bring you back to the main menu.)","title":"Debug Views"},{"location":"07-debugging/#debug-views","text":"Look Inside your Jumperless","title":"Debug Views"},{"location":"07-debugging/#crossbar-array","text":"There's a new way to see what the 12 analog crossbar switches are up to, just enter C in the menu Lowercase c will show a compact version You can also set it to live updating mode with c ! Your browser does not support the video tag.","title":"Crossbar Array"},{"location":"07-debugging/#bridge-array","text":"Enter b in the menu. This is generally the most helpful one for me to troubleshoot what's going on if your issue has anything to do with routing or connections. It probably looks like nonsense to you but I've been in it so long it makes perfect sense to me.","title":"Bridge Array"},{"location":"07-debugging/#net-list","text":"Enter n in the menu to show this one. If you have anything that's doing any measurement ( gpio input or ADC s), it'll stay up and live update if any of them change. (And just like basically any menu not asking for input, entering anything will bring you back to the main menu.)","title":"Net List"},{"location":"08-file-manager/","text":"File Manager The Jumperless has a built in File Manager which you can access in the menu with / , or enter U in the menu and Jumperless will mount as a USB Mass Storage drive called JUMPERLESS where you can edit files on the filesystem. File System Structure \u251c\u2500\u2500 config . txt \u2502 \u251c\u2500\u2500 slots / \u2502 \u251c\u2500\u2500 slot0 . yaml \u2502 \u251c\u2500\u2500 slot1 . yaml \u2502 \u251c\u2500\u2500 slot2 . yaml \u2502 \u2514\u2500\u2500 ... ( up to slot7 . yaml ) \u2502 \u2514\u2500\u2500 python_scripts / \u251c\u2500\u2500 history . txt \u251c\u2500\u2500 cool_micropython_script . py \u251c\u2500\u2500 ... ( your python scripts go here ) \u2502 \u2514\u2500\u2500 examples / \u251c\u2500\u2500 adc_basics . py \u251c\u2500\u2500 dac_basics . py \u251c\u2500\u2500 gpio_basics . py \u251c\u2500\u2500 led_brightness_control . py \u251c\u2500\u2500 node_connections . py \u251c\u2500\u2500 stylophone . py \u251c\u2500\u2500 uart_basics . py \u251c\u2500\u2500 uart_loopback . py \u2514\u2500\u2500 voltage_monitor . py Each slot's configuration is stored as a YAML file in the / slots / directory, and the global hardware configuration is in / config . txt . Navigation Basic Movement Control Action \u2191/\u2193 Arrow Keys or Rotary Encoder Move selection up/down Enter or Click Encoder Open directory or edit file / Go to root directory . Go up one directory CTRL + q Quit File Manager or Text Editor File Manager Commands Key Action Description [enter] Open Open file or enter directory h Help Show help v Quick view View file contents . Up dir Go up one directory n New file Create new file (prompts for filename) d New directory Create new directory x Delete Delete file or directory (confirm with y / N ) File Type Icons and Colors Icon File Type Extensions Color \u2318 Directories - Blue \ud80c\udd9a Python files .py, .pyw, .pyi Green \u237a Text files .txt, .md White \u2699 Config files .cfg, .conf, config.txt Yellow \u27d0 JSON/YAML files .json, .yaml Cyan \u260a Slot files /slots/slot*.yaml Magenta \u2383 Legacy slot files nodeFileSlot*.txt Orange Jumperless eKilo Text Editor The File Manager also has text editor based off eKilo Editor Controls Ctrl+S : Save file Ctrl+Q : Quit editor Ctrl+P : Save and launch MicroPython REPL Arrow keys : Navigate cursor Rotary encoder : Move cursor horizontally Click encoder : Enter character selection mode (you can scroll through the letters on the OLED and click again to insert it) Character Selection With the Click Wheel and OLED When using the rotary encoder in the editor: Click encoder : Enter character selection mode Rotate encoder : Cycle through available characters Click encoder : Confirm character selection Wait 3 seconds : Exit character selection mode Yes, you could write code with just the click wheel and the OLED if you really wanted to. OLED Display Support If you have an OLED connected, the File Manager shows: - Current path and selected file - File navigation with scrolling support - Real-time updates as you navigate MicroPython Examples The File Manager automatically creates example Python scripts in / python_scripts / examples / : Basic Hardware Examples adc_basics.py : Basic ADC (Analog-to-Digital Converter) operations. This example shows how to read analog voltages from all ADC channels (0-3). Connect voltage sources to ADC inputs and monitor readings in real-time. dac_basics.py : Basic DAC (Digital-to-Analog Converter) operations. Shows how to set DAC voltages on all channels (DAC_A, DAC_B, TOP_RAIL, BOTTOM_RAIL). Hardware setup: Connect voltmeter or LED to DAC output pins. gpio_basics.py : Basic GPIO (General Purpose Input/Output) operations. This example demonstrates digital I/O, direction control, and pull resistors. Tests input mode with pull-up, pull-down, and floating configurations. node_connections.py : Node connection and routing operations. This example shows how to connect/disconnect nodes, check connections, and clear all connections. Demonstrates working with breadboard nodes, DAC outputs, and GPIO pins. uart_loopback.py : UART Loopback Demo. Demonstrates UART communication by looping back data from UART_TX to UART_RX. Open a serial monitor on the Jumperless's second port at 115200 baud to see the looped messages. Interactive Examples interaction_demo.py : Interactive Demo - Control connections with probe, encoder, and buttons. This example shows how to use all the interactive controls together. No special hardware needed - use the probe to tap nodes, the encoder to adjust bridge spread, and buttons to change colors. led_brightness_control.py : LED Brightness Control Demo. Tap breadboard pads 1-60 to control the voltage on an LED and display the current draw. Hardware setup: Connect LED anode to breadboard row 15, connect LED cathode to GND. Displays voltage and current on OLED. stylophone.py : Jumperless Stylophone. Musical instrument using probe and GPIO to generate audio tones. Hardware setup: Connect speaker between rows 25 (positive) and 55 (negative). Touch breadboard pads to play different frequencies, use probe buttons to adjust sustain. You can trigger them to regenerate if you messed them up by deleting it with x (when you're in the File Manager), and then entering m to create new copies of any examples it doesn't see. Editing Slot Files Slot files (located in / slots / ) use YAML format and can be edited directly! They're human-readable files containing: bridges - Your circuit connections power - Rail and DAC voltages colors - Wire colors from Wokwi or custom colors config - Routing preferences and GPIO settings Example slot file: version : 2 sourceOfTruth : bridges bridges : - { n1 : 1 , n2 : 10 , dup : 2 , color : red } - { n1 : NANO_D5 , n2 : GPIO_1 , dup : 2 } - { n1 : TOP_RAIL , n2 : 5 , dup : 2 } power : topRail : 3.30 bottomRail : 2.50 dac0 : 3.33 dac1 : 0.00 Named nodes you can use: NANO_D0 - D13 , NANO_A0 - A7 , GPIO_1 - 8 , TOP_RAIL , BOTTOM_RAIL , GND , DAC0_5V , DAC1_5V , and more (see glossary ) When you edit and save a slot file, the Jumperless will automatically reload it if it's the active slot. This works whether you're using the onboard eKilo editor or have the Jumperless mouned as a USB Mass Storage drive and are editing the files on your computer in you favorite editor. USB Mass Storage Enter U in the menu and Jumperless will mount as a USB Mass Storage drive called JUMPERLESS where you can edit files on the filesystem. Keep in mind that file operations are pretty slow, so make sure to give it time to fully save files when you drop them onto the filesystem. When you're finished u (or just eject the drive) will unmount the Mass Storage device. You can also enter Z for a little debug menu Navigation Reference Key Action \u2191/\u2193 Move selection Enter Open/Edit / Go to root . Go up directory h Show help File Operations Key Action v View file e Edit file i File info n New file d New directory x Delete r Refresh System Key Action u Memory status m Initialize examples Ctrl+Q Quit","title":"File Manager"},{"location":"08-file-manager/#file-manager","text":"The Jumperless has a built in File Manager which you can access in the menu with / , or enter U in the menu and Jumperless will mount as a USB Mass Storage drive called JUMPERLESS where you can edit files on the filesystem.","title":"File Manager"},{"location":"08-file-manager/#file-system-structure","text":"\u251c\u2500\u2500 config . txt \u2502 \u251c\u2500\u2500 slots / \u2502 \u251c\u2500\u2500 slot0 . yaml \u2502 \u251c\u2500\u2500 slot1 . yaml \u2502 \u251c\u2500\u2500 slot2 . yaml \u2502 \u2514\u2500\u2500 ... ( up to slot7 . yaml ) \u2502 \u2514\u2500\u2500 python_scripts / \u251c\u2500\u2500 history . txt \u251c\u2500\u2500 cool_micropython_script . py \u251c\u2500\u2500 ... ( your python scripts go here ) \u2502 \u2514\u2500\u2500 examples / \u251c\u2500\u2500 adc_basics . py \u251c\u2500\u2500 dac_basics . py \u251c\u2500\u2500 gpio_basics . py \u251c\u2500\u2500 led_brightness_control . py \u251c\u2500\u2500 node_connections . py \u251c\u2500\u2500 stylophone . py \u251c\u2500\u2500 uart_basics . py \u251c\u2500\u2500 uart_loopback . py \u2514\u2500\u2500 voltage_monitor . py Each slot's configuration is stored as a YAML file in the / slots / directory, and the global hardware configuration is in / config . txt .","title":"File System Structure"},{"location":"08-file-manager/#navigation","text":"","title":"Navigation"},{"location":"08-file-manager/#basic-movement","text":"Control Action \u2191/\u2193 Arrow Keys or Rotary Encoder Move selection up/down Enter or Click Encoder Open directory or edit file / Go to root directory . Go up one directory CTRL + q Quit File Manager or Text Editor","title":"Basic Movement"},{"location":"08-file-manager/#file-manager-commands","text":"Key Action Description [enter] Open Open file or enter directory h Help Show help v Quick view View file contents . Up dir Go up one directory n New file Create new file (prompts for filename) d New directory Create new directory x Delete Delete file or directory (confirm with y / N )","title":"File Manager Commands"},{"location":"08-file-manager/#file-type-icons-and-colors","text":"Icon File Type Extensions Color \u2318 Directories - Blue \ud80c\udd9a Python files .py, .pyw, .pyi Green \u237a Text files .txt, .md White \u2699 Config files .cfg, .conf, config.txt Yellow \u27d0 JSON/YAML files .json, .yaml Cyan \u260a Slot files /slots/slot*.yaml Magenta \u2383 Legacy slot files nodeFileSlot*.txt Orange","title":"File Type Icons and Colors"},{"location":"08-file-manager/#jumperless-ekilo-text-editor","text":"The File Manager also has text editor based off eKilo","title":"Jumperless eKilo Text Editor"},{"location":"08-file-manager/#editor-controls","text":"Ctrl+S : Save file Ctrl+Q : Quit editor Ctrl+P : Save and launch MicroPython REPL Arrow keys : Navigate cursor Rotary encoder : Move cursor horizontally Click encoder : Enter character selection mode (you can scroll through the letters on the OLED and click again to insert it)","title":"Editor Controls"},{"location":"08-file-manager/#character-selection-with-the-click-wheel-and-oled","text":"When using the rotary encoder in the editor: Click encoder : Enter character selection mode Rotate encoder : Cycle through available characters Click encoder : Confirm character selection Wait 3 seconds : Exit character selection mode Yes, you could write code with just the click wheel and the OLED if you really wanted to.","title":"Character Selection With the Click Wheel and OLED"},{"location":"08-file-manager/#oled-display-support","text":"If you have an OLED connected, the File Manager shows: - Current path and selected file - File navigation with scrolling support - Real-time updates as you navigate","title":"OLED Display Support"},{"location":"08-file-manager/#micropython-examples","text":"The File Manager automatically creates example Python scripts in / python_scripts / examples / :","title":"MicroPython Examples"},{"location":"08-file-manager/#basic-hardware-examples","text":"adc_basics.py : Basic ADC (Analog-to-Digital Converter) operations. This example shows how to read analog voltages from all ADC channels (0-3). Connect voltage sources to ADC inputs and monitor readings in real-time. dac_basics.py : Basic DAC (Digital-to-Analog Converter) operations. Shows how to set DAC voltages on all channels (DAC_A, DAC_B, TOP_RAIL, BOTTOM_RAIL). Hardware setup: Connect voltmeter or LED to DAC output pins. gpio_basics.py : Basic GPIO (General Purpose Input/Output) operations. This example demonstrates digital I/O, direction control, and pull resistors. Tests input mode with pull-up, pull-down, and floating configurations. node_connections.py : Node connection and routing operations. This example shows how to connect/disconnect nodes, check connections, and clear all connections. Demonstrates working with breadboard nodes, DAC outputs, and GPIO pins. uart_loopback.py : UART Loopback Demo. Demonstrates UART communication by looping back data from UART_TX to UART_RX. Open a serial monitor on the Jumperless's second port at 115200 baud to see the looped messages.","title":"Basic Hardware Examples"},{"location":"08-file-manager/#interactive-examples","text":"interaction_demo.py : Interactive Demo - Control connections with probe, encoder, and buttons. This example shows how to use all the interactive controls together. No special hardware needed - use the probe to tap nodes, the encoder to adjust bridge spread, and buttons to change colors. led_brightness_control.py : LED Brightness Control Demo. Tap breadboard pads 1-60 to control the voltage on an LED and display the current draw. Hardware setup: Connect LED anode to breadboard row 15, connect LED cathode to GND. Displays voltage and current on OLED. stylophone.py : Jumperless Stylophone. Musical instrument using probe and GPIO to generate audio tones. Hardware setup: Connect speaker between rows 25 (positive) and 55 (negative). Touch breadboard pads to play different frequencies, use probe buttons to adjust sustain. You can trigger them to regenerate if you messed them up by deleting it with x (when you're in the File Manager), and then entering m to create new copies of any examples it doesn't see.","title":"Interactive Examples"},{"location":"08-file-manager/#editing-slot-files","text":"Slot files (located in / slots / ) use YAML format and can be edited directly! They're human-readable files containing: bridges - Your circuit connections power - Rail and DAC voltages colors - Wire colors from Wokwi or custom colors config - Routing preferences and GPIO settings Example slot file: version : 2 sourceOfTruth : bridges bridges : - { n1 : 1 , n2 : 10 , dup : 2 , color : red } - { n1 : NANO_D5 , n2 : GPIO_1 , dup : 2 } - { n1 : TOP_RAIL , n2 : 5 , dup : 2 } power : topRail : 3.30 bottomRail : 2.50 dac0 : 3.33 dac1 : 0.00 Named nodes you can use: NANO_D0 - D13 , NANO_A0 - A7 , GPIO_1 - 8 , TOP_RAIL , BOTTOM_RAIL , GND , DAC0_5V , DAC1_5V , and more (see glossary ) When you edit and save a slot file, the Jumperless will automatically reload it if it's the active slot. This works whether you're using the onboard eKilo editor or have the Jumperless mouned as a USB Mass Storage drive and are editing the files on your computer in you favorite editor.","title":"Editing Slot Files"},{"location":"08-file-manager/#usb-mass-storage","text":"Enter U in the menu and Jumperless will mount as a USB Mass Storage drive called JUMPERLESS where you can edit files on the filesystem. Keep in mind that file operations are pretty slow, so make sure to give it time to fully save files when you drop them onto the filesystem. When you're finished u (or just eject the drive) will unmount the Mass Storage device. You can also enter Z for a little debug menu","title":"USB Mass Storage"},{"location":"08-file-manager/#navigation-reference","text":"Key Action \u2191/\u2193 Move selection Enter Open/Edit / Go to root . Go up directory h Show help","title":"Navigation Reference"},{"location":"08-file-manager/#file-operations","text":"Key Action v View file e Edit file i File info n New file d New directory x Delete r Refresh","title":"File Operations"},{"location":"08-file-manager/#system","text":"Key Action u Memory status m Initialize examples Ctrl+Q Quit","title":"System"},{"location":"08-micropython/","text":"MicroPython This guide covers how to write, load, and run Python scripts that control Jumperless hardware using the embedded MicroPython interpreter. If you just want an overview of all the available calls, check out the MicroPython API Reference For stuff that's not Jumperless-specific, check out the MicroPython Docs Now you can live code with JumperIDE ! Holy shit I should have done this years ago Seriously, this is such a better experience than using the onboard text editor and REPL, you should play with it right now Go to https://ide.jumperless.org/ and press the connect button. Choose the 3rd Jumperless port in that list (Windows may not put them in order, so if nothing happens, try the other ones) and click Connect Then open some examples (this update should overwrite the examples with the new ones) and hit the Run / Stop button Press it again to Stop. If you make changes, hit the green Save button next to it (it takes a second and the script should be stopped.) If you write something cool, send it to me and I'll add it to the default examples (I'll put a page on this site soon where you can share them.) This is using MicroPython's built-in Raw REPL , so anything that can interact with that will work here. I've only tested with Viper IDE but I'm pretty sure just about anything else would work. There's also jumperless . py and jumperless . pyi module with stubs for all the built-in functions so syntax highlighting and autocomplete will work in your favorite code editor (sorry, autocomplete for jumperless functions doesn't work in ViperIDE.) You can grab them here: jumperless.py jumperless.pyi Quick Start (to do it from the built-in REPL) From the main Jumperless menu, press p to enter the MicroPython REPL: REPL Navigation Up / Down arrow keys on a blank prompt will scroll through history, any other key will break out of history mode and enter multiline editing. So you can use arrow keys to navigate and edit the script. In history mode, the >>> prompts will be pink, when you're editing, they'll be blue. Hardware Control Functions All Jumperless hardware functions are automatically imported into the global namespace - no prefix is actually necessary, but it's probably good to use import jumperless as j when using Viper IDE or something so it doesn't complain about not undefined names. Basic Script Structure \"\"\" My Jumperless Script Description of what this script does \"\"\" print ( \"Starting my script...\" ) # Connect some nodes connect ( 1 , 5 ) connect ( 2 , 6 ) # Set up GPIO gpio_set_dir ( 1 , True ) # Output gpio_set_dir ( 2 , False ) # Input # Main loop for i in range ( 10 ): gpio_set ( 1 , True ) time . sleep ( 0.5 ) gpio_set ( 1 , False ) time . sleep ( 0.5 ) # Read input (gpio_get returns truthy for HIGH, falsy for LOW) if gpio_get ( 2 ): print ( \"Button pressed!\" ) # Cleanup nodes_clear () print ( \"Script complete!\" ) Loading and Running Scripts Method 1 (Recommended): Viper IDE See above for instructions. It's at the top of the page for a reason, it's awesome. Method 2: File Manager From the REPL (enter p in the main menu), then type files to open the file manager: >>> files Navigate to your script and press Enter to load it for editing, then press Ctrl + P to load it into the REPL for execution. Note: The standard Python exec ( open ( ... ) . read ()) method is not supported in the Jumperless MicroPython environment. Always use the file manager and Ctrl + P to run scripts. Method 3: REPL Commands From the MicroPython REPL, you can use the following commands to manage scripts: # Load script into editor for modification load my_script . py # Save current session as script save my_new_script . py Method 4: Direct Execution From the main Jumperless menu, you can execute single commands: > gpio_set ( 1 , True ) > adc_get ( 0 ) > connect ( 1 , 5 ) REPL (Interactive Mode) Starting REPL From main menu: Press p REPL Commands CTRL + q - Exit REPL history - Show command history and saved scripts save [ name ] - Save last executed script load < name > - Load script by name or number files - Open file manager new - Create new script with eKilo editor helpl - Show REPL help help () - Show hardware commands Navigation \u2191 / \u2193 arrows - Browse command history \u2190 / \u2192 arrows - Move cursor , edit text TAB - Add 4 - space indentation Enter - Execute ( empty line in multiline to finish ) Ctrl + Q - Force quit REPL or interrupt running script Multiline Auto-Indent Mode The REPL automatically detects when you need multiple lines after a : >>> def blink_led (): ... for i in range ( 5 ): ... gpio_set ( 1 , True ) ... time . sleep ( 0.5 ) ... gpio_set ( 1 , False ) ... time . sleep ( 0.5 ) ... >>> blink_led () If you want to use real multiline mode, use the Kilo file editor. Command History Use \u2191/\u2193 arrows to browse previous commands Commands are automatically saved Type history to see all saved scripts Connection Context Switching The MicroPython REPL now supports connection contexts that determine how connections persist: global context : Changes persist to global state - connections remain after exiting Python python context : Connections are restored to how they were when exiting REPL (saved to slots / slotPython . yaml ) To toggle contexts: Type context in the REPL How it works: - In global mode: Any connections you make become permanent, just like using the normal command interface - In python mode: The connection state when you entered the REPL is saved, and restored when you exit - The current context is displayed in the REPL prompt Built-in Examples The system includes several example scripts. To run an example: Type files in the REPL. Navigate to the examples / directory. Select the desired script and press Enter to edit/view it. Press Ctrl + P to load it into the REPL for execution. Example scripts include: dac_basics . py adc_basics . py gpio_basics . py node_connections . py led_brightness_control . py stylophone . py uart_basics . py uart_loopback . py interaction_demo . py test_neopixel . py fake_gpio . py REPL not responding: - Press Ctrl+Q to force quit - Unplug / replug your Jumperless (don't worry, almost everything is persistent) Formatted Output and Custom Types The Jumperless module returns custom types that print nicely but also work in conditionals: # GPIO functions return custom types that print as readable strings state = gpio_get ( 1 ) # Prints \"HIGH\", \"LOW\", or \"FLOATING\" direction = gpio_get_dir ( 1 ) # Prints \"INPUT\" or \"OUTPUT\" pull = gpio_get_pull ( 1 ) # Prints \"PULLUP\", \"PULLDOWN\", or \"NONE\" # These types are also truthy/falsy for use in conditionals: if gpio_get ( 1 ): # True if HIGH, False if LOW or FLOATING print ( \"Pin is HIGH\" ) if gpio_get_dir ( 1 ): # True if OUTPUT, False if INPUT print ( \"Pin is output\" ) # Connection status works the same way connected = is_connected ( 1 , 5 ) # Prints \"CONNECTED\" or \"DISCONNECTED\" if connected : # True if connected, False if not print ( \"Nodes are connected\" ) # Voltage and current readings are floats voltage = adc_get ( 0 ) # Returns float (e.g., 3.300) current = ina_get_current ( 0 ) # Returns float in A (e.g., 0.0123) power = ina_get_power ( 0 ) # Returns float in W (e.g., 0.4567) # All functions work with both numbers and string aliases gpio_set_dir ( \"GPIO_1\" , True ) # Same as gpio_set_dir(1, True) connect ( \"TOP_RAIL\" , \"GPIO_1\" ) # Same as connect(101, 131)","title":"MicroPython"},{"location":"08-micropython/#micropython","text":"This guide covers how to write, load, and run Python scripts that control Jumperless hardware using the embedded MicroPython interpreter. If you just want an overview of all the available calls, check out the MicroPython API Reference For stuff that's not Jumperless-specific, check out the MicroPython Docs","title":"MicroPython"},{"location":"08-micropython/#now-you-can-live-code-with-jumperide","text":"Holy shit I should have done this years ago Seriously, this is such a better experience than using the onboard text editor and REPL, you should play with it right now Go to https://ide.jumperless.org/ and press the connect button. Choose the 3rd Jumperless port in that list (Windows may not put them in order, so if nothing happens, try the other ones) and click Connect Then open some examples (this update should overwrite the examples with the new ones) and hit the Run / Stop button Press it again to Stop. If you make changes, hit the green Save button next to it (it takes a second and the script should be stopped.)","title":"Now you can live code with JumperIDE!"},{"location":"08-micropython/#if-you-write-something-cool-send-it-to-me-and-ill-add-it-to-the-default-examples-ill-put-a-page-on-this-site-soon-where-you-can-share-them","text":"This is using MicroPython's built-in Raw REPL , so anything that can interact with that will work here. I've only tested with Viper IDE but I'm pretty sure just about anything else would work. There's also jumperless . py and jumperless . pyi module with stubs for all the built-in functions so syntax highlighting and autocomplete will work in your favorite code editor (sorry, autocomplete for jumperless functions doesn't work in ViperIDE.) You can grab them here:","title":"If you write something cool, send it to me and I'll add it to the default examples (I'll put a page on this site soon where you can share them.)"},{"location":"08-micropython/#jumperlesspy","text":"","title":"jumperless.py"},{"location":"08-micropython/#jumperlesspyi","text":"","title":"jumperless.pyi"},{"location":"08-micropython/#quick-start-to-do-it-from-the-built-in-repl","text":"From the main Jumperless menu, press p to enter the MicroPython REPL:","title":"Quick Start (to do it from the built-in REPL)"},{"location":"08-micropython/#repl-navigation","text":"Up / Down arrow keys on a blank prompt will scroll through history, any other key will break out of history mode and enter multiline editing. So you can use arrow keys to navigate and edit the script. In history mode, the >>> prompts will be pink, when you're editing, they'll be blue.","title":"REPL Navigation"},{"location":"08-micropython/#hardware-control-functions","text":"All Jumperless hardware functions are automatically imported into the global namespace - no prefix is actually necessary, but it's probably good to use import jumperless as j when using Viper IDE or something so it doesn't complain about not undefined names.","title":"Hardware Control Functions"},{"location":"08-micropython/#basic-script-structure","text":"\"\"\" My Jumperless Script Description of what this script does \"\"\" print ( \"Starting my script...\" ) # Connect some nodes connect ( 1 , 5 ) connect ( 2 , 6 ) # Set up GPIO gpio_set_dir ( 1 , True ) # Output gpio_set_dir ( 2 , False ) # Input # Main loop for i in range ( 10 ): gpio_set ( 1 , True ) time . sleep ( 0.5 ) gpio_set ( 1 , False ) time . sleep ( 0.5 ) # Read input (gpio_get returns truthy for HIGH, falsy for LOW) if gpio_get ( 2 ): print ( \"Button pressed!\" ) # Cleanup nodes_clear () print ( \"Script complete!\" )","title":"Basic Script Structure"},{"location":"08-micropython/#loading-and-running-scripts","text":"","title":"Loading and Running Scripts"},{"location":"08-micropython/#method-1-recommended-viper-ide","text":"See above for instructions. It's at the top of the page for a reason, it's awesome.","title":"Method 1 (Recommended): Viper IDE"},{"location":"08-micropython/#method-2-file-manager","text":"From the REPL (enter p in the main menu), then type files to open the file manager: >>> files Navigate to your script and press Enter to load it for editing, then press Ctrl + P to load it into the REPL for execution. Note: The standard Python exec ( open ( ... ) . read ()) method is not supported in the Jumperless MicroPython environment. Always use the file manager and Ctrl + P to run scripts.","title":"Method 2: File Manager"},{"location":"08-micropython/#method-3-repl-commands","text":"From the MicroPython REPL, you can use the following commands to manage scripts: # Load script into editor for modification load my_script . py # Save current session as script save my_new_script . py","title":"Method 3: REPL Commands"},{"location":"08-micropython/#method-4-direct-execution","text":"From the main Jumperless menu, you can execute single commands: > gpio_set ( 1 , True ) > adc_get ( 0 ) > connect ( 1 , 5 )","title":"Method 4: Direct Execution"},{"location":"08-micropython/#repl-interactive-mode","text":"","title":"REPL (Interactive Mode)"},{"location":"08-micropython/#starting-repl","text":"From main menu: Press p","title":"Starting REPL"},{"location":"08-micropython/#repl-commands","text":"CTRL + q - Exit REPL history - Show command history and saved scripts save [ name ] - Save last executed script load < name > - Load script by name or number files - Open file manager new - Create new script with eKilo editor helpl - Show REPL help help () - Show hardware commands","title":"REPL Commands"},{"location":"08-micropython/#navigation","text":"\u2191 / \u2193 arrows - Browse command history \u2190 / \u2192 arrows - Move cursor , edit text TAB - Add 4 - space indentation Enter - Execute ( empty line in multiline to finish ) Ctrl + Q - Force quit REPL or interrupt running script","title":"Navigation"},{"location":"08-micropython/#multiline-auto-indent-mode","text":"The REPL automatically detects when you need multiple lines after a : >>> def blink_led (): ... for i in range ( 5 ): ... gpio_set ( 1 , True ) ... time . sleep ( 0.5 ) ... gpio_set ( 1 , False ) ... time . sleep ( 0.5 ) ... >>> blink_led () If you want to use real multiline mode, use the Kilo file editor.","title":"Multiline Auto-Indent Mode"},{"location":"08-micropython/#command-history","text":"Use \u2191/\u2193 arrows to browse previous commands Commands are automatically saved Type history to see all saved scripts","title":"Command History"},{"location":"08-micropython/#connection-context-switching","text":"The MicroPython REPL now supports connection contexts that determine how connections persist: global context : Changes persist to global state - connections remain after exiting Python python context : Connections are restored to how they were when exiting REPL (saved to slots / slotPython . yaml ) To toggle contexts: Type context in the REPL How it works: - In global mode: Any connections you make become permanent, just like using the normal command interface - In python mode: The connection state when you entered the REPL is saved, and restored when you exit - The current context is displayed in the REPL prompt","title":"Connection Context Switching"},{"location":"08-micropython/#built-in-examples","text":"The system includes several example scripts. To run an example: Type files in the REPL. Navigate to the examples / directory. Select the desired script and press Enter to edit/view it. Press Ctrl + P to load it into the REPL for execution. Example scripts include: dac_basics . py adc_basics . py gpio_basics . py node_connections . py led_brightness_control . py stylophone . py uart_basics . py uart_loopback . py interaction_demo . py test_neopixel . py fake_gpio . py REPL not responding: - Press Ctrl+Q to force quit - Unplug / replug your Jumperless (don't worry, almost everything is persistent)","title":"Built-in Examples"},{"location":"08-micropython/#formatted-output-and-custom-types","text":"The Jumperless module returns custom types that print nicely but also work in conditionals: # GPIO functions return custom types that print as readable strings state = gpio_get ( 1 ) # Prints \"HIGH\", \"LOW\", or \"FLOATING\" direction = gpio_get_dir ( 1 ) # Prints \"INPUT\" or \"OUTPUT\" pull = gpio_get_pull ( 1 ) # Prints \"PULLUP\", \"PULLDOWN\", or \"NONE\" # These types are also truthy/falsy for use in conditionals: if gpio_get ( 1 ): # True if HIGH, False if LOW or FLOATING print ( \"Pin is HIGH\" ) if gpio_get_dir ( 1 ): # True if OUTPUT, False if INPUT print ( \"Pin is output\" ) # Connection status works the same way connected = is_connected ( 1 , 5 ) # Prints \"CONNECTED\" or \"DISCONNECTED\" if connected : # True if connected, False if not print ( \"Nodes are connected\" ) # Voltage and current readings are floats voltage = adc_get ( 0 ) # Returns float (e.g., 3.300) current = ina_get_current ( 0 ) # Returns float in A (e.g., 0.0123) power = ina_get_power ( 0 ) # Returns float in W (e.g., 0.4567) # All functions work with both numbers and string aliases gpio_set_dir ( \"GPIO_1\" , True ) # Same as gpio_set_dir(1, True) connect ( \"TOP_RAIL\" , \"GPIO_1\" ) # Same as connect(101, 131)","title":"Formatted Output and Custom Types"},{"location":"09.5-micropythonAPIreference/","text":"Jumperless MicroPython API Reference This document provides a comprehensive reference for the jumperless MicroPython module, which allows for direct control over the Jumperless hardware. A Note on Usage All functions and constants from the jumperless module are automatically imported into the global namespace. This means you can call them directly (e.g., connect ( 1 , 5 ) ) without needing the jumperless . prefix. There are three primary ways to specify nodes in functions: By Number : Use the integer corresponding to the breadboard row (1-60). By String Name : Use a case-insensitive string for any named node (e.g., \"d13\" , \"TOP_RAIL\" ). By Constant : Use the predefined, case-sensitive constant for a node (e.g., D13 , TOP_RAIL ). DAC (Digital-to-Analog Converter) - Examples : dac_set ( channel , voltage ) - Set DAC output voltage dac_get ( channel ) - Get DAC output voltage set_dac ( channel , voltage ) - Alias for dac_set get_dac ( channel ) - Alias for dac_get channel : 0 - 3 , DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL channel 0 / DAC0 : DAC 0 channel 1 / DAC1 : DAC 1 channel 2 / TOP_RAIL : top rail channel 3 / BOTTOM_RAIL : bottom rail voltage : - 8.0 to 8.0 V ADC (Analog-to-Digital Converter) - Examples : adc_get ( channel ) - Read ADC input voltage get_adc ( channel ) - Alias for adc_get channel : 0 - 4 ( and 7 for the probe tip in Measure mode ) INA (Current/Power Monitor) - Examples : ina_get_current ( sensor ) - Read current in amps ina_get_voltage ( sensor ) - Read shunt voltage ina_get_bus_voltage ( sensor ) - Read bus voltage ina_get_power ( sensor ) - Read power in watts Aliases: get_current , get_voltage , get_bus_voltage , get_power sensor : 0 or 1 GPIO - Examples : gpio_set ( pin , value ) - Set GPIO pin state gpio_get ( pin ) - Read GPIO pin state gpio_set_dir ( pin , direction ) - Set GPIO pin direction gpio_get_dir ( pin ) - Get GPIO pin direction gpio_set_pull ( pin , pull ) - Set GPIO pull-up/down gpio_get_pull ( pin ) - Get GPIO pull-up/down Aliases: set_gpio , get_gpio , set_gpio_dir , get_gpio_dir , etc. pin 1 - 8 : GPIO 1 - 8 pin 9 : UART Tx pin 10 : UART Rx value : True / False for HIGH / LOW direction : True / False for OUTPUT / INPUT pull : - 1 / 0 / 1 for PULL_DOWN / NONE / PULL_UP PWM (Pulse Width Modulation) - Examples : pwm ( pin , [ frequency ], [ duty ]) - Setup PWM on GPIO pin pwm_set_duty_cycle ( pin , duty ) - Set PWM duty cycle pwm_set_frequency ( pin , freq ) - Set PWM frequency pwm_stop ( pin ) - Stop PWM on pin Aliases: set_pwm , set_pwm_duty_cycle , set_pwm_frequency , stop_pwm pin : 1 - 8 GPIO pins only frequency : 0.001 - 62500000 default 1000 Hz duty_cycle : 0.0 - 1.0 default 0.5 ( 50 % ) Frequency Ranges: Hardware PWM: 10Hz to 62.5MHz (high precision) Slow PWM: 0.001Hz to 10Hz (hardware timer based) Automatic mode selection based on frequency Node Connections - Examples : connect ( node1 , node2 , [ duplicates =- 1 ]) - Connect two nodes (duplicates: -1=add, 0=none, N=force N) disconnect ( node1 , node2 ) - Disconnect nodes fast_connect ( node1 , node2 , [ duplicates =- 1 ]) - Connect, skip LED update fast_disconnect ( node1 , node2 ) - Disconnect, skip LED update is_connected ( node1 , node2 ) - Check if nodes are connected nodes_clear () - Clear all connections nodes_save ([ slot ]) - Save connections to slot nodes_discard () - Discard unsaved changes nodes_has_changes () - Check for unsaved changes switch_slot ( slot ) - Switch to a different slot get_state () - Get complete board state as JSON string set_state ( json , [ clear_first = True ]) - Apply complete state from JSON string set node2 to - 1 to disconnect everything connected to node1 fast_ * functions skip LED computation ( not faster , just defer visual updates ) Net Information : get_net_name ( netNum ) - Get the name of a net set_net_name ( netNum , name ) - Set a custom net name get_net_color ( netNum ) - Get net color as 0xRRGGBB get_net_color_name ( netNum ) - Get net color as name string set_net_color ( netNum , color ) - Set net color by name or RGB set_net_color_hsv ( netNum , h , [ s ], [ v ]) - Set net color by HSV (auto-detects 0-1 or 0-255) get_num_nets () - Get number of active nets get_num_bridges () - Get number of bridges get_net_nodes ( netNum ) - Get comma-separated node list get_bridge ( bridgeIdx ) - Get bridge info tuple get_net_info ( netNum ) - Get full net info as dict Path Query API - Inspect routing internals: get_num_paths ([ include_duplicates ]) - Get number of routing paths get_path_info ( path_idx ) - Get detailed path info as dict get_all_paths () - Get all paths as list of dicts get_path_between ( node1 , node2 ) - Query specific path between nodes Fake GPIO (Virtual GPIO Pins) - Turn any routable node into GPIO: FakeGpioPin ( node , [ mode ], [ v_high ], [ v_low ]) - Create virtual GPIO pin . on () , pin . off () , pin . toggle () , pin . value ([ val ]) - Control pin Use any routable node ( breadboard , Arduino pins , special nodes ) Any voltage : - 8 V to + 8 V ( not limited to 3.3 V ) Perfect for RS - 485 , 5 V TTL , industrial protocols Graphic Overlays - Examples : overlay_set ( name , row , col , w , h , colors ) - Create/update overlay overlay_clear ( name ) - Remove overlay overlay_clear_all () - Remove all overlays overlay_shift ( name , dRow , dCol ) - Move overlay relative overlay_place ( name , row , col ) - Move overlay absolute overlay_set_pixel ( row , col , color ) - Set single pixel overlay_count () - Get active overlay count overlay_serialize () - Get overlays as YAML OLED Display - Examples : oled_print ( \"text\" ) - Display text oled_clear () - Clear display oled_connect () - Connect OLED oled_disconnect () - Disconnect OLED Status - Examples : print_bridges () - Print all bridges print_paths () - Print path between nodes print_crossbars () - Print crossbar array print_nets () - Print nets print_chip_status () - Print chip status Probe Functions - Examples : probe_read_blocking () - Wait for probe touch (don't return until a pad is touched) probe_read_nonblocking () - Check probe immediately (return -1 if no pad is touched) get_button ([ blocking = True ]) - Get button state (default: blocking) probe_button ([ blocking = True ]) - Get button state (default: blocking) probe_button_blocking () - Wait for button press probe_button_nonblocking () - Check buttons immediately check_button () - Check for probe button presses get_switch_position () - Get probe switch position (0=measure, 1=select, -1=unknown) set_switch_position ( position ) - Set switch position manually check_switch_position () - Check switch via current sensing Touch returns : ProbePad object ( 1 - 60 , D13_PAD , TOP_RAIL_PAD , LOGO_PAD_TOP , etc . ) Button returns : CONNECT , REMOVE , or NONE ( front = connect , rear = remove ) Switch returns : SWITCH_MEASURE ( 0 ), SWITCH_SELECT ( 1 ), SWITCH_UNKNOWN ( - 1 ) Clickwheel (Rotary Encoder): clickwheel_get_position () - Get raw position counter clickwheel_reset_position () - Reset position to 0 clickwheel_get_direction ([ consume ]) - Get direction event (NONE/UP/DOWN) clickwheel_get_button () - Get button state JFS (Jumperless File System): jfs . open ( path , mode ) - Opens file, returns file handle jfs . read ( file , size = 1024 ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . seek ( file , position , whence = 0 ) - Seek in file jfs . tell ( file ) - Get current position jfs . size ( file ) - Get file size jfs . available ( file ) - Get bytes available jfs . exists ( path ) - Check if path exists (returns True/False) jfs . listdir ( path ) - List directory contents (returns list) jfs . mkdir ( path ) - Create directory jfs . rmdir ( path ) - Remove directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename/move file jfs . stat ( path ) - Get file/directory status info jfs . info () - Returns (total, used, free) tuple Misc - Examples : arduino_reset () - Reset Arduino run_app ( 'appName' ) - Run app pause_core2 ( pause ) - Pause/resume core2 processing send_raw ( chip , x , y , setOrClear ) - Send raw data to core2 change_terminal_color ( color , [ flush ]) - Set terminal color (0-255) cycle_term_color ([ reset ], [ step ], [ flush ]) - Cycle through colors force_service ( name ) - Force run a service by name force_service_by_index ( idx ) - Force run service by index (faster) get_service_index ( name ) - Get service index for caching context_toggle () - Toggle connection context (global/python) context_get () - Get current context name Help - Examples : help () - Display help nodes_help () - Show available nodes and how to address them Node Connections These functions manage the connections between nodes on the breadboard and special function pins. connect ( node1 , node2 , [ duplicates =- 1 ]) Creates a bridge between two nodes. node1 , node2 : The nodes to connect. Can be integers, strings, or constants. duplicates (optional): Controls duplicate connection behavior: - 1 (default): Just add the connection without managing duplicates (standard behavior) 0 : Force exactly 0 duplicates (removes any existing duplicate paths) 1 + : Force exactly N duplicates (adds or removes connections to reach that count) Example: # Connect breadboard row 1 to row 30 connect ( 1 , 30 ) # Connect Arduino D13 to the top power rail connect ( D13 , TOP_RAIL ) # Connect GPIO 1 to ADC 0 using strings connect ( \"GPIO_1\" , \"ADC0\" ) # Duplicate management examples connect ( 1 , 5 , duplicates = 0 ) # Ensure no duplicate paths connect ( 1 , 5 , duplicates = 2 ) # Force exactly 2 parallel paths connect ( 1 , 5 ) # Standard: just add the connection disconnect ( node1 , node2 ) Removes a specific bridge between two nodes. node1 , node2 : The two nodes to disconnect. To remove all connections from a single node, set node2 to - 1 . Example: # Remove the bridge between rows 1 and 30 disconnect ( 1 , 30 ) # Remove all connections from GPIO_1 disconnect ( GPIO_1 , - 1 ) <!-- ### fast_connect ( node1 , node2 , [ duplicates =- 1 ]) Connects two nodes while skipping LED computation . This function adds connections without updating LED state. It's not significantly faster overall, but it's useful when making many connections at once - you can defer LED updates until all connections are done. node1 , node2 : The nodes to connect. Can be integers, strings, or constants. duplicates (optional): Same behavior as connect () - see above for details. Example: # Make multiple connections without LED updates between each one for i in range ( 1 , 11 ): fast_connect ( i , i + 10 ) # LEDs update automatically when loop completes # With duplicate management fast_connect ( 1 , 5 , duplicates = 2 ) # Force 2 parallel paths, skip LED update fast_disconnect ( node1 , node2 ) Disconnects two nodes while skipping LED computation . Same LED-skipping behavior as fast_connect () . Useful for bulk disconnections. Example: # Bulk disconnections without LED updates for i in range ( 1 , 11 ): fast_disconnect ( i , i + 10 ) # LEDs update when loop completes ``` --> ### `is_connected(node1, node2)` Checks if a direct or indirect connection exists between two nodes . * Returns a custom ` ConnectionState ` object which evaluates to ` True ` if connected ( ` CONNECTED ` ) and ` False ` if not ( ` DISCONNECTED ` ) . ** Example : ** ``` jython if is_connected ( D13 , TOP_RAIL ): print ( \"D13 is connected to the top rail.\" ) state = is_connected ( 1 , 2 ) print ( state ) # Prints \"CONNECTED\" or \"DISCONNECTED\" nodes_clear () Removes all connections from the board. Example: nodes_clear () print ( \"All connections cleared.\" ) node ( name_or_id ) Creates a node object from a string name or integer ID. This is useful for storing a node reference in a variable. Node Type: Node objects support arithmetic and comparison operations with integers: Comparisons : == , != , < , <= , > , >= Arithmetic : + , - , * , // , % Conversions : int ( node ) converts to integer value Example: my_pin = node ( \"D7\" ) led_pin = node ( 15 ) connect ( my_pin , led_pin ) oled_print ( my_pin ) # Displays 'D7' on the OLED # Arithmetic and comparison work! if my_pin <= 20 : next_pin = my_pin + 1 # Returns int 8 connect ( next_pin , led_pin ) nodes_save ([ slot ]) Saves the current connections to a slot file. slot (optional): The slot number to save to. Defaults to the current active slot. Returns the slot number that was saved to. Example: # Save to current slot nodes_save () # Save to a specific slot nodes_save ( 3 ) nodes_discard () Discards all unsaved changes and restores the last saved state. Example: connect ( 1 , 5 ) # Make a change nodes_discard () # Undo it nodes_has_changes () Checks if there are unsaved changes since the last save. Returns True if there are unsaved changes, False otherwise. Example: if nodes_has_changes (): print ( \"You have unsaved changes!\" ) switch_slot ( slot ) Switches to a different connection slot. slot : The slot number to switch to (0-7). Returns the previous slot number. Example: old_slot = switch_slot ( 2 ) # Switch to slot 2 print ( \"Was in slot: \" + str ( old_slot )) get_state () Returns the entire board state as a formatted JSON string. This includes nets, power settings, and GPIO configuration. Example: state_json = get_state () print ( state_json ) set_state ( json , [ clear_first = True ]) Applies a board state from a JSON string. json : A JSON string representing the state (same format as returned by get_state () ). clear_first (optional): If True (default), clears all existing connections and FakeGPIO state before applying the new state. Set to False to merge the new state with the existing one. Example: # Apply a state from a string set_state ( '{\"nets\": [{\"index\": 1, \"name\": \"GND\", \"nodes\": [\"GND\"]}], \"power\": {\"top_rail\": 5.0}}' ) Net Information API Functions for querying and modifying net metadata. Nets are groups of connected nodes. get_net_name ( netNum ) Gets the name of a specific net. netNum : The net number (0 to number of nets - 1). Returns the net name string, or None if the net doesn't exist. Example: name = get_net_name ( 0 ) print ( \"Net 0 is called: \" + str ( name )) set_net_name ( netNum , name ) Sets a custom name for a net. netNum : The net number. name : The new name string. Pass empty string or None to reset to default. Example: set_net_name ( 0 , \"VCC\" ) set_net_name ( 1 , \"Signal_A\" ) get_net_color ( netNum ) Gets the color of a net as a 32-bit RGB value. netNum : The net number. Returns the color as 0 xRRGGBB . Example: color = get_net_color ( 0 ) print ( \"Net color: \" + hex ( color )) # e.g., \"0xff0000\" for red get_net_color_name ( netNum ) Gets the color name of a net as a human-readable string. netNum : The net number. Returns a color name like \"red\", \"blue\", \"green\", etc. Example: color_name = get_net_color_name ( 0 ) print ( \"Net 0 is \" + color_name ) # e.g., \"Net 0 is red\" set_net_color ( netNum , color , [ r ], [ g ], [ b ]) Sets the color of a net by name, hex string, or RGB values. netNum : The net number. color : Color as a name (\"red\", \"blue\", \"pink\") or hex string (\"#FF0000\", \"0xFF0000\"). r , g , b (optional): If providing RGB values directly, pass them as separate arguments. Returns 1 on success, 0 on failure (invalid color). Available color names: red, orange, amber, yellow, chartreuse, green, seafoam, cyan, blue, royal blue, indigo, violet, purple, pink, magenta, brown, white, black, grey Example: # Set by color name set_net_color ( 0 , \"red\" ) set_net_color ( 1 , \"cyan\" ) # Set by hex string set_net_color ( 2 , \"#FF00FF\" ) # Magenta set_net_color ( 3 , \"0x00FF00\" ) # Green # Set by RGB values set_net_color ( 4 , 255 , 128 , 0 ) # Orange set_net_color_hsv ( netNum , h , [ s ], [ v ]) Sets the color of a net using HSV (Hue, Saturation, Value) color space. Automatically detects whether you're using normalized (0.0-1.0) or full-range (0-255) values based on the hue parameter. netNum : The net number. h : Hue value. If h is between 0.0-1.0, all HSV values are treated as normalized (0.0-1.0). Otherwise, values are treated as 0-255 range. s (optional): Saturation value. Defaults to maximum saturation (255) if not provided or negative. v (optional): Value/brightness. Defaults to 32 (reasonable LED brightness) if not provided or negative. Returns 1 on success, 0 on failure. Range auto-detection: - If h \u2264 1.0: Normalized mode (0.0-1.0 for all values) - If h > 1.0: Full-range mode (0-255 for all values) Default brightness (32): This provides good visibility without being overly bright. For maximum brightness, explicitly set v to 1.0 (normalized) or 255 (full-range). Example: # Normalized mode (0.0-1.0) - detected because h <= 1.0 set_net_color_hsv ( 0 , 0.0 ) # Pure red, max saturation, default brightness (32) set_net_color_hsv ( 1 , 0.33 ) # Green, max saturation, default brightness (32) set_net_color_hsv ( 2 , 0.66 ) # Blue, max saturation, default brightness (32) set_net_color_hsv ( 3 , 0.5 , 0.8 ) # Cyan with 80% saturation, default brightness (32) set_net_color_hsv ( 4 , 0.5 , 1.0 , 0.5 ) # Cyan with max saturation, 50% brightness set_net_color_hsv ( 5 , 0.0 , 1.0 , 1.0 ) # Pure red at MAXIMUM brightness (255) # Full-range mode (0-255) - detected because h > 1.0 set_net_color_hsv ( 6 , 0 ) # Pure red, max saturation, default brightness (32) set_net_color_hsv ( 7 , 85 ) # Green (85 \u2248 255/3), default brightness (32) set_net_color_hsv ( 8 , 170 ) # Blue (170 \u2248 2*255/3), default brightness (32) set_net_color_hsv ( 9 , 128 , 200 ) # Cyan-ish with 200/255 saturation, default brightness set_net_color_hsv ( 10 , 128 , 255 , 128 ) # Cyan with max saturation, 50% brightness set_net_color_hsv ( 11 , 128 , 255 , 255 ) # Cyan at MAXIMUM brightness (255) # Using all defaults (h only) set_net_color_hsv ( 12 , 0.25 ) # Yellow with full saturation, brightness 32 set_net_color_hsv ( 13 , 64 ) # Yellow in 0-255 mode, brightness 32 Why use HSV? HSV is often more intuitive for color selection than RGB: - Hue represents the actual color (red \u2192 yellow \u2192 green \u2192 cyan \u2192 blue \u2192 magenta \u2192 red) - Saturation controls color intensity (0 = grayscale, max = vivid color) - Value controls brightness (0 = black, max = full brightness) get_num_nets () Gets the number of currently active nets. Returns an integer. Example: num = get_num_nets () print ( \"There are \" + str ( num ) + \" nets\" ) get_num_bridges () Gets the total number of bridges (connections). Returns an integer. Example: num = get_num_bridges () print ( \"There are \" + str ( num ) + \" bridges\" ) get_net_nodes ( netNum ) Gets all nodes in a net as a comma-separated string. netNum : The net number. Returns a string like \"D13,TOP_RAIL,GPIO_1\". Example: nodes = get_net_nodes ( 0 ) print ( \"Net 0 contains: \" + nodes ) get_bridge ( bridgeIdx ) Gets information about a specific bridge. bridgeIdx : The bridge index (0 to number of bridges - 1). Returns a tuple ( node1 , node2 , duplicates ) . Example: bridge = get_bridge ( 0 ) print ( \"Bridge 0: \" + str ( bridge [ 0 ]) + \" to \" + str ( bridge [ 1 ])) get_net_info ( netNum ) Gets comprehensive information about a net as a dictionary. netNum : The net number. Returns a dict with keys: name , number , color , color_name , nodes . Example: info = get_net_info ( 0 ) print ( \"Net name: \" + info [ 'name' ]) print ( \"Net color: \" + info [ 'color_name' ]) print ( \"Net nodes: \" + info [ 'nodes' ]) Path Query API Functions for inspecting the internal routing paths between nodes. Paths represent the actual physical routes through the crossbar chips that connect nodes together. Understanding Paths vs Bridges Bridges : Direct connections you create (e.g., connect ( 1 , 5 ) ) Paths : The actual routing through crossbar chips to implement those bridges A single bridge may require multiple paths through different chips. The path query API lets you inspect these internal routing details. get_num_paths ([ include_duplicates = True ]) Gets the number of routing paths currently in use. include_duplicates (optional): If True (default), count all paths including duplicates. If False , count only primary (non-duplicate) paths. Returns an integer. Example: total = get_num_paths () # All paths including duplicates primary = get_num_paths ( False ) # Only primary paths print ( f \"Total paths: { total } , Primary: { primary } \" ) get_path_info ( path_idx ) Gets detailed information about a specific routing path. path_idx : The path index (0 to get_num_paths () - 1 ) Returns a dict with keys: node1 , node2 , net , chips , x , y , duplicate Returns None if index is invalid Example: path = get_path_info ( 0 ) if path : print ( f \"Path from { path [ 'node1' ] } to { path [ 'node2' ] } \" ) print ( f \"Uses chips: { path [ 'chips' ] } \" ) print ( f \"Is duplicate: { path [ 'duplicate' ] } \" ) get_all_paths () Gets all routing paths as a list of dictionaries. Returns a list of path dicts (same format as get_path_info () ) Example: paths = get_all_paths () for i , path in enumerate ( paths ): print ( f \"Path { i } : { path [ 'node1' ] } -> { path [ 'node2' ] } via net { path [ 'net' ] } \" ) get_path_between ( node1 , node2 ) Queries the routing path between two specific nodes. node1 , node2 : The nodes to query Returns a path dict if found, None otherwise Example: path = get_path_between ( 1 , 5 ) if path : print ( f \"Route uses chips: { path [ 'chips' ] } \" ) print ( f \"Crossbar coordinates: x= { path [ 'x' ] } , y= { path [ 'y' ] } \" ) else : print ( \"No path found between nodes 1 and 5\" ) DAC (Digital-to-Analog Converter) Functions for controlling the analog voltage outputs. dac_set ( channel , voltage , [ save = True ]) Sets the output voltage for a specific DAC channel. channel : The DAC channel to set. Can be an integer (0-3) or a node constant ( DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL ). voltage : The desired voltage (from -8.0V to 8.0V). save (optional): If True (default), the setting is saved to the config file. Aliases : set_dac () Channels: * 0 or DAC0 : The 5V tolerant DAC output. * 1 or DAC1 : The 8V tolerant DAC output. * 2 or TOP_RAIL : The top power rail. * 3 or BOTTOM_RAIL : The bottom power rail. Example: # Set the top rail to 5V dac_set ( TOP_RAIL , 5.0 ) # Set DAC0 to 1.25V set_dac ( DAC0 , 1.25 ) dac_get ( channel ) Reads the currently set voltage for a DAC channel. channel : The DAC channel to read. Returns a float. Aliases : get_dac () Example: voltage = dac_get ( TOP_RAIL ) print ( \"Top Rail voltage: \" + str ( voltage )) ADC (Analog-to-Digital Converter) Functions for measuring analog voltages. adc_get ( channel ) Reads the voltage from a specific ADC channel. channel : The ADC channel to read (0-4). Returns a float. Aliases : get_adc () Channels: 0 - 3 : 8V tolerant ADC inputs. 4 : 5V tolerant ADC input. Example: voltage = adc_get ( 0 ) print ( \"ADC0 voltage: \" + str ( voltage )) Graphic Overlays Functions for creating and manipulating 2D color overlays on the breadboard LEDs. The breadboard is addressed as a 10-row \u00d7 30-column grid : * Row 1-5 : Top half (A-E) * Row 6-10 : Bottom half (F-J) * Column 1-30 : Breadboard columns 1-30 overlay_set ( name , x , y , height , width , colors ) Creates or updates a graphic overlay. name : Unique string identifier for the overlay. x : Starting column ( 1-30 ). Matches breadboard column labels. y : Starting row ( 1-10 ). 1-5 = Top half (A-E), 6-10 = Bottom half (F-J). height : Height in rows (y-dimension). width : Width in columns (x-dimension). colors : List of 32-bit integer colors (0xRRGGBB). Can be a flat list or 2D list (rows). Returns the overlay index. Note: If you pass a 2D array (list of lists) for colors , the outer list represents rows (height) and the inner lists represent columns (width). Make sure your width and height arguments match the data shape. Example: # Create a 5-wide, 2-high overlay at x=2, y=5 # x=2 (Column 2), y=5 (Row 5/E) colors_2d = [ [ 0x550000 , 0x550000 , 0x550000 , 0x550000 , 0x550000 ], # Row 0 [ 0x550000 , 0x550000 , 0x550000 , 0x550000 , 0x550000 ] # Row 1 ] overlay_set ( \"box_2d\" , 12 , 5 , 2 , 5 , colors_2d ) overlay_clear ( name ) Removes a specific overlay. name : The identifier of the overlay to remove. Returns 1 if found/removed, 0 otherwise. overlay_clear_all () Removes ALL active overlays. overlay_shift ( name , dx , dy ) Moves an overlay by a relative offset. Wraps around edges. name : Overlay identifier. dx : Column delta (e.g., 1 for right, -1 for left). dy : Row delta (e.g., 1 for down, -1 for up). Returns 1 if found, 0 otherwise. overlay_place ( name , x , y ) Moves an overlay to a specific absolute position. Wraps around edges. name : Overlay identifier. x : New column ( 1-30 ). y : New row ( 1-10 ). Returns 1 if found, 0 otherwise. Example: # Use the probe to move the box overlay import jumperless as j import time colors_2d = [ [ 0x550000 , 0x104000 , 0x005500 , 0x001040 , 0x000055 ], # Row 0 [ 0x550000 , 0x104000 , 0x005500 , 0x001040 , 0x000055 ], # Row 1 ] j . overlay_set ( \"box_2d\" , 12 , 5 , 2 , 5 , colors_2d ) while True : node = j . probe_read_blocking () j . overlay_place ( \"box_2d\" , node , 5 ) time . sleep ( 0.1 ) overlay_set_pixel ( x , y , color ) Sets a single pixel directly (convenience wrapper). x : Column (1-30). y : Row (1-10). color : 0xRRGGBB color. overlay_serialize () Returns the current state of all overlays as a JSON string. GPIO (General Purpose Input/Output) Functions for controlling the digital I/O pins. gpio_set ( pin , value ) Sets the output state of a GPIO pin. pin : The GPIO pin number (1-10). value : True for HIGH, False for LOW. Aliases : set_gpio () gpio_get ( pin ) Reads the state of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIOState object ( HIGH , LOW , or FLOATING ). Aliases : get_gpio () gpio_set_dir ( pin , direction ) Sets the direction of a GPIO pin. pin : The GPIO pin number (1-10). direction : True for OUTPUT, False for INPUT. Aliases : set_gpio_dir () gpio_get_dir ( pin ) Reads the direction of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIODirection object ( INPUT or OUTPUT ). Aliases : get_gpio_dir () gpio_set_pull ( pin , pull ) Configures the internal pull resistor for a GPIO pin. pin : The GPIO pin number (1-10). pull : 1 for PULLUP, - 1 for PULLDOWN, 0 for NONE. Aliases : set_gpio_pull () gpio_get_pull ( pin ) Reads the pull resistor configuration of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIOPull object ( PULLUP , PULLDOWN , or NONE ). Aliases : get_gpio_pull () gpio_set_read_floating ( pin , enabled ) Enable or disable special floating detection when reading GPIO inputs. These are all enabled by default. pin : The GPIO pin number (1-10). enabled : True to enable floating-read behavior, False to disable. Aliases : set_gpio_read_floating () Description: When enabled, the firmware performs an extra floating-detection check so gpio_get () can return FLOATING for very-high-impedance inputs. To do this it momentarily biases the pin with a very weak internal pull-up (~50 k\u03a9) while sampling. That transient bias can affect extremely high\u2011impedance sources (for example, >10 M\u03a9 sensors) and may cause a small leakage current or change the measured state. If your external circuit is super high\u2011impedance, either disable floating-read for that pin or add a defined pull resistor. gpio_get_read_floating ( pin ) Returns whether floating-read detection is enabled for a GPIO pin. pin : The GPIO pin number (1-10). Returns: True if floating-read is enabled, otherwise False . Aliases : get_gpio_read_floating () Example: # Enable floating detection on GPIO 3 gpio_set_read_floating ( 3 , True ) # Confirm it is enabled print ( gpio_get_read_floating ( 3 )) # True or False # If a connected high\u2011impedance sensor behaves oddly, disable floating-read gpio_set_read_floating ( 3 , False ) Pinout: * 1 - 8 : Routable GPIO pins GPIO_1 to GPIO_8 . * 9 : UART_TX . * 10 : UART_RX . Example: # Set GPIO 1 as an output and turn it on gpio_set_dir ( 1 , True ) gpio_set ( 1 , True ) # Set GPIO 2 as an input with a pull-up gpio_set_dir ( 2 , False ) gpio_set_pull ( 2 , 1 ) # Read the state of GPIO 2 state = gpio_get ( 2 ) if state : # GPIOState is truthy when HIGH, falsy when LOW or FLOATING print ( \"GPIO 2 is HIGH\" ) # You can also print it directly - shows \"HIGH\", \"LOW\", or \"FLOATING\" print ( \"State: \" + str ( state )) PWM (Pulse-Width Modulation) Functions for generating PWM signals on GPIO pins. pwm ( pin , [ frequency ], [ duty_cycle ]) Sets up and starts a PWM signal on a GPIO pin. pin : The GPIO pin to use (1-8). frequency (optional): The PWM frequency in Hz (0.001 to 62500000). Defaults to 1000. duty_cycle (optional): The duty cycle from 0.0 to 1.0. Defaults to 0.5. Aliases : set_pwm () Frequency Ranges: Hardware PWM : 10Hz to 62.5MHz (high precision, hardware peripheral) Slow PWM : 0.001Hz to 10Hz (hardware timer based, precise timing) Automatic Selection : System automatically chooses the appropriate mode based on frequency pwm_set_duty_cycle ( pin , duty_cycle ) Changes the duty cycle of an existing PWM signal. pin : The GPIO pin number (1-8). duty_cycle : The new duty cycle (0.0 to 1.0). Aliases : set_pwm_duty_cycle () pwm_set_frequency ( pin , frequency ) Changes the frequency of an existing PWM signal. pin : The GPIO pin number (1-8). frequency : The new frequency in Hz (0.001 to 62500000). Aliases : set_pwm_frequency () pwm_stop ( pin ) Stops the PWM signal on a GPIO pin. pin : The GPIO pin number (1-8). Aliases : stop_pwm () Example: # Hardware PWM: 1kHz, 25% duty cycle on GPIO_1 pwm ( GPIO_1 , 1000 , 0.25 ) # Slow PWM: 0.1Hz (10 second period), 50% duty cycle on GPIO_2 pwm ( GPIO_2 , 0.1 , 0.5 ) # Ultra-slow PWM: 0.001Hz (1000 second period), 25% duty cycle on GPIO_3 pwm ( GPIO_3 , 0.001 , 0.25 ) # Change the duty cycle to 75% pwm_set_duty_cycle ( GPIO_1 , 0.75 ) # Change frequency (will automatically switch between hardware/slow PWM) pwm_set_frequency ( GPIO_1 , 500 ) # 500Hz (hardware PWM) pwm_set_frequency ( GPIO_1 , 5 ) # 5Hz (slow PWM) # Stop the PWM signal pwm_stop ( GPIO_1 ) WaveGen (Waveform Generator) Functions for generating analog waveforms on DAC outputs. Setters: wavegen_set_output ( output ) - Select output: DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL (default DAC1 ) wavegen_set_freq ( hz ) - Set frequency: 0.0001\u201310000.0 Hz (default 100 Hz) wavegen_set_wave ( shape ) - Set waveform shape (see constants below) wavegen_set_sweep ( start_hz , end_hz , seconds ) - Configure a linear sweep wavegen_set_amplitude ( vpp ) - 0.0\u201316.0 Vpp (default 3.3 Vpp) wavegen_set_offset ( v ) - -8.0\u2013+8.0 V (default 1.65 V for 0\u20133.3 V centered) wavegen_start ([ run = True ]) - Start/stop output; calling with False stops wavegen_stop () - Stop output immediately Getters: wavegen_get_output () - Get current output channel wavegen_get_freq () - Get current frequency wavegen_get_wave () - Get current waveform wavegen_get_amplitude () - Get current amplitude (Vpp) wavegen_get_offset () - Get current offset wavegen_is_running () - Check if wavegen is active Aliases: All setters/getters have set_wavegen_ * and get_wavegen_ * aliases. Waveform Constants: SINE (0) - Sine wave TRIANGLE (1) - Triangle wave SAWTOOTH (2) - Sawtooth/ramp wave RAMP (2) - Alias for SAWTOOTH SQUARE (3) - Square wave ARBITRARY (4) - Arbitrary waveform (not yet implemented) Example: # Generate a 100Hz sine wave on DAC1 wavegen_set_output ( DAC1 ) wavegen_set_wave ( SINE ) wavegen_set_freq ( 100 ) wavegen_set_amplitude ( 3.3 ) # 3.3V peak-to-peak wavegen_set_offset ( 1.65 ) # Center at 1.65V (0-3.3V range) wavegen_start () # Check if running if wavegen_is_running (): print ( \"Wavegen active at \" + str ( wavegen_get_freq ()) + \"Hz\" ) # Change waveform while running wavegen_set_wave ( TRIANGLE ) # Stop wavegen_stop () Notes: - Wavegen runs on core 2 and is fully blocking while active; LEDs and routing updates pause until wavegen_stop () . - Frequency, waveform, amplitude, and offset can be changed live while running. INA (Current/Power Monitor) Functions for reading data from the INA219 current sensors. ina_get_current ( sensor ) Reads the current in Amps. * sensor : The sensor to read (0 or 1). * Aliases : get_current () ina_get_voltage ( sensor ) Reads the shunt voltage in Volts. * sensor : The sensor to read (0 or 1). * Aliases : get_voltage () ina_get_bus_voltage ( sensor ) Reads the bus voltage in Volts. * sensor : The sensor to read (0 or 1). * Aliases : get_bus_voltage () ina_get_power ( sensor ) Reads the power in Watts. * sensor : The sensor to read (0 or 1). * Aliases : get_power () Example: current_mA = ina_get_current ( 0 ) * 1000 print ( \"Current: \" + str ( current_mA ) + \" mA\" ) OLED Display Functions for controlling the onboard OLED display with advanced text, graphics, and bitmap capabilities. Basic Display Functions oled_print ( text , [ size =- 1 ]) Displays text on the OLED screen. It can print strings, numbers, and custom Jumperless types. text : The content to display. size (optional): Text size (0=small scrolling, 1=normal, 2=large). If -1 or omitted, uses the default size set by oled_set_text_size () . Defaults to 2. Size Modes: - Size 0 : Small scrolling text (perfect for terminal-like output with multiple lines) - Size 1 : Normal centered text - Size 2 : Large centered text (default) Example: oled_print ( \"Hello!\" ) # Uses default size oled_print ( \"Big Text\" , 2 ) # Large text oled_print ( \"Scrolling\" , 0 ) # Small scrolling text oled_clear ([ show = True ]) Clears the OLED display. show (optional): If True (default), automatically calls oled_show () after clearing. Set to False for animations to avoid flashing between frames. Example: # Normal use - clears and shows oled_clear () # Animation loop - clear without showing to prevent flashing for frame in range ( 100 ): oled_clear ( False ) # Clear without show # Draw your frame... oled_show () # Show once after drawing oled_show () Refreshes the OLED display to show the latest changes. Note: Usually not needed as oled_print () handles display updates automatically. Required after oled_set_pixel () calls. oled_connect () Connects the I2C lines to the OLED display. oled_disconnect () Disconnects the I2C lines from the OLED display. Text Size Control oled_set_text_size ( size ) Set the default text size for all subsequent oled_print () calls. size : Text size (0=small scrolling, 1=normal, 2=large) Returns: True if successful, False if invalid size Example: import jumperless as j # Use small scrolling text for terminal output j . oled_set_text_size ( 0 ) for i in range ( 10 ): j . oled_print ( f \"Line { i + 1 } \" ) # Each creates a new scrolling line # Switch to large text j . oled_set_text_size ( 2 ) j . oled_print ( \"BIG TEXT\" ) oled_get_text_size () Get the current default text size. Returns: Current text size (0, 1, or 2) Example: current_size = oled_get_text_size () print ( f \"Current OLED text size: { current_size } \" ) Print Redirection oled_copy_print ( enable ) Enable or disable copying Python print () output to the OLED display in real-time. When enabled, all print () statements will appear on both the serial console and the OLED in small scrolling text mode. This is perfect for debugging without a serial connection. enable : True to enable, False to disable Example: import jumperless as j # Enable print copying j . oled_copy_print ( True ) # These appear on both serial AND OLED print ( \"Starting test...\" ) voltage = j . adc_get ( 0 ) print ( f \"Voltage: { voltage : .2f } V\" ) print ( \"Test complete!\" ) # Disable print copying j . oled_copy_print ( False ) print ( \"This only goes to serial\" ) Font System oled_get_fonts () Get a list of all available font families. Returns: List of font family names (strings) Available Fonts: Eurostyle - sans serif, futuristic, like Xenon pinball or Star Trek Jokerman - decorative font with lots of extra artistic dots and bars Comic Sans - sans serif, comic book style lettering Courier New - slab serif, typewriter style New Science - sans serif, humanist/geometric, like Helvetica New Science Ext - wider version of New Science Iosevka Regular - fixed spacing sans serif, like Lucida, slashed zero Berkeley Mono - fixed spacing, sans serif, large X height Pragmatism - sans serif, vaguely romantic Andale Mono - fixed spacing sans serif, used for small text (Descriptions by MadBodger) Example: import jumperless as j import time fonts = j . oled_get_fonts () print ( f \"Available fonts: { fonts } \" ) # Display each font for font in fonts : j . oled_set_font ( font ) j . oled_print ( font , 2 ) time . sleep ( 1.5 ) oled_set_font ( name ) Set the current font family by name. The font will remain active until changed. name : Font family name (case-insensitive) Returns: True if successful, False if font not found Example: import jumperless as j # Set to Jokerman if j . oled_set_font ( \"Jokerman\" ): j . oled_print ( \"Fun Font!\" , 2 ) else : print ( \"Font not found\" ) # Set to Courier for code-like display j . oled_set_font ( \"Courier New\" ) j . oled_print ( \"Code Style\" , 2 ) oled_get_current_font () Get the name of the currently active font family. Returns: Current font family name (string) Example: import jumperless as j current = j . oled_get_current_font () print ( f \"Current font: { current } \" ) # Save and restore font saved_font = j . oled_get_current_font () j . oled_set_font ( \"Jokerman\" ) j . oled_print ( \"Temporary\" , 2 ) j . oled_set_font ( saved_font ) # Restore original Bitmap Display oled_load_bitmap ( filepath ) Load a bitmap file into the internal bitmap buffer. filepath : Path to bitmap file (e.g., \"/images/logo.bin\") Returns: True if loaded successfully, False on error Bitmap File Format: Raw Format : Pure bitmap data (guesses dimensions from file size) 128x32 = 512 bytes 128x64 = 1024 bytes 64x32 = 256 bytes Custom Format : 4-byte header + bitmap data Bytes 0-1: Width (16-bit little-endian) Bytes 2-3: Height (16-bit little-endian) Remaining: Bitmap data (1 bit per pixel, packed) Example: if oled_load_bitmap ( \"/images/jogo32h.bin\" ): print ( \"Logo loaded!\" ) else : print ( \"Failed to load logo\" ) oled_display_bitmap ( x , y , width , height , [ data = None ]) Display a bitmap on the OLED. Two modes: Use loaded bitmap : If data is None , displays the bitmap from oled_load_bitmap () Direct data : If data is provided, displays that bitmap immediately x : X position on display (0-127) y : Y position on display (0-31) width : Bitmap width in pixels (ignored if using loaded bitmap) height : Bitmap height in pixels (ignored if using loaded bitmap) data (optional): Bitmap data to display directly Returns: True if successful, False on error Example: import jumperless as j # Method 1: Load then display j . oled_load_bitmap ( \"/images/logo.bin\" ) j . oled_display_bitmap ( 0 , 0 , 0 , 0 ) # width/height ignored for loaded bitmap # Method 2: Display direct data bitmap_data = bytes ([ 0xFF , 0x00 , 0xFF , 0x00 ] * 128 ) # Striped pattern j . oled_display_bitmap ( 0 , 0 , 128 , 32 , bitmap_data ) oled_show_bitmap_file ( filepath , x , y ) Convenience function that loads and displays a bitmap in one call. filepath : Path to bitmap file x : X position on display y : Y position on display Returns: True if successful, False on error Example: import jumperless as j import time # One-liner to show a logo j . oled_show_bitmap_file ( \"/images/jogo32h.bin\" , 0 , 0 ) time . sleep ( 2 ) # Show another image j . oled_show_bitmap_file ( \"/images/badge.bin\" , 32 , 8 ) Framebuffer and Pixel Manipulation The framebuffer functions provide low-level access to the display memory, enabling advanced graphics, animations, and screen capture. Framebuffer Format: - 1 bit per pixel (0=black/off, 1=white/on) - Organized in vertical bytes (8 pixels per byte) - Size: 512 bytes (128x32) or 1024 bytes (128x64) - Compatible with Adafruit SSD1306 format oled_get_framebuffer () Get a copy of the current OLED framebuffer as a bytes object. Returns: Framebuffer data as bytes (512 or 1024 bytes depending on display size) oled_set_framebuffer ( data ) Set the entire OLED framebuffer from bytes or bytearray. data : Framebuffer data (must be correct size for display) Returns: True if successful, False if wrong size Example: import jumperless as j import time # Capture current display fb = j . oled_get_framebuffer () print ( f \"Framebuffer size: { len ( fb ) } bytes\" ) # Save to file for later with open ( \"/screen_capture.bin\" , \"wb\" ) as f : f . write ( fb ) j . oled_clear () time . sleep ( 2 ) # Load and display saved screen with open ( \"/screen_capture.bin\" , \"rb\" ) as f : fb_data = f . read () if j . oled_set_framebuffer ( fb_data ): print ( \"Screen restored!\" ) else : print ( \"Wrong framebuffer size\" ) oled_get_framebuffer_size () Get the dimensions and size of the framebuffer. Returns: Tuple of ( width , height , buffer_size_in_bytes ) Example: width , height , size = oled_get_framebuffer_size () print ( f \"Display: { width } x { height } , { size } bytes\" ) # Output: Display: 128x32, 512 bytes # Calculate pixels total_pixels = width * height print ( f \"Total pixels: { total_pixels } \" ) oled_set_pixel ( x , y , color ) Set a single pixel on the OLED. Note: Call oled_show () after setting pixels to make changes visible. x : X coordinate (0 to width-1) y : Y coordinate (0 to height-1) color : Pixel color (0=black/off, 1=white/on) Returns: True if successful, False if OLED not connected Example: import jumperless as j # Draw a diagonal line j . oled_clear () for i in range ( 32 ): j . oled_set_pixel ( i , i , 1 ) j . oled_show () # Draw a box for x in range ( 20 , 108 ): j . oled_set_pixel ( x , 10 , 1 ) # Top edge j . oled_set_pixel ( x , 22 , 1 ) # Bottom edge for y in range ( 10 , 23 ): j . oled_set_pixel ( 20 , y , 1 ) # Left edge j . oled_set_pixel ( 107 , y , 1 ) # Right edge j . oled_show () oled_get_pixel ( x , y ) Get the color value of a single pixel. x : X coordinate (0 to width-1) y : Y coordinate (0 to height-1) Returns: Pixel color (0=black/off, 1=white/on, -1=error) Example: # Check if a pixel is set pixel = oled_get_pixel ( 64 , 16 ) if pixel == 1 : print ( \"Pixel is white/on\" ) elif pixel == 0 : print ( \"Pixel is black/off\" ) else : print ( \"Error reading pixel\" ) Advanced OLED Examples Debug Output to OLED import jumperless as j import time # Enable print copying for debugging j . oled_copy_print ( True ) # Your code with debug output for i in range ( 10 ): voltage = j . adc_get ( 0 ) print ( f \"V { i } : { voltage : .2f } V\" ) time . sleep ( 0.5 ) j . oled_copy_print ( False ) Simple Oscilloscope import jumperless as j import math import time # Clear display j . oled_clear () width , height , _ = j . oled_get_framebuffer_size () j . connect ( j . ADC0 , 11 ) # Draw sine wave animation for offset in range ( 100 ): j . oled_clear ( False ) # Don't show() after clear to avoid flashing # Draw axes for x in range ( width ): if ( x % 4 == 0 ): j . oled_set_pixel ( x , height // 2 , 1 ) # Dotted center line # Draw sine wave for x in range ( width ): # y = int(height//2 + 10 * math.sin((x + offset) / 10)) # Dummy sine wave y = int ( j . get_adc ( 0 )) + 16 if 0 <= y < height : j . oled_set_pixel ( x , y , 1 ) # time.sleep_ms(10) j . oled_show () time . sleep ( 0.005 ) Screen Capture and Manipulation import jumperless as j import time # Capture screen fb = j . oled_get_framebuffer () # Invert all pixels inverted = bytearray ( fb ) for i in range ( len ( inverted )): inverted [ i ] = ~ inverted [ i ] & 0xFF # Display inverted j . oled_set_framebuffer ( inverted ) time . sleep ( 1 ) # Restore original j . oled_set_framebuffer ( fb ) Terminal-like Output import jumperless as j import time # Use small scrolling text j . oled_set_text_size ( 0 ) j . oled_clear () for i in range ( 20 ): j . oled_print ( f \"Line { i } \" ) time . sleep ( 0.2 ) Font Showcase import jumperless as j import time for font in j . oled_get_fonts (): j . oled_set_font ( font ) j . oled_print ( font , 2 ) time . sleep ( 1.5 ) Probe Functions for interacting with the physical probe. probe_read ([ blocking = True ]) Reads the pad currently being touched by the probe. blocking (optional): If True (default), the function will wait until a pad is touched. If False , it returns immediately. Returns a ProbePad object (e.g., 25 , D13_PAD , NO_PAD ). Aliases : read_probe () , probe_read_blocking () , probe_read_nonblocking () , probe_wait () , wait_probe () , probe_touch () , wait_touch () ProbePad Type: ProbePad objects support arithmetic and comparison operations with integers: Comparisons : == , != , < , <= , > , >= Arithmetic : + , - , * , // , % Conversions : int ( pad ) converts to integer value Example: pad = probe_read ( False ) # Non-blocking if pad != NO_PAD : print ( pad ) if pad <= 60 : # Compare with integer node_1 = pad node_2 = pad + 3 # Arithmetic with integer if node_2 > 60 : # Works! node_2 -= 60 connect ( node_1 , node_2 ) probe_button ([ blocking = True ], [ consume = False ]) Reads the state of the buttons on the probe. blocking (optional): If True (default), waits for a button press. If False , returns the current state immediately. consume (optional): If True , clears the button press after reading (one-shot detection). If False (default), the button state persists while held, allowing repeated reads in a loop. Returns a ProbeButton object ( CONNECT_BUTTON , REMOVE_BUTTON , or BUTTON_NONE ). Aliases : get_button () , button_read () , read_button () , probe_button_blocking () , probe_button_nonblocking () , check_button () , button_check () Consume Behavior: consume = False (default): Holding the button returns the same state repeatedly - ideal for continuous control (e.g., incrementing values while held) consume = True : Each button press is detected only once - ideal for menu navigation or one-shot actions Example: # Continuous control - hold button to keep changing hue while True : button = check_button () # consume=False by default if button == BUTTON_CONNECT : hue += 1 # Keeps incrementing while button is held set_net_color_hsv ( 0 , hue ) elif button == BUTTON_REMOVE : hue -= 1 # Keeps decrementing while button is held set_net_color_hsv ( 0 , hue ) time . sleep ( 0.05 ) # One-shot detection - each press counted once presses = 0 while presses < 5 : button = get_button ( consume = True ) # Each press consumed if button == BUTTON_CONNECT : presses += 1 print ( f \"Press # { presses } \" ) Example: print ( \"Touch a pad...\" ) pad = probe_read () print ( \"You touched: \" + str ( pad )) if pad == D13_PAD : print ( \"That's the Arduino LED pin!\" ) print ( \"Press a probe button...\" ) button = get_button () if button == CONNECT_BUTTON : print ( \"Connect button pressed.\" ) get_switch_position () Gets the current probe switch position. Returns: 0 (SWITCH_MEASURE), 1 (SWITCH_SELECT), or - 1 (SWITCH_UNKNOWN) Example: position = get_switch_position () if position == SWITCH_MEASURE : print ( \"Probe is in measure mode\" ) elif position == SWITCH_SELECT : print ( \"Probe is in select mode\" ) set_switch_position ( position ) Manually sets the probe switch position. position : 0 (SWITCH_MEASURE), 1 (SWITCH_SELECT), or - 1 (SWITCH_UNKNOWN) Example: set_switch_position ( SWITCH_SELECT ) # Force select mode check_switch_position () Checks the probe switch position using current sensing and updates the internal state. Returns: Updated switch position Uses hysteresis thresholds to prevent oscillation between modes: - Switches to SELECT when current > high threshold - Switches to MEASURE when current < low threshold Example: # Periodically check and respond to switch changes while True : position = check_switch_position () if position == SWITCH_MEASURE : voltage = measureMode () print ( f \"Voltage: { voltage } V\" ) elif position == SWITCH_SELECT : pad = probe_read ( blocking = False ) if pad != NO_PAD : print ( f \"Touched: { pad } \" ) time . sleep ( 0.1 ) Clickwheel Functions for reading the rotary encoder (clickwheel) position, direction, and button state. clickwheel_get_position () Gets the raw clickwheel position counter. Returns: Current position value (integer, can be positive or negative) The position accumulates as you turn the clickwheel - clockwise increases, counter-clockwise decreases. Example: pos = clickwheel_get_position () print ( f \"Current position: { pos } \" ) clickwheel_reset_position () Resets the clickwheel position counter to 0. Example: clickwheel_reset_position () assert clickwheel_get_position () == 0 clickwheel_get_direction ([ consume = True ]) Gets the current clickwheel direction event. consume (optional): If True (default), clears the direction after reading (one-shot detection). If False , the direction persists until consumed. Returns: CLICKWHEEL_NONE (0), CLICKWHEEL_UP (1), or CLICKWHEEL_DOWN (2) Important: The direction state persists until consumed! This means you won't miss turn events even if you don't check every loop iteration. The UP or DOWN state stays active until you read it with consume = True . Example (One-shot - Default): direction = clickwheel_get_direction () # consume=True (default) if direction == CLICKWHEEL_UP : value += 1 # Only increments once per turn event print ( f \"Turned up: { value } \" ) elif direction == CLICKWHEEL_DOWN : value -= 1 # Only decrements once per turn event print ( f \"Turned down: { value } \" ) Example (Persistent - Check Multiple Times): # Check direction without consuming direction = clickwheel_get_direction ( consume = False ) if direction == CLICKWHEEL_UP : print ( \"Turning clockwise...\" ) # Do some work... # Check again - still UP until consumed! if clickwheel_get_direction ( consume = False ) == CLICKWHEEL_UP : print ( \"Still turning up!\" ) # Finally consume it clickwheel_get_direction ( consume = True ) clickwheel_get_button () Gets the current clickwheel button state. Returns: CLICKWHEEL_IDLE (0) - Not pressed CLICKWHEEL_PRESSED (1) - Just pressed CLICKWHEEL_HELD (2) - Being held down CLICKWHEEL_RELEASED (3) - Just released CLICKWHEEL_DOUBLECLICKED (4) - Double-clicked Example: button = clickwheel_get_button () if button == CLICKWHEEL_PRESSED : print ( \"Button pressed!\" ) elif button == CLICKWHEEL_HELD : print ( \"Button held down\" ) elif button == CLICKWHEEL_DOUBLECLICKED : print ( \"Double click!\" ) Complete Example - Menu Navigation: import jumperless as j import time menu_items = [ \"Option 1\" , \"Option 2\" , \"Option 3\" , \"Option 4\" ] selected = 0 j . clickwheel_reset_position () while True : # Check direction (consume=True by default - one turn = one event) direction = j . clickwheel_get_direction () if direction == j . CLICKWHEEL_UP : selected = ( selected + 1 ) % len ( menu_items ) print ( f \"> { menu_items [ selected ] } \" ) elif direction == j . CLICKWHEEL_DOWN : selected = ( selected - 1 ) % len ( menu_items ) print ( f \"> { menu_items [ selected ] } \" ) # Check button button = j . clickwheel_get_button () if button == j . CLICKWHEEL_PRESSED : print ( f \"Selected: { menu_items [ selected ] } \" ) elif button == j . CLICKWHEEL_DOUBLECLICKED : print ( \"Exit menu\" ) break # Note: Direction persists, so even with slow polling (50ms), # you won't miss turn events! time . sleep ( 0.05 ) Example - Value Adjustment with Persistence: import jumperless as j import time value = 50 while True : # Check direction without consuming direction = j . clickwheel_get_direction ( consume = False ) if direction == j . CLICKWHEEL_UP : value = min ( 100 , value + 1 ) j . oled_print ( f \"Value: { value } \" , 2 ) time . sleep ( 0.1 ) # Delay for visual feedback # Consume after displaying j . clickwheel_get_direction ( consume = True ) elif direction == j . CLICKWHEEL_DOWN : value = max ( 0 , value - 1 ) j . oled_print ( f \"Value: { value } \" , 2 ) time . sleep ( 0.1 ) j . clickwheel_get_direction ( consume = True ) # Exit on button press if j . clickwheel_get_button () == j . CLICKWHEEL_PRESSED : break time . sleep ( 0.01 ) Fake GPIO (Virtual GPIO Pins) Fake GPIO uses the Jumperless' internal crossbar switches to create virtual GPIO pins on any routable node. Unlike the RP2350's hardware GPIO (limited to 10 routable pins at 0-3.3V), Fake GPIO lets you use any node with custom voltage levels from -8V to +8V, or as inputs, you can have as many as you like and the ADC will switch to that node and take a reading on demand. This is still pretty new and will probably change in the future Note: Fake GPIO Outputs are currently disabled until I fix the code, they were causing dead shorts between supplies Why Use Fake GPIO? The RP2350's hardware GPIO is limited to 10 routable pins (GPIO_1 through GPIO_8, plus UART TX/RX) with fixed 3.3V logic levels. Fake GPIO extends this by using the crossbar switching matrix to create virtual GPIO pins on any routable node with configurable voltage levels. <!-- Pin Expansion: Any routable node can function as a virtual GPIO pin, including breadboard nodes (1-60) and Arduino pins (D0-D13, A0-A7). The ADC dynamically switches to INPUT pins on demand for reading, allowing an unlimited number of inputs. Voltage Range: Output voltages from -8V to +8V are supported by routing between voltage sources (TOP_RAIL, BOTTOM_RAIL, GND, DAC0, DAC1). This enables: RS-485/RS-422 differential signaling (\u00b18V) 5V TTL logic compatibility Bipolar signal generation Configuring OUTPUT Pins FakeGpioPin ( node , j . OUTPUT , high_source , low_source ) Creates a digital output that switches between two voltage sources. Parameters: node (int, required): Any routable node - breadboard holes (1-60), Arduino pins (D0-D13, A0-A7), special nodes mode (constant, required): j . OUTPUT high_source (node, optional): Voltage source for HIGH state (default: j . TOP_RAIL ) low_source (node, optional): Voltage source for LOW state (default: j . GND ) Valid voltage sources: j . TOP_RAIL , j . BOTTOM_RAIL , j . GND , j . DAC0 , j . DAC1 Returns: FakeGpioPin object Examples: import jumperless as j # Simple output (TOP_RAIL and GND) led = j . FakeGpioPin ( 10 , j . OUTPUT ) led . on () # HIGH (TOP_RAIL voltage) led . off () # LOW (GND = 0V) # RS-485 differential signaling (\u00b18V) j . rails_set ( 8.0 , - 8.0 ) # TOP=+8V, BOTTOM=-8V rs485_a = j . FakeGpioPin ( 25 , j . OUTPUT , j . TOP_RAIL , j . BOTTOM_RAIL ) rs485_b = j . FakeGpioPin ( 26 , j . OUTPUT , j . BOTTOM_RAIL , j . TOP_RAIL ) rs485_a . on () # A: +8V, B: -8V (differential high) rs485_a . off () # A: -8V, B: +8V (differential low) # Multiple pins sharing voltage sources outputs = [] for node in [ 30 , 31 , 32 , 33 ]: pin = j . FakeGpioPin ( node , j . OUTPUT , j . TOP_RAIL , j . GND ) outputs . append ( pin ) # All pins safely share TOP_RAIL and GND! ``` --> ### Configuring INPUT Pins ``` python FakeGpioPin ( node , j . INPUT , threshold_high , threshold_low ) Creates a digital input that reads voltage via the ADC. Parameters: node (int, required): Any routable node to read from mode (constant, required): j . INPUT threshold_high (float, optional): Input HIGH threshold in volts (default: 2.0) threshold_low (float, optional): Input LOW threshold in volts (default: 0.8) Returns: FakeGpioPin object Example: import jumperless as j # Read a digital signal button = j . FakeGpioPin ( 20 , j . INPUT ) state = button . value () # Returns 0 or 1 # Custom thresholds for 5V logic signal_5v = j . FakeGpioPin ( 25 , j . INPUT , 3.5 , 1.5 ) if signal_5v . value (): print ( \"5V logic HIGH detected\" ) FakeGpioPin Methods pin . on () Sets OUTPUT pin to HIGH state (connects high_source ). pin . off () Sets OUTPUT pin to LOW state (connects low_source ). pin . toggle () Toggles OUTPUT pin between HIGH and LOW states. pin . value ([ val ]) For OUTPUT: Gets or sets the pin value (0 or 1). For INPUT: Reads the current pin state (0 or 1). # Basic usage pin = j . FakeGpioPin ( 20 ) pin . on () # HIGH pin . off () # LOW pin . toggle () # Switch state # Using value() pin . value ( 1 ) # Set HIGH pin . value ( 0 ) # Set LOW state = pin . value () # Read current state System Functions arduino_reset () Resets the connected Arduino Nano. run_app ( appName ) Launches a built-in Jumperless application. appName : The name of the app to run (e.g., \"File Manager\", \"I2C Scan\"). pause_core2 ( pause ) Pauses or resumes core2 processing. pause : True to pause core2, False to resume. For doing time sensitive things where you don't want core 2 to cause timing glitches while it periodically updates the LEDs. Core 2 will resume when you exit the REPL no matter what. send_raw ( chip , x , y , setOrClear ) Sends raw data to core2 for direct chip control. chip : Chip identifier (string, e.g., \"A\", \"B\", \"C\"). x , y : Coordinates for the operation. setOrClear : 1 to set, 0 to clear. You should probably be looking at the schematic if you use this. By bypassing all the routing logic, you can make or break connections in ~1 \u00b5s. Pretty handy if want to do high speed switching between known states. change_terminal_color ( color , [ flush = True ]) Sets the terminal text color using 256-color ANSI codes. color : Color index (0-255), or -1 to reset to default flush (optional): Flush output immediately (default: True ) This is the 6x6x6 color cube that terminals use: Example: change_terminal_color ( 196 ) # Bright red print ( \"Error message\" ) change_terminal_color ( - 1 ) # Reset to default change_terminal_color ( 46 ) # Cyan print ( \"Info message\" ) cycle_term_color ([ reset = False ], [ step = 1.0 ], [ flush = True ]) Cycles through the terminal color palette. reset (optional): If True , reset to start of color sequence step (optional): Color increment step (defaults to the last one you set) flush (optional): Flush output immediately (default: True ) Useful for creating rainbow effects or visually distinguishing output sections. This is really just a helper function for me, it only uses a subset of the colors (I think ~44 of them?) above that actually look good. It takes a float so you can use fractional values if you have more than 44 things and you want a smooth spectrum. This doesn't currently work in Viper IDE because it strips the escape sequences Example: cycle_term_color ( True , 1.5 ) # Start fresh for i in range ( 10 ): cycle_term_color () # Next color print ( f \"Line { i } in different color\" ) # Visual separator in help output cycle_term_color ( True , step = 5.0 ) force_service ( name ) Forces immediate execution of a specific system service by name. name : Service name as a string (e.g., \"ProbeButton\" , \"Peripherals\" ). Returns: True if service was found and executed, False otherwise. Useful for manually triggering specific services during tight loops where automatic service scheduling might not run frequently enough. Example: while True : # Fast loop that might miss automatic service updates connect ( 1 , 2 ) force_service ( \"ProbeButton\" ) # Ensure button state updates button = check_button () time . sleep ( 0.001 ) force_service_by_index ( index ) Forces immediate execution of a specific system service by index (faster than name lookup). index : Service index (integer, obtained via get_service_index () ). Returns: True if index valid and service executed, False otherwise. Example: # Cache the index once for maximum speed btn_idx = get_service_index ( \"ProbeButton\" ) while True : connect ( 1 , 2 ) force_service_by_index ( btn_idx ) # Fastest way to force service button = check_button () time . sleep ( 0.001 ) get_service_index ( name ) Gets the index of a service by name for use with force_service_by_index () . name : Service name as a string. Returns: Service index (integer, 0 or higher), or - 1 if not found. Cache the returned index for repeated fast calls to force_service_by_index () . Example: # Look up once, use many times probe_idx = get_service_index ( \"ProbeButton\" ) if probe_idx >= 0 : # Use the cached index in your loop force_service_by_index ( probe_idx ) context_toggle () Toggles the connection context between global and python modes. In global mode: Connection changes persist after exiting Python. In python mode: Connection state is restored when you exit the REPL. Example: context_toggle () # Switch from global to python (or vice versa) print ( \"Now in \" + context_get () + \" mode\" ) context_get () Gets the current connection context name. Returns \"global\" or \"python\" . Example: if context_get () == \"global\" : print ( \"Changes will persist after exit\" ) else : print ( \"Changes will be discarded on exit\" ) Status Functions These functions print detailed status information to the serial console. print_bridges () : Prints all active bridges. print_paths () : Prints all resolved paths between nodes. print_crossbars () : Prints the raw state of the crossbar matrix. print_nets () : Prints the current net list. print_chip_status () : Prints the status of the CH446Q chips. Help Functions help () Displays a comprehensive list of all available functions and constants in the jumperless module. You can also pass it sections, so help ( \"GPIO\" ) will just print that section. nodes_help () Displays a detailed reference for all available node names and their aliases. Node Names and Constants The Jumperless module provides extensive node name support with multiple aliases for each node: # Power rails (multiple aliases supported) TOP_RAIL = 101 # Also: TOPRAIL, T_R, TOP_R BOTTOM_RAIL = 102 # Also: BOT_RAIL, BOTTOMRAIL, BOTRAIL, B_R, BOT_R SUPPLY_3V3 = 103 # Also: 3V3, 3.3V SUPPLY_5V = 105 # Also: 5V, +5V SUPPLY_8V_P = 120 # Also: 8V_P, 8V_POS SUPPLY_8V_N = 121 # Also: 8V_N, 8V_NEG # Ground connections GND = 100 # Also: GROUND TOP_RAIL_GND = 104 # Also: TOP_GND (not actually routable but included for PADs) BOTTOM_RAIL_GND = 126 # Also: BOT_GND, BOTTOM_GND (not actually routable but included for PADs) # DAC outputs DAC0 = 106 # Also: DAC_0, DAC0_5V DAC1 = 107 # Also: DAC_1, DAC1_8V # ADC inputs ADC0 = 110 # Also: ADC_0, ADC0_8V ADC1 = 111 # Also: ADC_1, ADC1_8V ADC2 = 112 # Also: ADC_2, ADC2_8V ADC3 = 113 # Also: ADC_3, ADC3_8V ADC4 = 114 # Also: ADC_4, ADC4_5V ADC7 = 115 # Also: ADC_7, ADC7_PROBE, PROBE # Current sensing ISENSE_PLUS = 108 # Also: ISENSE_POS, ISENSE_P, INA_P, I_P, CURRENT_SENSE_PLUS, ISENSE_POSITIVE, I_POS ISENSE_MINUS = 109 # Also: ISENSE_NEG, ISENSE_N, INA_N, I_N, CURRENT_SENSE_MINUS, ISENSE_NEGATIVE, I_NEG # GPIO pins (multiple naming conventions) GPIO_1 = 131 # Also: RP_GPIO_1, GPIO1, GP_1, GP1 GPIO_2 = 132 # Also: RP_GPIO_2, GPIO2, GP_2, GP2 GPIO_3 = 133 # Also: RP_GPIO_3, GPIO3, GP_3, GP3 GPIO_4 = 134 # Also: RP_GPIO_4, GPIO4, GP_4, GP4 GPIO_5 = 135 # Also: RP_GPIO_5, GPIO5, GP_5, GP5 GPIO_6 = 136 # Also: RP_GPIO_6, GPIO6, GP_6, GP6 GPIO_7 = 137 # Also: RP_GPIO_7, GPIO7, GP_7, GP7 GPIO_8 = 138 # Also: RP_GPIO_8, GPIO8, GP_8, GP8 # UART pins UART_TX = 116 # Also: RP_UART_TX, TX, RP_GPIO_16 UART_RX = 117 # Also: RP_UART_RX, RX, RP_GPIO_17 # Additional RP GPIOs RP_GPIO_18 = 118 # Also: GP_18 RP_GPIO_19 = 119 # Also: GP_19 # Buffer connections BUFFER_IN = 139 # Also: ROUTABLE_BUFFER_IN, BUF_IN, BUFF_IN, BUFFIN BUFFER_OUT = 140 # Also: ROUTABLE_BUFFER_OUT, BUF_OUT, BUFF_OUT, BUFFOUT # Arduino Nano pins (extensive support) D13 = 83 # Also: NANO_D13 D12 = 82 # Also: NANO_D12 D11 = 81 # Also: NANO_D11 D10 = 80 # Also: NANO_D10 D9 = 79 # Also: NANO_D9 D8 = 78 # Also: NANO_D8 D7 = 77 # Also: NANO_D7 D6 = 76 # Also: NANO_D6 D5 = 75 # Also: NANO_D5 D4 = 74 # Also: NANO_D4 D3 = 73 # Also: NANO_D3 D2 = 72 # Also: NANO_D2 D1 = 71 # Also: NANO_D1 D0 = 70 # Also: NANO_D0 # Arduino Nano analog pins A0 = 86 # Also: NANO_A0 A1 = 87 # Also: NANO_A1 A2 = 88 # Also: NANO_A2 A3 = 89 # Also: NANO_A3 A4 = 90 # Also: NANO_A4 A5 = 91 # Also: NANO_A5 A6 = 92 # Also: NANO_A6 A7 = 93 # Also: NANO_A7 # Arduino Nano non-routable hardwired connections VIN = 69 # Unconnected to anything RST0 = 94 # Hardwired to GPIO 18 on the RP2350 RST1 = 95 # Hardwired to GPIO 19 on the RP2350 N_GND0 = 97 # GND N_GND1 = 96 # GND NANO_5V = 99 # Hardwired to USB 5V bus (can also be used to power the Jumperless) NANO_3V3 = 98 # Unconnected (without bridging the solder jumper on the back) # Probe switch position constants SWITCH_MEASURE = 0 # Probe in measure mode SWITCH_SELECT = 1 # Probe in select mode SWITCH_UNKNOWN = - 1 # Position unknown # Clickwheel direction constants CLICKWHEEL_NONE = 0 # No movement CLICKWHEEL_UP = 1 # Turned clockwise CLICKWHEEL_DOWN = 2 # Turned counter-clockwise # Clickwheel button state constants CLICKWHEEL_IDLE = 0 # Not pressed CLICKWHEEL_PRESSED = 1 # Just pressed CLICKWHEEL_HELD = 2 # Being held down CLICKWHEEL_RELEASED = 3 # Just released CLICKWHEEL_DOUBLECLICKED = 4 # Double-clicked The entire output of help() >>> help () Jumperless Native MicroPython Module Available help sections : help () or help ( \"all\" ) - Show all functions help ( \"DAC\" ) - DAC functions help ( \"ADC\" ) - ADC functions help ( \"GPIO\" ) - GPIO functions help ( \"PWM\" ) - PWM functions help ( \"WAVEGEN\" ) - Waveform generator help ( \"INA\" ) - INA current / power monitor help ( \"NODES\" ) - Node connections help ( \"NETS\" ) - Net info ( names , colors ) help ( \"SLOTS\" ) - Slot management help ( \"OLED\" ) - OLED display help ( \"PROBE\" ) - Probe and button functions help ( \"CLICKWHEEL\" ) - Clickwheel ( rotary encoder ) functions help ( \"FAKEGPIO\" ) - Fake GPIO ( virtual GPIO pins ) help ( \"STATUS\" ) - Status and debug functions help ( \"FILESYSTEM\" ) - Filesystem functions help ( \"MISC\" ) - Miscellaneous functions help ( \"EXAMPLES\" ) - Usage examples DAC ( Digital - to - Analog Converter ): dac_set ( channel , voltage ) - Set DAC output voltage dac_get ( channel ) - Get DAC output voltage set_dac ( channel , voltage ) - Alias for dac_set get_dac ( channel ) - Alias for dac_get channel : 0 - 3 , DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL channel 0 / DAC0 : DAC 0 channel 1 / DAC1 : DAC 1 channel 2 / TOP_RAIL : top rail channel 3 / BOTTOM_RAIL : bottom rail voltage : - 8.0 to 8.0 V ADC ( Analog - to - Digital Converter ): adc_get ( channel ) - Read ADC input voltage get_adc ( channel ) - Alias for adc_get channel : 0 - 4 GPIO : gpio_set ( pin , value ) - Set GPIO pin state gpio_get ( pin ) - Read GPIO pin state gpio_set_dir ( pin , direction ) - Set GPIO pin direction gpio_get_dir ( pin ) - Get GPIO pin direction gpio_set_pull ( pin , pull ) - Set GPIO pull - up / down gpio_get_pull ( pin ) - Get GPIO pull - up / down Aliases : set_gpio , get_gpio , set_gpio_dir , get_gpio_dir , etc . pin 1 - 8 : GPIO 1 - 8 pin 9 : UART Tx pin 10 : UART Rx value : True / False for HIGH / LOW direction : True / False for OUTPUT / INPUT pull : - 1 / 0 / 1 / 2 for PULLDOWN / NO_PULL / PULLUP / BUS_KEEPER PWM ( Pulse Width Modulation ): pwm ( pin , [ frequency ], [ duty ]) - Setup PWM on GPIO pin pwm_set_duty_cycle ( pin , duty ) - Set PWM duty cycle pwm_set_frequency ( pin , freq ) - Set PWM frequency pwm_stop ( pin ) - Stop PWM on pin Aliases : set_pwm , set_pwm_duty_cycle , set_pwm_frequency , stop_pwm pin : 1 - 8 GPIO pins only frequency : 0.001 Hz - 62.5 MHz default 1000 Hz duty_cycle : 0.0 - 1.0 default 0.5 ( 50 % ) WaveGen ( Waveform Generator ): wavegen_set_output ( channel ) - Set output : DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL wavegen_set_freq ( hz ) - Set frequency ( 0.0001 - 10000 Hz ) wavegen_set_wave ( shape ) - Set waveform shape wavegen_set_amplitude ( vpp ) - Set amplitude ( 0 - 16 Vpp ) wavegen_set_offset ( v ) - Set DC offset ( - 8 to + 8 V ) wavegen_start () - Start waveform generation wavegen_stop () - Stop waveform generation Getters : wavegen_get_output (), wavegen_get_freq (), wavegen_get_wave (), wavegen_get_amplitude (), wavegen_get_offset (), wavegen_is_running () Waveform constants : SINE , TRIANGLE , SAWTOOTH ( RAMP ), SQUARE INA ( Current / Power Monitor ): ina_get_current ( sensor ) - Read current in amps ina_get_voltage ( sensor ) - Read shunt voltage ina_get_bus_voltage ( sensor ) - Read bus voltage ina_get_power ( sensor ) - Read power in watts Aliases : get_current , get_voltage , get_bus_voltage , get_power sensor : 0 or 1 Node Connections : connect ( node1 , node2 , [ duplicates =- 1 ]) - Connect two nodes disconnect ( node1 , node2 ) - Disconnect nodes fast_connect ( node1 , node2 , [ duplicates =- 1 ]) - Connect , skip LED update fast_disconnect ( node1 , node2 ) - Disconnect , skip LED update is_connected ( node1 , node2 ) - Check if nodes are connected nodes_clear () - Clear all connections set node2 to - 1 to disconnect everything connected to node1 duplicates : - 1 ( add ), 0 ( no duplicates ), N ( force N duplicates ) fast_ * functions skip LED computation ( defer visual updates ) Net Information : get_net_name ( netNum ) - Get net name set_net_name ( netNum , name ) - Set custom net name get_net_color ( netNum ) - Get net color as 0 xRRGGBB get_net_color_name ( netNum ) - Get net color name set_net_color ( netNum , color ) - Set net color by name or hex set_net_color_hsv ( netNum , h , [ s ], [ v ]) - Set by HSV ( auto - detects range ) get_num_nets () - Get number of active nets get_num_bridges () - Get number of bridges get_net_nodes ( netNum ) - Get comma - separated node list get_bridge ( bridgeIdx ) - Get bridge info tuple get_net_info ( netNum ) - Get full net info as dict Colors : red , orange , yellow , green , cyan , blue , purple , pink , etc . HSV : h = 0.0 - 1.0 or 0 - 255 ( auto ), s = 0 - 1 / 0 - 255 ( default max ), v = 0 - 1 / 0 - 255 ( default 32 ) Path Query API : get_num_paths ([ include_duplicates ]) - Get number of routing paths get_path_info ( path_idx ) - Get detailed path info as dict get_all_paths () - Get all paths as list of dicts get_path_between ( node1 , node2 ) - Query specific path between nodes Inspect internal routing through crossbar chips Slot Management : nodes_save ([ slot ]) - Save connections to slot nodes_discard () - Discard unsaved changes nodes_has_changes () - Check for unsaved changes switch_slot ( slot ) - Switch to different slot ( 0 - 7 ) CURRENT_SLOT - Get current slot number Context ( controls persistence ): context_toggle () - Toggle global / python mode context_get () - Get current mode name OLED Display : oled_print ( \"text\" ) - Display text oled_clear () - Clear display oled_connect () - Connect OLED oled_disconnect () - Disconnect OLED Probe Functions : probe_read ([ blocking = True ]) - Read probe ( default : blocking ) read_probe ([ blocking = True ]) - Read probe ( default : blocking ) probe_read_blocking () - Wait for probe touch ( explicit ) probe_read_nonblocking () - Check probe immediately ( explicit ) get_button ([ blocking ], [ consume ]) - Get button ( blocking = True , consume = False ) probe_button ([ blocking ], [ consume ]) - Get button ( blocking = True , consume = False ) check_button ([ consume ]) - Check button non - blocking ( consume = False ) probe_button_blocking ([ consume ]) - Wait for button ( consume = False ) probe_button_nonblocking ([ consume ]) - Check button immediate ( consume = False ) consume = False ( default ): Holding button returns same state ( continuous control ) consume = True : Each press detected once ( one - shot detection ) Probe Switch Functions : get_switch_position () - Get current switch position set_switch_position ( pos ) - Set switch position manually check_switch_position () - Check switch via current sensing Touch returns : ProbePad object ( 1 - 60 , D13_PAD , TOP_RAIL_PAD , LOGO_PAD_TOP , etc . ) Button returns : CONNECT , REMOVE , or NONE ( front = connect , rear = remove ) Switch returns : SWITCH_MEASURE ( 0 ), SWITCH_SELECT ( 1 ), SWITCH_UNKNOWN ( - 1 ) Clickwheel ( Rotary Encoder ): clickwheel_get_position () - Get raw position counter clickwheel_reset_position () - Reset position to 0 clickwheel_get_direction ([ consume = True ]) - Get direction event clickwheel_get_button () - Get button state clickwheel_is_initialized () - Check if clickwheel is ready consume = True ( default ): Direction cleared after reading ( one - shot detection ) consume = False : Direction persists until consumed ( can read multiple times ) Direction returns : CLICKWHEEL_NONE ( 0 ), CLICKWHEEL_UP ( 1 ), CLICKWHEEL_DOWN ( 2 ) Button returns : CLICKWHEEL_IDLE ( 0 ), CLICKWHEEL_PRESSED ( 1 ), CLICKWHEEL_HELD ( 2 ), CLICKWHEEL_RELEASED ( 3 ), CLICKWHEEL_DOUBLECLICKED ( 4 ) Fake GPIO ( Virtual GPIO Pins ): FakeGpioPin ( node , [ mode ], [ v_high ], [ v_low ]) - Create virtual GPIO on any breadboard node pin . on () - Set HIGH ( v_high voltage ) pin . off () - Set LOW ( v_low voltage ) pin . toggle () - Toggle HIGH / LOW pin . value ([ val ]) - Get / set value ( 0 or 1 ) Why use Fake GPIO ? \u2022 More pins : Use any routable node ( breadboard , Arduino pins , special nodes ) \u2022 Any voltage : - 8 V to + 8 V ( not limited to 3.3 V ) \u2022 Industrial protocols : RS - 485 ( \u00b1 8 V ), 5 V TTL , custom logic levels Mode constants : OUTPUT , INPUT Status : print_bridges () - Print all bridges print_paths () - Print path between nodes print_crossbars () - Print crossbar array print_nets () - Print nets print_chip_status () - Print chip status Filesystem : jfs . open ( path , mode ) - Open file jfs . read ( file , size ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . exists ( path ) - Check if file exists jfs . listdir ( path ) - List directory jfs . mkdir ( path ) - Create directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename file jfs . info () - Get filesystem info Misc : arduino_reset () - Reset Arduino run_app ( appName ) - Run built - in app pause_core2 ( pause ) - Pause / unpause Core2 ( True / False ) send_raw ( chip , x , y , set ) - Send raw data to crossbar chip change_terminal_color ( color , [ flush ]) - Set terminal color ( 0 - 255 ) cycle_term_color ([ reset ], [ step ], [ flush ]) - Cycle through colors force_service ( name ) - Force run a specific service ( e . g . , \"ProbeButton\" ) force_service_by_index ( idx ) - Force run service by index ( faster ) get_service_index ( name ) - Get service index by name ( cache for fast calls ) Examples ( all functions available globally ): dac_set ( DAC0 , 5.0 ) # Set DAC0 using node constant voltage = get_adc ( 1 ) # Read ADC1 using alias connect ( TOP_RAIL , D13 ) # Connect using constants connect ( 4 , 20 , duplicates = 2 ) # Force 2 parallel paths fast_connect ( 1 , 5 ) # Connect without LED update top_rail = node ( \"TOP_RAIL\" ) # Create node object oled_print ( \"Hello!\" ) # Display text on OLED current = get_current ( 0 ) # Read current using alias set_gpio ( 1 , True ) # Set GPIO pin high pwm ( 1 , 1000 , 0.5 ) # 1kHz PWM, 50% duty wavegen_set_wave ( SINE ); wavegen_start () # Start sine wave set_net_color ( 0 , \"red\" ) # Color net 0 red set_net_color_hsv ( 1 , 0.5 ) # Cyan net 1 (HSV hue) nodes_save () # Save current connections pad = probe_read () # Wait for probe touch button = get_button () # Wait for button press pos = clickwheel_get_position () # Get encoder position direction = clickwheel_get_direction () # Get turn direction change_terminal_color ( 196 ) # Set red text cycle_term_color () # Next color path = get_path_between ( 1 , 5 ) # Query routing path led = FakeGpioPin ( 25 ) # Virtual GPIO on breadboard node led . toggle () # Digital switching rs485 = FakeGpioPin ( 20 , OUTPUT , 8.0 , - 8.0 ) # RS-485 \u00b18V signal >>> The entire output of nodes_help() >>> nodes_help () Jumperless Node Reference ======================== NODE TYPES : Numbered : 1 - 60 ( breadboard ) Arduino : D0 - D13 , A0 - A7 ( nano header ) GPIO : GPIO_1 - GPIO_8 ( routable GPIO ) Power : TOP_RAIL , BOTTOM_RAIL , GND DAC : DAC0 , DAC1 ( analog outputs ) ADC : ADC0 - ADC4 , PROBE ( analog inputs ) Current : ISENSE_PLUS , ISENSE_MINUS UART : UART_TX , UART_RX Buffer : BUFFER_IN , BUFFER_OUT THREE WAYS TO USE NODES : 1. NUMBERS ( direct breadboard holes ): connect ( 1 , 30 ) # Connect holes 1 and 30 connect ( 15 , 42 ) # Any number 1-60 2. STRINGS ( case - insensitive names ): connect ( \"D13\" , \"TOP_RAIL\" ) # Arduino pin to power rail connect ( \"gpio_1\" , \"adc0\" ) # GPIO to ADC (case-insensitive) connect ( \"15\" , \"dac1\" ) # Mix numbers and names 3. CONSTANTS ( pre - defined objects ): connect ( TOP_RAIL , D13 ) # Using imported constants connect ( GPIO_1 , A0 ) # No quotes needed connect ( DAC0 , 25 ) # Mix constants and numbers MIXED USAGE : my_pin = \"D13\" # Create node object from string connect ( my_pin , TOP_RAIL ) # Use node object with constant oled_print ( my_pin ) # Display shows 'D13' COMMON ALIASES ( many names work for same node ): \"TOP_RAIL\" = \"T_R\" \"GPIO_1\" = \"GPIO1\" = \"GP1\" \"DAC0\" = \"DAC_0\" \"UART_TX\" = \"TX\" NOTES : - String names are case - insensitive : \"d13\" = \"D13\" = \"nAnO_d13\" - Constants are case - sensitive : use D13 , not d13 - All three methods work in any function","title":"MicroPython API Reference"},{"location":"09.5-micropythonAPIreference/#jumperless-micropython-api-reference","text":"This document provides a comprehensive reference for the jumperless MicroPython module, which allows for direct control over the Jumperless hardware.","title":"Jumperless MicroPython API Reference"},{"location":"09.5-micropythonAPIreference/#a-note-on-usage","text":"All functions and constants from the jumperless module are automatically imported into the global namespace. This means you can call them directly (e.g., connect ( 1 , 5 ) ) without needing the jumperless . prefix. There are three primary ways to specify nodes in functions: By Number : Use the integer corresponding to the breadboard row (1-60). By String Name : Use a case-insensitive string for any named node (e.g., \"d13\" , \"TOP_RAIL\" ). By Constant : Use the predefined, case-sensitive constant for a node (e.g., D13 , TOP_RAIL ). DAC (Digital-to-Analog Converter) - Examples : dac_set ( channel , voltage ) - Set DAC output voltage dac_get ( channel ) - Get DAC output voltage set_dac ( channel , voltage ) - Alias for dac_set get_dac ( channel ) - Alias for dac_get channel : 0 - 3 , DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL channel 0 / DAC0 : DAC 0 channel 1 / DAC1 : DAC 1 channel 2 / TOP_RAIL : top rail channel 3 / BOTTOM_RAIL : bottom rail voltage : - 8.0 to 8.0 V ADC (Analog-to-Digital Converter) - Examples : adc_get ( channel ) - Read ADC input voltage get_adc ( channel ) - Alias for adc_get channel : 0 - 4 ( and 7 for the probe tip in Measure mode ) INA (Current/Power Monitor) - Examples : ina_get_current ( sensor ) - Read current in amps ina_get_voltage ( sensor ) - Read shunt voltage ina_get_bus_voltage ( sensor ) - Read bus voltage ina_get_power ( sensor ) - Read power in watts Aliases: get_current , get_voltage , get_bus_voltage , get_power sensor : 0 or 1 GPIO - Examples : gpio_set ( pin , value ) - Set GPIO pin state gpio_get ( pin ) - Read GPIO pin state gpio_set_dir ( pin , direction ) - Set GPIO pin direction gpio_get_dir ( pin ) - Get GPIO pin direction gpio_set_pull ( pin , pull ) - Set GPIO pull-up/down gpio_get_pull ( pin ) - Get GPIO pull-up/down Aliases: set_gpio , get_gpio , set_gpio_dir , get_gpio_dir , etc. pin 1 - 8 : GPIO 1 - 8 pin 9 : UART Tx pin 10 : UART Rx value : True / False for HIGH / LOW direction : True / False for OUTPUT / INPUT pull : - 1 / 0 / 1 for PULL_DOWN / NONE / PULL_UP PWM (Pulse Width Modulation) - Examples : pwm ( pin , [ frequency ], [ duty ]) - Setup PWM on GPIO pin pwm_set_duty_cycle ( pin , duty ) - Set PWM duty cycle pwm_set_frequency ( pin , freq ) - Set PWM frequency pwm_stop ( pin ) - Stop PWM on pin Aliases: set_pwm , set_pwm_duty_cycle , set_pwm_frequency , stop_pwm pin : 1 - 8 GPIO pins only frequency : 0.001 - 62500000 default 1000 Hz duty_cycle : 0.0 - 1.0 default 0.5 ( 50 % ) Frequency Ranges: Hardware PWM: 10Hz to 62.5MHz (high precision) Slow PWM: 0.001Hz to 10Hz (hardware timer based) Automatic mode selection based on frequency Node Connections - Examples : connect ( node1 , node2 , [ duplicates =- 1 ]) - Connect two nodes (duplicates: -1=add, 0=none, N=force N) disconnect ( node1 , node2 ) - Disconnect nodes fast_connect ( node1 , node2 , [ duplicates =- 1 ]) - Connect, skip LED update fast_disconnect ( node1 , node2 ) - Disconnect, skip LED update is_connected ( node1 , node2 ) - Check if nodes are connected nodes_clear () - Clear all connections nodes_save ([ slot ]) - Save connections to slot nodes_discard () - Discard unsaved changes nodes_has_changes () - Check for unsaved changes switch_slot ( slot ) - Switch to a different slot get_state () - Get complete board state as JSON string set_state ( json , [ clear_first = True ]) - Apply complete state from JSON string set node2 to - 1 to disconnect everything connected to node1 fast_ * functions skip LED computation ( not faster , just defer visual updates ) Net Information : get_net_name ( netNum ) - Get the name of a net set_net_name ( netNum , name ) - Set a custom net name get_net_color ( netNum ) - Get net color as 0xRRGGBB get_net_color_name ( netNum ) - Get net color as name string set_net_color ( netNum , color ) - Set net color by name or RGB set_net_color_hsv ( netNum , h , [ s ], [ v ]) - Set net color by HSV (auto-detects 0-1 or 0-255) get_num_nets () - Get number of active nets get_num_bridges () - Get number of bridges get_net_nodes ( netNum ) - Get comma-separated node list get_bridge ( bridgeIdx ) - Get bridge info tuple get_net_info ( netNum ) - Get full net info as dict Path Query API - Inspect routing internals: get_num_paths ([ include_duplicates ]) - Get number of routing paths get_path_info ( path_idx ) - Get detailed path info as dict get_all_paths () - Get all paths as list of dicts get_path_between ( node1 , node2 ) - Query specific path between nodes Fake GPIO (Virtual GPIO Pins) - Turn any routable node into GPIO: FakeGpioPin ( node , [ mode ], [ v_high ], [ v_low ]) - Create virtual GPIO pin . on () , pin . off () , pin . toggle () , pin . value ([ val ]) - Control pin Use any routable node ( breadboard , Arduino pins , special nodes ) Any voltage : - 8 V to + 8 V ( not limited to 3.3 V ) Perfect for RS - 485 , 5 V TTL , industrial protocols Graphic Overlays - Examples : overlay_set ( name , row , col , w , h , colors ) - Create/update overlay overlay_clear ( name ) - Remove overlay overlay_clear_all () - Remove all overlays overlay_shift ( name , dRow , dCol ) - Move overlay relative overlay_place ( name , row , col ) - Move overlay absolute overlay_set_pixel ( row , col , color ) - Set single pixel overlay_count () - Get active overlay count overlay_serialize () - Get overlays as YAML OLED Display - Examples : oled_print ( \"text\" ) - Display text oled_clear () - Clear display oled_connect () - Connect OLED oled_disconnect () - Disconnect OLED Status - Examples : print_bridges () - Print all bridges print_paths () - Print path between nodes print_crossbars () - Print crossbar array print_nets () - Print nets print_chip_status () - Print chip status Probe Functions - Examples : probe_read_blocking () - Wait for probe touch (don't return until a pad is touched) probe_read_nonblocking () - Check probe immediately (return -1 if no pad is touched) get_button ([ blocking = True ]) - Get button state (default: blocking) probe_button ([ blocking = True ]) - Get button state (default: blocking) probe_button_blocking () - Wait for button press probe_button_nonblocking () - Check buttons immediately check_button () - Check for probe button presses get_switch_position () - Get probe switch position (0=measure, 1=select, -1=unknown) set_switch_position ( position ) - Set switch position manually check_switch_position () - Check switch via current sensing Touch returns : ProbePad object ( 1 - 60 , D13_PAD , TOP_RAIL_PAD , LOGO_PAD_TOP , etc . ) Button returns : CONNECT , REMOVE , or NONE ( front = connect , rear = remove ) Switch returns : SWITCH_MEASURE ( 0 ), SWITCH_SELECT ( 1 ), SWITCH_UNKNOWN ( - 1 ) Clickwheel (Rotary Encoder): clickwheel_get_position () - Get raw position counter clickwheel_reset_position () - Reset position to 0 clickwheel_get_direction ([ consume ]) - Get direction event (NONE/UP/DOWN) clickwheel_get_button () - Get button state JFS (Jumperless File System): jfs . open ( path , mode ) - Opens file, returns file handle jfs . read ( file , size = 1024 ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . seek ( file , position , whence = 0 ) - Seek in file jfs . tell ( file ) - Get current position jfs . size ( file ) - Get file size jfs . available ( file ) - Get bytes available jfs . exists ( path ) - Check if path exists (returns True/False) jfs . listdir ( path ) - List directory contents (returns list) jfs . mkdir ( path ) - Create directory jfs . rmdir ( path ) - Remove directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename/move file jfs . stat ( path ) - Get file/directory status info jfs . info () - Returns (total, used, free) tuple Misc - Examples : arduino_reset () - Reset Arduino run_app ( 'appName' ) - Run app pause_core2 ( pause ) - Pause/resume core2 processing send_raw ( chip , x , y , setOrClear ) - Send raw data to core2 change_terminal_color ( color , [ flush ]) - Set terminal color (0-255) cycle_term_color ([ reset ], [ step ], [ flush ]) - Cycle through colors force_service ( name ) - Force run a service by name force_service_by_index ( idx ) - Force run service by index (faster) get_service_index ( name ) - Get service index for caching context_toggle () - Toggle connection context (global/python) context_get () - Get current context name Help - Examples : help () - Display help nodes_help () - Show available nodes and how to address them","title":"A Note on Usage"},{"location":"09.5-micropythonAPIreference/#node-connections","text":"These functions manage the connections between nodes on the breadboard and special function pins.","title":"Node Connections"},{"location":"09.5-micropythonAPIreference/#connectnode1-node2-duplicates-1","text":"Creates a bridge between two nodes. node1 , node2 : The nodes to connect. Can be integers, strings, or constants. duplicates (optional): Controls duplicate connection behavior: - 1 (default): Just add the connection without managing duplicates (standard behavior) 0 : Force exactly 0 duplicates (removes any existing duplicate paths) 1 + : Force exactly N duplicates (adds or removes connections to reach that count) Example: # Connect breadboard row 1 to row 30 connect ( 1 , 30 ) # Connect Arduino D13 to the top power rail connect ( D13 , TOP_RAIL ) # Connect GPIO 1 to ADC 0 using strings connect ( \"GPIO_1\" , \"ADC0\" ) # Duplicate management examples connect ( 1 , 5 , duplicates = 0 ) # Ensure no duplicate paths connect ( 1 , 5 , duplicates = 2 ) # Force exactly 2 parallel paths connect ( 1 , 5 ) # Standard: just add the connection","title":"connect(node1, node2, [duplicates=-1])"},{"location":"09.5-micropythonAPIreference/#disconnectnode1-node2","text":"Removes a specific bridge between two nodes. node1 , node2 : The two nodes to disconnect. To remove all connections from a single node, set node2 to - 1 . Example: # Remove the bridge between rows 1 and 30 disconnect ( 1 , 30 ) # Remove all connections from GPIO_1 disconnect ( GPIO_1 , - 1 ) <!-- ### fast_connect ( node1 , node2 , [ duplicates =- 1 ]) Connects two nodes while skipping LED computation . This function adds connections without updating LED state. It's not significantly faster overall, but it's useful when making many connections at once - you can defer LED updates until all connections are done. node1 , node2 : The nodes to connect. Can be integers, strings, or constants. duplicates (optional): Same behavior as connect () - see above for details. Example: # Make multiple connections without LED updates between each one for i in range ( 1 , 11 ): fast_connect ( i , i + 10 ) # LEDs update automatically when loop completes # With duplicate management fast_connect ( 1 , 5 , duplicates = 2 ) # Force 2 parallel paths, skip LED update","title":"disconnect(node1, node2)"},{"location":"09.5-micropythonAPIreference/#fast_disconnectnode1-node2","text":"Disconnects two nodes while skipping LED computation . Same LED-skipping behavior as fast_connect () . Useful for bulk disconnections. Example: # Bulk disconnections without LED updates for i in range ( 1 , 11 ): fast_disconnect ( i , i + 10 ) # LEDs update when loop completes ``` --> ### `is_connected(node1, node2)` Checks if a direct or indirect connection exists between two nodes . * Returns a custom ` ConnectionState ` object which evaluates to ` True ` if connected ( ` CONNECTED ` ) and ` False ` if not ( ` DISCONNECTED ` ) . ** Example : ** ``` jython if is_connected ( D13 , TOP_RAIL ): print ( \"D13 is connected to the top rail.\" ) state = is_connected ( 1 , 2 ) print ( state ) # Prints \"CONNECTED\" or \"DISCONNECTED\"","title":"fast_disconnect(node1, node2)"},{"location":"09.5-micropythonAPIreference/#nodes_clear","text":"Removes all connections from the board. Example: nodes_clear () print ( \"All connections cleared.\" )","title":"nodes_clear()"},{"location":"09.5-micropythonAPIreference/#nodename_or_id","text":"Creates a node object from a string name or integer ID. This is useful for storing a node reference in a variable. Node Type: Node objects support arithmetic and comparison operations with integers: Comparisons : == , != , < , <= , > , >= Arithmetic : + , - , * , // , % Conversions : int ( node ) converts to integer value Example: my_pin = node ( \"D7\" ) led_pin = node ( 15 ) connect ( my_pin , led_pin ) oled_print ( my_pin ) # Displays 'D7' on the OLED # Arithmetic and comparison work! if my_pin <= 20 : next_pin = my_pin + 1 # Returns int 8 connect ( next_pin , led_pin )","title":"node(name_or_id)"},{"location":"09.5-micropythonAPIreference/#nodes_saveslot","text":"Saves the current connections to a slot file. slot (optional): The slot number to save to. Defaults to the current active slot. Returns the slot number that was saved to. Example: # Save to current slot nodes_save () # Save to a specific slot nodes_save ( 3 )","title":"nodes_save([slot])"},{"location":"09.5-micropythonAPIreference/#nodes_discard","text":"Discards all unsaved changes and restores the last saved state. Example: connect ( 1 , 5 ) # Make a change nodes_discard () # Undo it","title":"nodes_discard()"},{"location":"09.5-micropythonAPIreference/#nodes_has_changes","text":"Checks if there are unsaved changes since the last save. Returns True if there are unsaved changes, False otherwise. Example: if nodes_has_changes (): print ( \"You have unsaved changes!\" )","title":"nodes_has_changes()"},{"location":"09.5-micropythonAPIreference/#switch_slotslot","text":"Switches to a different connection slot. slot : The slot number to switch to (0-7). Returns the previous slot number. Example: old_slot = switch_slot ( 2 ) # Switch to slot 2 print ( \"Was in slot: \" + str ( old_slot ))","title":"switch_slot(slot)"},{"location":"09.5-micropythonAPIreference/#get_state","text":"Returns the entire board state as a formatted JSON string. This includes nets, power settings, and GPIO configuration. Example: state_json = get_state () print ( state_json )","title":"get_state()"},{"location":"09.5-micropythonAPIreference/#set_statejson-clear_firsttrue","text":"Applies a board state from a JSON string. json : A JSON string representing the state (same format as returned by get_state () ). clear_first (optional): If True (default), clears all existing connections and FakeGPIO state before applying the new state. Set to False to merge the new state with the existing one. Example: # Apply a state from a string set_state ( '{\"nets\": [{\"index\": 1, \"name\": \"GND\", \"nodes\": [\"GND\"]}], \"power\": {\"top_rail\": 5.0}}' )","title":"set_state(json, [clear_first=True])"},{"location":"09.5-micropythonAPIreference/#net-information-api","text":"Functions for querying and modifying net metadata. Nets are groups of connected nodes.","title":"Net Information API"},{"location":"09.5-micropythonAPIreference/#get_net_namenetnum","text":"Gets the name of a specific net. netNum : The net number (0 to number of nets - 1). Returns the net name string, or None if the net doesn't exist. Example: name = get_net_name ( 0 ) print ( \"Net 0 is called: \" + str ( name ))","title":"get_net_name(netNum)"},{"location":"09.5-micropythonAPIreference/#set_net_namenetnum-name","text":"Sets a custom name for a net. netNum : The net number. name : The new name string. Pass empty string or None to reset to default. Example: set_net_name ( 0 , \"VCC\" ) set_net_name ( 1 , \"Signal_A\" )","title":"set_net_name(netNum, name)"},{"location":"09.5-micropythonAPIreference/#get_net_colornetnum","text":"Gets the color of a net as a 32-bit RGB value. netNum : The net number. Returns the color as 0 xRRGGBB . Example: color = get_net_color ( 0 ) print ( \"Net color: \" + hex ( color )) # e.g., \"0xff0000\" for red","title":"get_net_color(netNum)"},{"location":"09.5-micropythonAPIreference/#get_net_color_namenetnum","text":"Gets the color name of a net as a human-readable string. netNum : The net number. Returns a color name like \"red\", \"blue\", \"green\", etc. Example: color_name = get_net_color_name ( 0 ) print ( \"Net 0 is \" + color_name ) # e.g., \"Net 0 is red\"","title":"get_net_color_name(netNum)"},{"location":"09.5-micropythonAPIreference/#set_net_colornetnum-color-r-g-b","text":"Sets the color of a net by name, hex string, or RGB values. netNum : The net number. color : Color as a name (\"red\", \"blue\", \"pink\") or hex string (\"#FF0000\", \"0xFF0000\"). r , g , b (optional): If providing RGB values directly, pass them as separate arguments. Returns 1 on success, 0 on failure (invalid color). Available color names: red, orange, amber, yellow, chartreuse, green, seafoam, cyan, blue, royal blue, indigo, violet, purple, pink, magenta, brown, white, black, grey Example: # Set by color name set_net_color ( 0 , \"red\" ) set_net_color ( 1 , \"cyan\" ) # Set by hex string set_net_color ( 2 , \"#FF00FF\" ) # Magenta set_net_color ( 3 , \"0x00FF00\" ) # Green # Set by RGB values set_net_color ( 4 , 255 , 128 , 0 ) # Orange","title":"set_net_color(netNum, color, [r], [g], [b])"},{"location":"09.5-micropythonAPIreference/#set_net_color_hsvnetnum-h-s-v","text":"Sets the color of a net using HSV (Hue, Saturation, Value) color space. Automatically detects whether you're using normalized (0.0-1.0) or full-range (0-255) values based on the hue parameter. netNum : The net number. h : Hue value. If h is between 0.0-1.0, all HSV values are treated as normalized (0.0-1.0). Otherwise, values are treated as 0-255 range. s (optional): Saturation value. Defaults to maximum saturation (255) if not provided or negative. v (optional): Value/brightness. Defaults to 32 (reasonable LED brightness) if not provided or negative. Returns 1 on success, 0 on failure. Range auto-detection: - If h \u2264 1.0: Normalized mode (0.0-1.0 for all values) - If h > 1.0: Full-range mode (0-255 for all values) Default brightness (32): This provides good visibility without being overly bright. For maximum brightness, explicitly set v to 1.0 (normalized) or 255 (full-range). Example: # Normalized mode (0.0-1.0) - detected because h <= 1.0 set_net_color_hsv ( 0 , 0.0 ) # Pure red, max saturation, default brightness (32) set_net_color_hsv ( 1 , 0.33 ) # Green, max saturation, default brightness (32) set_net_color_hsv ( 2 , 0.66 ) # Blue, max saturation, default brightness (32) set_net_color_hsv ( 3 , 0.5 , 0.8 ) # Cyan with 80% saturation, default brightness (32) set_net_color_hsv ( 4 , 0.5 , 1.0 , 0.5 ) # Cyan with max saturation, 50% brightness set_net_color_hsv ( 5 , 0.0 , 1.0 , 1.0 ) # Pure red at MAXIMUM brightness (255) # Full-range mode (0-255) - detected because h > 1.0 set_net_color_hsv ( 6 , 0 ) # Pure red, max saturation, default brightness (32) set_net_color_hsv ( 7 , 85 ) # Green (85 \u2248 255/3), default brightness (32) set_net_color_hsv ( 8 , 170 ) # Blue (170 \u2248 2*255/3), default brightness (32) set_net_color_hsv ( 9 , 128 , 200 ) # Cyan-ish with 200/255 saturation, default brightness set_net_color_hsv ( 10 , 128 , 255 , 128 ) # Cyan with max saturation, 50% brightness set_net_color_hsv ( 11 , 128 , 255 , 255 ) # Cyan at MAXIMUM brightness (255) # Using all defaults (h only) set_net_color_hsv ( 12 , 0.25 ) # Yellow with full saturation, brightness 32 set_net_color_hsv ( 13 , 64 ) # Yellow in 0-255 mode, brightness 32 Why use HSV? HSV is often more intuitive for color selection than RGB: - Hue represents the actual color (red \u2192 yellow \u2192 green \u2192 cyan \u2192 blue \u2192 magenta \u2192 red) - Saturation controls color intensity (0 = grayscale, max = vivid color) - Value controls brightness (0 = black, max = full brightness)","title":"set_net_color_hsv(netNum, h, [s], [v])"},{"location":"09.5-micropythonAPIreference/#get_num_nets","text":"Gets the number of currently active nets. Returns an integer. Example: num = get_num_nets () print ( \"There are \" + str ( num ) + \" nets\" )","title":"get_num_nets()"},{"location":"09.5-micropythonAPIreference/#get_num_bridges","text":"Gets the total number of bridges (connections). Returns an integer. Example: num = get_num_bridges () print ( \"There are \" + str ( num ) + \" bridges\" )","title":"get_num_bridges()"},{"location":"09.5-micropythonAPIreference/#get_net_nodesnetnum","text":"Gets all nodes in a net as a comma-separated string. netNum : The net number. Returns a string like \"D13,TOP_RAIL,GPIO_1\". Example: nodes = get_net_nodes ( 0 ) print ( \"Net 0 contains: \" + nodes )","title":"get_net_nodes(netNum)"},{"location":"09.5-micropythonAPIreference/#get_bridgebridgeidx","text":"Gets information about a specific bridge. bridgeIdx : The bridge index (0 to number of bridges - 1). Returns a tuple ( node1 , node2 , duplicates ) . Example: bridge = get_bridge ( 0 ) print ( \"Bridge 0: \" + str ( bridge [ 0 ]) + \" to \" + str ( bridge [ 1 ]))","title":"get_bridge(bridgeIdx)"},{"location":"09.5-micropythonAPIreference/#get_net_infonetnum","text":"Gets comprehensive information about a net as a dictionary. netNum : The net number. Returns a dict with keys: name , number , color , color_name , nodes . Example: info = get_net_info ( 0 ) print ( \"Net name: \" + info [ 'name' ]) print ( \"Net color: \" + info [ 'color_name' ]) print ( \"Net nodes: \" + info [ 'nodes' ])","title":"get_net_info(netNum)"},{"location":"09.5-micropythonAPIreference/#path-query-api","text":"Functions for inspecting the internal routing paths between nodes. Paths represent the actual physical routes through the crossbar chips that connect nodes together.","title":"Path Query API"},{"location":"09.5-micropythonAPIreference/#understanding-paths-vs-bridges","text":"Bridges : Direct connections you create (e.g., connect ( 1 , 5 ) ) Paths : The actual routing through crossbar chips to implement those bridges A single bridge may require multiple paths through different chips. The path query API lets you inspect these internal routing details.","title":"Understanding Paths vs Bridges"},{"location":"09.5-micropythonAPIreference/#get_num_pathsinclude_duplicatestrue","text":"Gets the number of routing paths currently in use. include_duplicates (optional): If True (default), count all paths including duplicates. If False , count only primary (non-duplicate) paths. Returns an integer. Example: total = get_num_paths () # All paths including duplicates primary = get_num_paths ( False ) # Only primary paths print ( f \"Total paths: { total } , Primary: { primary } \" )","title":"get_num_paths([include_duplicates=True])"},{"location":"09.5-micropythonAPIreference/#get_path_infopath_idx","text":"Gets detailed information about a specific routing path. path_idx : The path index (0 to get_num_paths () - 1 ) Returns a dict with keys: node1 , node2 , net , chips , x , y , duplicate Returns None if index is invalid Example: path = get_path_info ( 0 ) if path : print ( f \"Path from { path [ 'node1' ] } to { path [ 'node2' ] } \" ) print ( f \"Uses chips: { path [ 'chips' ] } \" ) print ( f \"Is duplicate: { path [ 'duplicate' ] } \" )","title":"get_path_info(path_idx)"},{"location":"09.5-micropythonAPIreference/#get_all_paths","text":"Gets all routing paths as a list of dictionaries. Returns a list of path dicts (same format as get_path_info () ) Example: paths = get_all_paths () for i , path in enumerate ( paths ): print ( f \"Path { i } : { path [ 'node1' ] } -> { path [ 'node2' ] } via net { path [ 'net' ] } \" )","title":"get_all_paths()"},{"location":"09.5-micropythonAPIreference/#get_path_betweennode1-node2","text":"Queries the routing path between two specific nodes. node1 , node2 : The nodes to query Returns a path dict if found, None otherwise Example: path = get_path_between ( 1 , 5 ) if path : print ( f \"Route uses chips: { path [ 'chips' ] } \" ) print ( f \"Crossbar coordinates: x= { path [ 'x' ] } , y= { path [ 'y' ] } \" ) else : print ( \"No path found between nodes 1 and 5\" )","title":"get_path_between(node1, node2)"},{"location":"09.5-micropythonAPIreference/#dac-digital-to-analog-converter","text":"Functions for controlling the analog voltage outputs.","title":"DAC (Digital-to-Analog Converter)"},{"location":"09.5-micropythonAPIreference/#dac_setchannel-voltage-savetrue","text":"Sets the output voltage for a specific DAC channel. channel : The DAC channel to set. Can be an integer (0-3) or a node constant ( DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL ). voltage : The desired voltage (from -8.0V to 8.0V). save (optional): If True (default), the setting is saved to the config file. Aliases : set_dac () Channels: * 0 or DAC0 : The 5V tolerant DAC output. * 1 or DAC1 : The 8V tolerant DAC output. * 2 or TOP_RAIL : The top power rail. * 3 or BOTTOM_RAIL : The bottom power rail. Example: # Set the top rail to 5V dac_set ( TOP_RAIL , 5.0 ) # Set DAC0 to 1.25V set_dac ( DAC0 , 1.25 )","title":"dac_set(channel, voltage, [save=True])"},{"location":"09.5-micropythonAPIreference/#dac_getchannel","text":"Reads the currently set voltage for a DAC channel. channel : The DAC channel to read. Returns a float. Aliases : get_dac () Example: voltage = dac_get ( TOP_RAIL ) print ( \"Top Rail voltage: \" + str ( voltage ))","title":"dac_get(channel)"},{"location":"09.5-micropythonAPIreference/#adc-analog-to-digital-converter","text":"Functions for measuring analog voltages.","title":"ADC (Analog-to-Digital Converter)"},{"location":"09.5-micropythonAPIreference/#adc_getchannel","text":"Reads the voltage from a specific ADC channel. channel : The ADC channel to read (0-4). Returns a float. Aliases : get_adc () Channels: 0 - 3 : 8V tolerant ADC inputs. 4 : 5V tolerant ADC input. Example: voltage = adc_get ( 0 ) print ( \"ADC0 voltage: \" + str ( voltage ))","title":"adc_get(channel)"},{"location":"09.5-micropythonAPIreference/#graphic-overlays","text":"Functions for creating and manipulating 2D color overlays on the breadboard LEDs. The breadboard is addressed as a 10-row \u00d7 30-column grid : * Row 1-5 : Top half (A-E) * Row 6-10 : Bottom half (F-J) * Column 1-30 : Breadboard columns 1-30","title":"Graphic Overlays"},{"location":"09.5-micropythonAPIreference/#overlay_setname-x-y-height-width-colors","text":"Creates or updates a graphic overlay. name : Unique string identifier for the overlay. x : Starting column ( 1-30 ). Matches breadboard column labels. y : Starting row ( 1-10 ). 1-5 = Top half (A-E), 6-10 = Bottom half (F-J). height : Height in rows (y-dimension). width : Width in columns (x-dimension). colors : List of 32-bit integer colors (0xRRGGBB). Can be a flat list or 2D list (rows). Returns the overlay index. Note: If you pass a 2D array (list of lists) for colors , the outer list represents rows (height) and the inner lists represent columns (width). Make sure your width and height arguments match the data shape. Example: # Create a 5-wide, 2-high overlay at x=2, y=5 # x=2 (Column 2), y=5 (Row 5/E) colors_2d = [ [ 0x550000 , 0x550000 , 0x550000 , 0x550000 , 0x550000 ], # Row 0 [ 0x550000 , 0x550000 , 0x550000 , 0x550000 , 0x550000 ] # Row 1 ] overlay_set ( \"box_2d\" , 12 , 5 , 2 , 5 , colors_2d )","title":"overlay_set(name, x, y, height, width, colors)"},{"location":"09.5-micropythonAPIreference/#overlay_clearname","text":"Removes a specific overlay. name : The identifier of the overlay to remove. Returns 1 if found/removed, 0 otherwise.","title":"overlay_clear(name)"},{"location":"09.5-micropythonAPIreference/#overlay_clear_all","text":"Removes ALL active overlays.","title":"overlay_clear_all()"},{"location":"09.5-micropythonAPIreference/#overlay_shiftname-dx-dy","text":"Moves an overlay by a relative offset. Wraps around edges. name : Overlay identifier. dx : Column delta (e.g., 1 for right, -1 for left). dy : Row delta (e.g., 1 for down, -1 for up). Returns 1 if found, 0 otherwise.","title":"overlay_shift(name, dx, dy)"},{"location":"09.5-micropythonAPIreference/#overlay_placename-x-y","text":"Moves an overlay to a specific absolute position. Wraps around edges. name : Overlay identifier. x : New column ( 1-30 ). y : New row ( 1-10 ). Returns 1 if found, 0 otherwise. Example: # Use the probe to move the box overlay import jumperless as j import time colors_2d = [ [ 0x550000 , 0x104000 , 0x005500 , 0x001040 , 0x000055 ], # Row 0 [ 0x550000 , 0x104000 , 0x005500 , 0x001040 , 0x000055 ], # Row 1 ] j . overlay_set ( \"box_2d\" , 12 , 5 , 2 , 5 , colors_2d ) while True : node = j . probe_read_blocking () j . overlay_place ( \"box_2d\" , node , 5 ) time . sleep ( 0.1 )","title":"overlay_place(name, x, y)"},{"location":"09.5-micropythonAPIreference/#overlay_set_pixelx-y-color","text":"Sets a single pixel directly (convenience wrapper). x : Column (1-30). y : Row (1-10). color : 0xRRGGBB color.","title":"overlay_set_pixel(x, y, color)"},{"location":"09.5-micropythonAPIreference/#overlay_serialize","text":"Returns the current state of all overlays as a JSON string.","title":"overlay_serialize()"},{"location":"09.5-micropythonAPIreference/#gpio-general-purpose-inputoutput","text":"Functions for controlling the digital I/O pins.","title":"GPIO (General Purpose Input/Output)"},{"location":"09.5-micropythonAPIreference/#gpio_setpin-value","text":"Sets the output state of a GPIO pin. pin : The GPIO pin number (1-10). value : True for HIGH, False for LOW. Aliases : set_gpio ()","title":"gpio_set(pin, value)"},{"location":"09.5-micropythonAPIreference/#gpio_getpin","text":"Reads the state of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIOState object ( HIGH , LOW , or FLOATING ). Aliases : get_gpio ()","title":"gpio_get(pin)"},{"location":"09.5-micropythonAPIreference/#gpio_set_dirpin-direction","text":"Sets the direction of a GPIO pin. pin : The GPIO pin number (1-10). direction : True for OUTPUT, False for INPUT. Aliases : set_gpio_dir ()","title":"gpio_set_dir(pin, direction)"},{"location":"09.5-micropythonAPIreference/#gpio_get_dirpin","text":"Reads the direction of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIODirection object ( INPUT or OUTPUT ). Aliases : get_gpio_dir ()","title":"gpio_get_dir(pin)"},{"location":"09.5-micropythonAPIreference/#gpio_set_pullpin-pull","text":"Configures the internal pull resistor for a GPIO pin. pin : The GPIO pin number (1-10). pull : 1 for PULLUP, - 1 for PULLDOWN, 0 for NONE. Aliases : set_gpio_pull ()","title":"gpio_set_pull(pin, pull)"},{"location":"09.5-micropythonAPIreference/#gpio_get_pullpin","text":"Reads the pull resistor configuration of a GPIO pin. pin : The GPIO pin number (1-10). Returns a GPIOPull object ( PULLUP , PULLDOWN , or NONE ). Aliases : get_gpio_pull ()","title":"gpio_get_pull(pin)"},{"location":"09.5-micropythonAPIreference/#gpio_set_read_floatingpin-enabled","text":"Enable or disable special floating detection when reading GPIO inputs. These are all enabled by default. pin : The GPIO pin number (1-10). enabled : True to enable floating-read behavior, False to disable. Aliases : set_gpio_read_floating () Description: When enabled, the firmware performs an extra floating-detection check so gpio_get () can return FLOATING for very-high-impedance inputs. To do this it momentarily biases the pin with a very weak internal pull-up (~50 k\u03a9) while sampling. That transient bias can affect extremely high\u2011impedance sources (for example, >10 M\u03a9 sensors) and may cause a small leakage current or change the measured state. If your external circuit is super high\u2011impedance, either disable floating-read for that pin or add a defined pull resistor.","title":"gpio_set_read_floating(pin, enabled)"},{"location":"09.5-micropythonAPIreference/#gpio_get_read_floatingpin","text":"Returns whether floating-read detection is enabled for a GPIO pin. pin : The GPIO pin number (1-10). Returns: True if floating-read is enabled, otherwise False . Aliases : get_gpio_read_floating () Example: # Enable floating detection on GPIO 3 gpio_set_read_floating ( 3 , True ) # Confirm it is enabled print ( gpio_get_read_floating ( 3 )) # True or False # If a connected high\u2011impedance sensor behaves oddly, disable floating-read gpio_set_read_floating ( 3 , False ) Pinout: * 1 - 8 : Routable GPIO pins GPIO_1 to GPIO_8 . * 9 : UART_TX . * 10 : UART_RX . Example: # Set GPIO 1 as an output and turn it on gpio_set_dir ( 1 , True ) gpio_set ( 1 , True ) # Set GPIO 2 as an input with a pull-up gpio_set_dir ( 2 , False ) gpio_set_pull ( 2 , 1 ) # Read the state of GPIO 2 state = gpio_get ( 2 ) if state : # GPIOState is truthy when HIGH, falsy when LOW or FLOATING print ( \"GPIO 2 is HIGH\" ) # You can also print it directly - shows \"HIGH\", \"LOW\", or \"FLOATING\" print ( \"State: \" + str ( state ))","title":"gpio_get_read_floating(pin)"},{"location":"09.5-micropythonAPIreference/#pwm-pulse-width-modulation","text":"Functions for generating PWM signals on GPIO pins.","title":"PWM (Pulse-Width Modulation)"},{"location":"09.5-micropythonAPIreference/#pwmpin-frequency-duty_cycle","text":"Sets up and starts a PWM signal on a GPIO pin. pin : The GPIO pin to use (1-8). frequency (optional): The PWM frequency in Hz (0.001 to 62500000). Defaults to 1000. duty_cycle (optional): The duty cycle from 0.0 to 1.0. Defaults to 0.5. Aliases : set_pwm () Frequency Ranges: Hardware PWM : 10Hz to 62.5MHz (high precision, hardware peripheral) Slow PWM : 0.001Hz to 10Hz (hardware timer based, precise timing) Automatic Selection : System automatically chooses the appropriate mode based on frequency","title":"pwm(pin, [frequency], [duty_cycle])"},{"location":"09.5-micropythonAPIreference/#pwm_set_duty_cyclepin-duty_cycle","text":"Changes the duty cycle of an existing PWM signal. pin : The GPIO pin number (1-8). duty_cycle : The new duty cycle (0.0 to 1.0). Aliases : set_pwm_duty_cycle ()","title":"pwm_set_duty_cycle(pin, duty_cycle)"},{"location":"09.5-micropythonAPIreference/#pwm_set_frequencypin-frequency","text":"Changes the frequency of an existing PWM signal. pin : The GPIO pin number (1-8). frequency : The new frequency in Hz (0.001 to 62500000). Aliases : set_pwm_frequency ()","title":"pwm_set_frequency(pin, frequency)"},{"location":"09.5-micropythonAPIreference/#pwm_stoppin","text":"Stops the PWM signal on a GPIO pin. pin : The GPIO pin number (1-8). Aliases : stop_pwm () Example: # Hardware PWM: 1kHz, 25% duty cycle on GPIO_1 pwm ( GPIO_1 , 1000 , 0.25 ) # Slow PWM: 0.1Hz (10 second period), 50% duty cycle on GPIO_2 pwm ( GPIO_2 , 0.1 , 0.5 ) # Ultra-slow PWM: 0.001Hz (1000 second period), 25% duty cycle on GPIO_3 pwm ( GPIO_3 , 0.001 , 0.25 ) # Change the duty cycle to 75% pwm_set_duty_cycle ( GPIO_1 , 0.75 ) # Change frequency (will automatically switch between hardware/slow PWM) pwm_set_frequency ( GPIO_1 , 500 ) # 500Hz (hardware PWM) pwm_set_frequency ( GPIO_1 , 5 ) # 5Hz (slow PWM) # Stop the PWM signal pwm_stop ( GPIO_1 )","title":"pwm_stop(pin)"},{"location":"09.5-micropythonAPIreference/#wavegen-waveform-generator","text":"Functions for generating analog waveforms on DAC outputs. Setters: wavegen_set_output ( output ) - Select output: DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL (default DAC1 ) wavegen_set_freq ( hz ) - Set frequency: 0.0001\u201310000.0 Hz (default 100 Hz) wavegen_set_wave ( shape ) - Set waveform shape (see constants below) wavegen_set_sweep ( start_hz , end_hz , seconds ) - Configure a linear sweep wavegen_set_amplitude ( vpp ) - 0.0\u201316.0 Vpp (default 3.3 Vpp) wavegen_set_offset ( v ) - -8.0\u2013+8.0 V (default 1.65 V for 0\u20133.3 V centered) wavegen_start ([ run = True ]) - Start/stop output; calling with False stops wavegen_stop () - Stop output immediately Getters: wavegen_get_output () - Get current output channel wavegen_get_freq () - Get current frequency wavegen_get_wave () - Get current waveform wavegen_get_amplitude () - Get current amplitude (Vpp) wavegen_get_offset () - Get current offset wavegen_is_running () - Check if wavegen is active Aliases: All setters/getters have set_wavegen_ * and get_wavegen_ * aliases. Waveform Constants: SINE (0) - Sine wave TRIANGLE (1) - Triangle wave SAWTOOTH (2) - Sawtooth/ramp wave RAMP (2) - Alias for SAWTOOTH SQUARE (3) - Square wave ARBITRARY (4) - Arbitrary waveform (not yet implemented) Example: # Generate a 100Hz sine wave on DAC1 wavegen_set_output ( DAC1 ) wavegen_set_wave ( SINE ) wavegen_set_freq ( 100 ) wavegen_set_amplitude ( 3.3 ) # 3.3V peak-to-peak wavegen_set_offset ( 1.65 ) # Center at 1.65V (0-3.3V range) wavegen_start () # Check if running if wavegen_is_running (): print ( \"Wavegen active at \" + str ( wavegen_get_freq ()) + \"Hz\" ) # Change waveform while running wavegen_set_wave ( TRIANGLE ) # Stop wavegen_stop () Notes: - Wavegen runs on core 2 and is fully blocking while active; LEDs and routing updates pause until wavegen_stop () . - Frequency, waveform, amplitude, and offset can be changed live while running.","title":"WaveGen (Waveform Generator)"},{"location":"09.5-micropythonAPIreference/#ina-currentpower-monitor","text":"Functions for reading data from the INA219 current sensors.","title":"INA (Current/Power Monitor)"},{"location":"09.5-micropythonAPIreference/#ina_get_currentsensor","text":"Reads the current in Amps. * sensor : The sensor to read (0 or 1). * Aliases : get_current ()","title":"ina_get_current(sensor)"},{"location":"09.5-micropythonAPIreference/#ina_get_voltagesensor","text":"Reads the shunt voltage in Volts. * sensor : The sensor to read (0 or 1). * Aliases : get_voltage ()","title":"ina_get_voltage(sensor)"},{"location":"09.5-micropythonAPIreference/#ina_get_bus_voltagesensor","text":"Reads the bus voltage in Volts. * sensor : The sensor to read (0 or 1). * Aliases : get_bus_voltage ()","title":"ina_get_bus_voltage(sensor)"},{"location":"09.5-micropythonAPIreference/#ina_get_powersensor","text":"Reads the power in Watts. * sensor : The sensor to read (0 or 1). * Aliases : get_power () Example: current_mA = ina_get_current ( 0 ) * 1000 print ( \"Current: \" + str ( current_mA ) + \" mA\" )","title":"ina_get_power(sensor)"},{"location":"09.5-micropythonAPIreference/#oled-display","text":"Functions for controlling the onboard OLED display with advanced text, graphics, and bitmap capabilities.","title":"OLED Display"},{"location":"09.5-micropythonAPIreference/#basic-display-functions","text":"","title":"Basic Display Functions"},{"location":"09.5-micropythonAPIreference/#oled_printtext-size-1","text":"Displays text on the OLED screen. It can print strings, numbers, and custom Jumperless types. text : The content to display. size (optional): Text size (0=small scrolling, 1=normal, 2=large). If -1 or omitted, uses the default size set by oled_set_text_size () . Defaults to 2. Size Modes: - Size 0 : Small scrolling text (perfect for terminal-like output with multiple lines) - Size 1 : Normal centered text - Size 2 : Large centered text (default) Example: oled_print ( \"Hello!\" ) # Uses default size oled_print ( \"Big Text\" , 2 ) # Large text oled_print ( \"Scrolling\" , 0 ) # Small scrolling text","title":"oled_print(text, [size=-1])"},{"location":"09.5-micropythonAPIreference/#oled_clearshowtrue","text":"Clears the OLED display. show (optional): If True (default), automatically calls oled_show () after clearing. Set to False for animations to avoid flashing between frames. Example: # Normal use - clears and shows oled_clear () # Animation loop - clear without showing to prevent flashing for frame in range ( 100 ): oled_clear ( False ) # Clear without show # Draw your frame... oled_show () # Show once after drawing","title":"oled_clear([show=True])"},{"location":"09.5-micropythonAPIreference/#oled_show","text":"Refreshes the OLED display to show the latest changes. Note: Usually not needed as oled_print () handles display updates automatically. Required after oled_set_pixel () calls.","title":"oled_show()"},{"location":"09.5-micropythonAPIreference/#oled_connect","text":"Connects the I2C lines to the OLED display.","title":"oled_connect()"},{"location":"09.5-micropythonAPIreference/#oled_disconnect","text":"Disconnects the I2C lines from the OLED display.","title":"oled_disconnect()"},{"location":"09.5-micropythonAPIreference/#text-size-control","text":"","title":"Text Size Control"},{"location":"09.5-micropythonAPIreference/#oled_set_text_sizesize","text":"Set the default text size for all subsequent oled_print () calls. size : Text size (0=small scrolling, 1=normal, 2=large) Returns: True if successful, False if invalid size Example: import jumperless as j # Use small scrolling text for terminal output j . oled_set_text_size ( 0 ) for i in range ( 10 ): j . oled_print ( f \"Line { i + 1 } \" ) # Each creates a new scrolling line # Switch to large text j . oled_set_text_size ( 2 ) j . oled_print ( \"BIG TEXT\" )","title":"oled_set_text_size(size)"},{"location":"09.5-micropythonAPIreference/#oled_get_text_size","text":"Get the current default text size. Returns: Current text size (0, 1, or 2) Example: current_size = oled_get_text_size () print ( f \"Current OLED text size: { current_size } \" )","title":"oled_get_text_size()"},{"location":"09.5-micropythonAPIreference/#print-redirection","text":"","title":"Print Redirection"},{"location":"09.5-micropythonAPIreference/#oled_copy_printenable","text":"Enable or disable copying Python print () output to the OLED display in real-time. When enabled, all print () statements will appear on both the serial console and the OLED in small scrolling text mode. This is perfect for debugging without a serial connection. enable : True to enable, False to disable Example: import jumperless as j # Enable print copying j . oled_copy_print ( True ) # These appear on both serial AND OLED print ( \"Starting test...\" ) voltage = j . adc_get ( 0 ) print ( f \"Voltage: { voltage : .2f } V\" ) print ( \"Test complete!\" ) # Disable print copying j . oled_copy_print ( False ) print ( \"This only goes to serial\" )","title":"oled_copy_print(enable)"},{"location":"09.5-micropythonAPIreference/#font-system","text":"","title":"Font System"},{"location":"09.5-micropythonAPIreference/#oled_get_fonts","text":"Get a list of all available font families. Returns: List of font family names (strings) Available Fonts: Eurostyle - sans serif, futuristic, like Xenon pinball or Star Trek Jokerman - decorative font with lots of extra artistic dots and bars Comic Sans - sans serif, comic book style lettering Courier New - slab serif, typewriter style New Science - sans serif, humanist/geometric, like Helvetica New Science Ext - wider version of New Science Iosevka Regular - fixed spacing sans serif, like Lucida, slashed zero Berkeley Mono - fixed spacing, sans serif, large X height Pragmatism - sans serif, vaguely romantic Andale Mono - fixed spacing sans serif, used for small text (Descriptions by MadBodger) Example: import jumperless as j import time fonts = j . oled_get_fonts () print ( f \"Available fonts: { fonts } \" ) # Display each font for font in fonts : j . oled_set_font ( font ) j . oled_print ( font , 2 ) time . sleep ( 1.5 )","title":"oled_get_fonts()"},{"location":"09.5-micropythonAPIreference/#oled_set_fontname","text":"Set the current font family by name. The font will remain active until changed. name : Font family name (case-insensitive) Returns: True if successful, False if font not found Example: import jumperless as j # Set to Jokerman if j . oled_set_font ( \"Jokerman\" ): j . oled_print ( \"Fun Font!\" , 2 ) else : print ( \"Font not found\" ) # Set to Courier for code-like display j . oled_set_font ( \"Courier New\" ) j . oled_print ( \"Code Style\" , 2 )","title":"oled_set_font(name)"},{"location":"09.5-micropythonAPIreference/#oled_get_current_font","text":"Get the name of the currently active font family. Returns: Current font family name (string) Example: import jumperless as j current = j . oled_get_current_font () print ( f \"Current font: { current } \" ) # Save and restore font saved_font = j . oled_get_current_font () j . oled_set_font ( \"Jokerman\" ) j . oled_print ( \"Temporary\" , 2 ) j . oled_set_font ( saved_font ) # Restore original","title":"oled_get_current_font()"},{"location":"09.5-micropythonAPIreference/#bitmap-display","text":"","title":"Bitmap Display"},{"location":"09.5-micropythonAPIreference/#oled_load_bitmapfilepath","text":"Load a bitmap file into the internal bitmap buffer. filepath : Path to bitmap file (e.g., \"/images/logo.bin\") Returns: True if loaded successfully, False on error Bitmap File Format: Raw Format : Pure bitmap data (guesses dimensions from file size) 128x32 = 512 bytes 128x64 = 1024 bytes 64x32 = 256 bytes Custom Format : 4-byte header + bitmap data Bytes 0-1: Width (16-bit little-endian) Bytes 2-3: Height (16-bit little-endian) Remaining: Bitmap data (1 bit per pixel, packed) Example: if oled_load_bitmap ( \"/images/jogo32h.bin\" ): print ( \"Logo loaded!\" ) else : print ( \"Failed to load logo\" )","title":"oled_load_bitmap(filepath)"},{"location":"09.5-micropythonAPIreference/#oled_display_bitmapx-y-width-height-datanone","text":"Display a bitmap on the OLED. Two modes: Use loaded bitmap : If data is None , displays the bitmap from oled_load_bitmap () Direct data : If data is provided, displays that bitmap immediately x : X position on display (0-127) y : Y position on display (0-31) width : Bitmap width in pixels (ignored if using loaded bitmap) height : Bitmap height in pixels (ignored if using loaded bitmap) data (optional): Bitmap data to display directly Returns: True if successful, False on error Example: import jumperless as j # Method 1: Load then display j . oled_load_bitmap ( \"/images/logo.bin\" ) j . oled_display_bitmap ( 0 , 0 , 0 , 0 ) # width/height ignored for loaded bitmap # Method 2: Display direct data bitmap_data = bytes ([ 0xFF , 0x00 , 0xFF , 0x00 ] * 128 ) # Striped pattern j . oled_display_bitmap ( 0 , 0 , 128 , 32 , bitmap_data )","title":"oled_display_bitmap(x, y, width, height, [data=None])"},{"location":"09.5-micropythonAPIreference/#oled_show_bitmap_filefilepath-x-y","text":"Convenience function that loads and displays a bitmap in one call. filepath : Path to bitmap file x : X position on display y : Y position on display Returns: True if successful, False on error Example: import jumperless as j import time # One-liner to show a logo j . oled_show_bitmap_file ( \"/images/jogo32h.bin\" , 0 , 0 ) time . sleep ( 2 ) # Show another image j . oled_show_bitmap_file ( \"/images/badge.bin\" , 32 , 8 )","title":"oled_show_bitmap_file(filepath, x, y)"},{"location":"09.5-micropythonAPIreference/#framebuffer-and-pixel-manipulation","text":"The framebuffer functions provide low-level access to the display memory, enabling advanced graphics, animations, and screen capture. Framebuffer Format: - 1 bit per pixel (0=black/off, 1=white/on) - Organized in vertical bytes (8 pixels per byte) - Size: 512 bytes (128x32) or 1024 bytes (128x64) - Compatible with Adafruit SSD1306 format","title":"Framebuffer and Pixel Manipulation"},{"location":"09.5-micropythonAPIreference/#oled_get_framebuffer","text":"Get a copy of the current OLED framebuffer as a bytes object. Returns: Framebuffer data as bytes (512 or 1024 bytes depending on display size)","title":"oled_get_framebuffer()"},{"location":"09.5-micropythonAPIreference/#oled_set_framebufferdata","text":"Set the entire OLED framebuffer from bytes or bytearray. data : Framebuffer data (must be correct size for display) Returns: True if successful, False if wrong size Example: import jumperless as j import time # Capture current display fb = j . oled_get_framebuffer () print ( f \"Framebuffer size: { len ( fb ) } bytes\" ) # Save to file for later with open ( \"/screen_capture.bin\" , \"wb\" ) as f : f . write ( fb ) j . oled_clear () time . sleep ( 2 ) # Load and display saved screen with open ( \"/screen_capture.bin\" , \"rb\" ) as f : fb_data = f . read () if j . oled_set_framebuffer ( fb_data ): print ( \"Screen restored!\" ) else : print ( \"Wrong framebuffer size\" )","title":"oled_set_framebuffer(data)"},{"location":"09.5-micropythonAPIreference/#oled_get_framebuffer_size","text":"Get the dimensions and size of the framebuffer. Returns: Tuple of ( width , height , buffer_size_in_bytes ) Example: width , height , size = oled_get_framebuffer_size () print ( f \"Display: { width } x { height } , { size } bytes\" ) # Output: Display: 128x32, 512 bytes # Calculate pixels total_pixels = width * height print ( f \"Total pixels: { total_pixels } \" )","title":"oled_get_framebuffer_size()"},{"location":"09.5-micropythonAPIreference/#oled_set_pixelx-y-color","text":"Set a single pixel on the OLED. Note: Call oled_show () after setting pixels to make changes visible. x : X coordinate (0 to width-1) y : Y coordinate (0 to height-1) color : Pixel color (0=black/off, 1=white/on) Returns: True if successful, False if OLED not connected Example: import jumperless as j # Draw a diagonal line j . oled_clear () for i in range ( 32 ): j . oled_set_pixel ( i , i , 1 ) j . oled_show () # Draw a box for x in range ( 20 , 108 ): j . oled_set_pixel ( x , 10 , 1 ) # Top edge j . oled_set_pixel ( x , 22 , 1 ) # Bottom edge for y in range ( 10 , 23 ): j . oled_set_pixel ( 20 , y , 1 ) # Left edge j . oled_set_pixel ( 107 , y , 1 ) # Right edge j . oled_show ()","title":"oled_set_pixel(x, y, color)"},{"location":"09.5-micropythonAPIreference/#oled_get_pixelx-y","text":"Get the color value of a single pixel. x : X coordinate (0 to width-1) y : Y coordinate (0 to height-1) Returns: Pixel color (0=black/off, 1=white/on, -1=error) Example: # Check if a pixel is set pixel = oled_get_pixel ( 64 , 16 ) if pixel == 1 : print ( \"Pixel is white/on\" ) elif pixel == 0 : print ( \"Pixel is black/off\" ) else : print ( \"Error reading pixel\" )","title":"oled_get_pixel(x, y)"},{"location":"09.5-micropythonAPIreference/#advanced-oled-examples","text":"","title":"Advanced OLED Examples"},{"location":"09.5-micropythonAPIreference/#debug-output-to-oled","text":"import jumperless as j import time # Enable print copying for debugging j . oled_copy_print ( True ) # Your code with debug output for i in range ( 10 ): voltage = j . adc_get ( 0 ) print ( f \"V { i } : { voltage : .2f } V\" ) time . sleep ( 0.5 ) j . oled_copy_print ( False )","title":"Debug Output to OLED"},{"location":"09.5-micropythonAPIreference/#simple-oscilloscope","text":"import jumperless as j import math import time # Clear display j . oled_clear () width , height , _ = j . oled_get_framebuffer_size () j . connect ( j . ADC0 , 11 ) # Draw sine wave animation for offset in range ( 100 ): j . oled_clear ( False ) # Don't show() after clear to avoid flashing # Draw axes for x in range ( width ): if ( x % 4 == 0 ): j . oled_set_pixel ( x , height // 2 , 1 ) # Dotted center line # Draw sine wave for x in range ( width ): # y = int(height//2 + 10 * math.sin((x + offset) / 10)) # Dummy sine wave y = int ( j . get_adc ( 0 )) + 16 if 0 <= y < height : j . oled_set_pixel ( x , y , 1 ) # time.sleep_ms(10) j . oled_show () time . sleep ( 0.005 )","title":"Simple Oscilloscope"},{"location":"09.5-micropythonAPIreference/#screen-capture-and-manipulation","text":"import jumperless as j import time # Capture screen fb = j . oled_get_framebuffer () # Invert all pixels inverted = bytearray ( fb ) for i in range ( len ( inverted )): inverted [ i ] = ~ inverted [ i ] & 0xFF # Display inverted j . oled_set_framebuffer ( inverted ) time . sleep ( 1 ) # Restore original j . oled_set_framebuffer ( fb )","title":"Screen Capture and Manipulation"},{"location":"09.5-micropythonAPIreference/#terminal-like-output","text":"import jumperless as j import time # Use small scrolling text j . oled_set_text_size ( 0 ) j . oled_clear () for i in range ( 20 ): j . oled_print ( f \"Line { i } \" ) time . sleep ( 0.2 )","title":"Terminal-like Output"},{"location":"09.5-micropythonAPIreference/#font-showcase","text":"import jumperless as j import time for font in j . oled_get_fonts (): j . oled_set_font ( font ) j . oled_print ( font , 2 ) time . sleep ( 1.5 )","title":"Font Showcase"},{"location":"09.5-micropythonAPIreference/#probe","text":"Functions for interacting with the physical probe.","title":"Probe"},{"location":"09.5-micropythonAPIreference/#probe_readblockingtrue","text":"Reads the pad currently being touched by the probe. blocking (optional): If True (default), the function will wait until a pad is touched. If False , it returns immediately. Returns a ProbePad object (e.g., 25 , D13_PAD , NO_PAD ). Aliases : read_probe () , probe_read_blocking () , probe_read_nonblocking () , probe_wait () , wait_probe () , probe_touch () , wait_touch () ProbePad Type: ProbePad objects support arithmetic and comparison operations with integers: Comparisons : == , != , < , <= , > , >= Arithmetic : + , - , * , // , % Conversions : int ( pad ) converts to integer value Example: pad = probe_read ( False ) # Non-blocking if pad != NO_PAD : print ( pad ) if pad <= 60 : # Compare with integer node_1 = pad node_2 = pad + 3 # Arithmetic with integer if node_2 > 60 : # Works! node_2 -= 60 connect ( node_1 , node_2 )","title":"probe_read([blocking=True])"},{"location":"09.5-micropythonAPIreference/#probe_buttonblockingtrue-consumefalse","text":"Reads the state of the buttons on the probe. blocking (optional): If True (default), waits for a button press. If False , returns the current state immediately. consume (optional): If True , clears the button press after reading (one-shot detection). If False (default), the button state persists while held, allowing repeated reads in a loop. Returns a ProbeButton object ( CONNECT_BUTTON , REMOVE_BUTTON , or BUTTON_NONE ). Aliases : get_button () , button_read () , read_button () , probe_button_blocking () , probe_button_nonblocking () , check_button () , button_check () Consume Behavior: consume = False (default): Holding the button returns the same state repeatedly - ideal for continuous control (e.g., incrementing values while held) consume = True : Each button press is detected only once - ideal for menu navigation or one-shot actions Example: # Continuous control - hold button to keep changing hue while True : button = check_button () # consume=False by default if button == BUTTON_CONNECT : hue += 1 # Keeps incrementing while button is held set_net_color_hsv ( 0 , hue ) elif button == BUTTON_REMOVE : hue -= 1 # Keeps decrementing while button is held set_net_color_hsv ( 0 , hue ) time . sleep ( 0.05 ) # One-shot detection - each press counted once presses = 0 while presses < 5 : button = get_button ( consume = True ) # Each press consumed if button == BUTTON_CONNECT : presses += 1 print ( f \"Press # { presses } \" ) Example: print ( \"Touch a pad...\" ) pad = probe_read () print ( \"You touched: \" + str ( pad )) if pad == D13_PAD : print ( \"That's the Arduino LED pin!\" ) print ( \"Press a probe button...\" ) button = get_button () if button == CONNECT_BUTTON : print ( \"Connect button pressed.\" )","title":"probe_button([blocking=True], [consume=False])"},{"location":"09.5-micropythonAPIreference/#get_switch_position","text":"Gets the current probe switch position. Returns: 0 (SWITCH_MEASURE), 1 (SWITCH_SELECT), or - 1 (SWITCH_UNKNOWN) Example: position = get_switch_position () if position == SWITCH_MEASURE : print ( \"Probe is in measure mode\" ) elif position == SWITCH_SELECT : print ( \"Probe is in select mode\" )","title":"get_switch_position()"},{"location":"09.5-micropythonAPIreference/#set_switch_positionposition","text":"Manually sets the probe switch position. position : 0 (SWITCH_MEASURE), 1 (SWITCH_SELECT), or - 1 (SWITCH_UNKNOWN) Example: set_switch_position ( SWITCH_SELECT ) # Force select mode","title":"set_switch_position(position)"},{"location":"09.5-micropythonAPIreference/#check_switch_position","text":"Checks the probe switch position using current sensing and updates the internal state. Returns: Updated switch position Uses hysteresis thresholds to prevent oscillation between modes: - Switches to SELECT when current > high threshold - Switches to MEASURE when current < low threshold Example: # Periodically check and respond to switch changes while True : position = check_switch_position () if position == SWITCH_MEASURE : voltage = measureMode () print ( f \"Voltage: { voltage } V\" ) elif position == SWITCH_SELECT : pad = probe_read ( blocking = False ) if pad != NO_PAD : print ( f \"Touched: { pad } \" ) time . sleep ( 0.1 )","title":"check_switch_position()"},{"location":"09.5-micropythonAPIreference/#clickwheel","text":"Functions for reading the rotary encoder (clickwheel) position, direction, and button state.","title":"Clickwheel"},{"location":"09.5-micropythonAPIreference/#clickwheel_get_position","text":"Gets the raw clickwheel position counter. Returns: Current position value (integer, can be positive or negative) The position accumulates as you turn the clickwheel - clockwise increases, counter-clockwise decreases. Example: pos = clickwheel_get_position () print ( f \"Current position: { pos } \" )","title":"clickwheel_get_position()"},{"location":"09.5-micropythonAPIreference/#clickwheel_reset_position","text":"Resets the clickwheel position counter to 0. Example: clickwheel_reset_position () assert clickwheel_get_position () == 0","title":"clickwheel_reset_position()"},{"location":"09.5-micropythonAPIreference/#clickwheel_get_directionconsumetrue","text":"Gets the current clickwheel direction event. consume (optional): If True (default), clears the direction after reading (one-shot detection). If False , the direction persists until consumed. Returns: CLICKWHEEL_NONE (0), CLICKWHEEL_UP (1), or CLICKWHEEL_DOWN (2) Important: The direction state persists until consumed! This means you won't miss turn events even if you don't check every loop iteration. The UP or DOWN state stays active until you read it with consume = True . Example (One-shot - Default): direction = clickwheel_get_direction () # consume=True (default) if direction == CLICKWHEEL_UP : value += 1 # Only increments once per turn event print ( f \"Turned up: { value } \" ) elif direction == CLICKWHEEL_DOWN : value -= 1 # Only decrements once per turn event print ( f \"Turned down: { value } \" ) Example (Persistent - Check Multiple Times): # Check direction without consuming direction = clickwheel_get_direction ( consume = False ) if direction == CLICKWHEEL_UP : print ( \"Turning clockwise...\" ) # Do some work... # Check again - still UP until consumed! if clickwheel_get_direction ( consume = False ) == CLICKWHEEL_UP : print ( \"Still turning up!\" ) # Finally consume it clickwheel_get_direction ( consume = True )","title":"clickwheel_get_direction([consume=True])"},{"location":"09.5-micropythonAPIreference/#clickwheel_get_button","text":"Gets the current clickwheel button state. Returns: CLICKWHEEL_IDLE (0) - Not pressed CLICKWHEEL_PRESSED (1) - Just pressed CLICKWHEEL_HELD (2) - Being held down CLICKWHEEL_RELEASED (3) - Just released CLICKWHEEL_DOUBLECLICKED (4) - Double-clicked Example: button = clickwheel_get_button () if button == CLICKWHEEL_PRESSED : print ( \"Button pressed!\" ) elif button == CLICKWHEEL_HELD : print ( \"Button held down\" ) elif button == CLICKWHEEL_DOUBLECLICKED : print ( \"Double click!\" ) Complete Example - Menu Navigation: import jumperless as j import time menu_items = [ \"Option 1\" , \"Option 2\" , \"Option 3\" , \"Option 4\" ] selected = 0 j . clickwheel_reset_position () while True : # Check direction (consume=True by default - one turn = one event) direction = j . clickwheel_get_direction () if direction == j . CLICKWHEEL_UP : selected = ( selected + 1 ) % len ( menu_items ) print ( f \"> { menu_items [ selected ] } \" ) elif direction == j . CLICKWHEEL_DOWN : selected = ( selected - 1 ) % len ( menu_items ) print ( f \"> { menu_items [ selected ] } \" ) # Check button button = j . clickwheel_get_button () if button == j . CLICKWHEEL_PRESSED : print ( f \"Selected: { menu_items [ selected ] } \" ) elif button == j . CLICKWHEEL_DOUBLECLICKED : print ( \"Exit menu\" ) break # Note: Direction persists, so even with slow polling (50ms), # you won't miss turn events! time . sleep ( 0.05 ) Example - Value Adjustment with Persistence: import jumperless as j import time value = 50 while True : # Check direction without consuming direction = j . clickwheel_get_direction ( consume = False ) if direction == j . CLICKWHEEL_UP : value = min ( 100 , value + 1 ) j . oled_print ( f \"Value: { value } \" , 2 ) time . sleep ( 0.1 ) # Delay for visual feedback # Consume after displaying j . clickwheel_get_direction ( consume = True ) elif direction == j . CLICKWHEEL_DOWN : value = max ( 0 , value - 1 ) j . oled_print ( f \"Value: { value } \" , 2 ) time . sleep ( 0.1 ) j . clickwheel_get_direction ( consume = True ) # Exit on button press if j . clickwheel_get_button () == j . CLICKWHEEL_PRESSED : break time . sleep ( 0.01 )","title":"clickwheel_get_button()"},{"location":"09.5-micropythonAPIreference/#fake-gpio-virtual-gpio-pins","text":"Fake GPIO uses the Jumperless' internal crossbar switches to create virtual GPIO pins on any routable node. Unlike the RP2350's hardware GPIO (limited to 10 routable pins at 0-3.3V), Fake GPIO lets you use any node with custom voltage levels from -8V to +8V, or as inputs, you can have as many as you like and the ADC will switch to that node and take a reading on demand. This is still pretty new and will probably change in the future Note: Fake GPIO Outputs are currently disabled until I fix the code, they were causing dead shorts between supplies","title":"Fake GPIO (Virtual GPIO Pins)"},{"location":"09.5-micropythonAPIreference/#why-use-fake-gpio","text":"The RP2350's hardware GPIO is limited to 10 routable pins (GPIO_1 through GPIO_8, plus UART TX/RX) with fixed 3.3V logic levels. Fake GPIO extends this by using the crossbar switching matrix to create virtual GPIO pins on any routable node with configurable voltage levels. <!-- Pin Expansion: Any routable node can function as a virtual GPIO pin, including breadboard nodes (1-60) and Arduino pins (D0-D13, A0-A7). The ADC dynamically switches to INPUT pins on demand for reading, allowing an unlimited number of inputs. Voltage Range: Output voltages from -8V to +8V are supported by routing between voltage sources (TOP_RAIL, BOTTOM_RAIL, GND, DAC0, DAC1). This enables: RS-485/RS-422 differential signaling (\u00b18V) 5V TTL logic compatibility Bipolar signal generation","title":"Why Use Fake GPIO?"},{"location":"09.5-micropythonAPIreference/#configuring-output-pins","text":"FakeGpioPin ( node , j . OUTPUT , high_source , low_source ) Creates a digital output that switches between two voltage sources. Parameters: node (int, required): Any routable node - breadboard holes (1-60), Arduino pins (D0-D13, A0-A7), special nodes mode (constant, required): j . OUTPUT high_source (node, optional): Voltage source for HIGH state (default: j . TOP_RAIL ) low_source (node, optional): Voltage source for LOW state (default: j . GND ) Valid voltage sources: j . TOP_RAIL , j . BOTTOM_RAIL , j . GND , j . DAC0 , j . DAC1 Returns: FakeGpioPin object Examples: import jumperless as j # Simple output (TOP_RAIL and GND) led = j . FakeGpioPin ( 10 , j . OUTPUT ) led . on () # HIGH (TOP_RAIL voltage) led . off () # LOW (GND = 0V) # RS-485 differential signaling (\u00b18V) j . rails_set ( 8.0 , - 8.0 ) # TOP=+8V, BOTTOM=-8V rs485_a = j . FakeGpioPin ( 25 , j . OUTPUT , j . TOP_RAIL , j . BOTTOM_RAIL ) rs485_b = j . FakeGpioPin ( 26 , j . OUTPUT , j . BOTTOM_RAIL , j . TOP_RAIL ) rs485_a . on () # A: +8V, B: -8V (differential high) rs485_a . off () # A: -8V, B: +8V (differential low) # Multiple pins sharing voltage sources outputs = [] for node in [ 30 , 31 , 32 , 33 ]: pin = j . FakeGpioPin ( node , j . OUTPUT , j . TOP_RAIL , j . GND ) outputs . append ( pin ) # All pins safely share TOP_RAIL and GND! ``` --> ### Configuring INPUT Pins ``` python FakeGpioPin ( node , j . INPUT , threshold_high , threshold_low ) Creates a digital input that reads voltage via the ADC. Parameters: node (int, required): Any routable node to read from mode (constant, required): j . INPUT threshold_high (float, optional): Input HIGH threshold in volts (default: 2.0) threshold_low (float, optional): Input LOW threshold in volts (default: 0.8) Returns: FakeGpioPin object Example: import jumperless as j # Read a digital signal button = j . FakeGpioPin ( 20 , j . INPUT ) state = button . value () # Returns 0 or 1 # Custom thresholds for 5V logic signal_5v = j . FakeGpioPin ( 25 , j . INPUT , 3.5 , 1.5 ) if signal_5v . value (): print ( \"5V logic HIGH detected\" )","title":"Configuring OUTPUT Pins"},{"location":"09.5-micropythonAPIreference/#fakegpiopin-methods","text":"","title":"FakeGpioPin Methods"},{"location":"09.5-micropythonAPIreference/#pinon","text":"Sets OUTPUT pin to HIGH state (connects high_source ).","title":"pin.on()"},{"location":"09.5-micropythonAPIreference/#pinoff","text":"Sets OUTPUT pin to LOW state (connects low_source ).","title":"pin.off()"},{"location":"09.5-micropythonAPIreference/#pintoggle","text":"Toggles OUTPUT pin between HIGH and LOW states.","title":"pin.toggle()"},{"location":"09.5-micropythonAPIreference/#pinvalueval","text":"For OUTPUT: Gets or sets the pin value (0 or 1). For INPUT: Reads the current pin state (0 or 1). # Basic usage pin = j . FakeGpioPin ( 20 ) pin . on () # HIGH pin . off () # LOW pin . toggle () # Switch state # Using value() pin . value ( 1 ) # Set HIGH pin . value ( 0 ) # Set LOW state = pin . value () # Read current state","title":"pin.value([val])"},{"location":"09.5-micropythonAPIreference/#system-functions","text":"","title":"System Functions"},{"location":"09.5-micropythonAPIreference/#arduino_reset","text":"Resets the connected Arduino Nano.","title":"arduino_reset()"},{"location":"09.5-micropythonAPIreference/#run_appappname","text":"Launches a built-in Jumperless application. appName : The name of the app to run (e.g., \"File Manager\", \"I2C Scan\").","title":"run_app(appName)"},{"location":"09.5-micropythonAPIreference/#pause_core2pause","text":"Pauses or resumes core2 processing. pause : True to pause core2, False to resume. For doing time sensitive things where you don't want core 2 to cause timing glitches while it periodically updates the LEDs. Core 2 will resume when you exit the REPL no matter what.","title":"pause_core2(pause)"},{"location":"09.5-micropythonAPIreference/#send_rawchip-x-y-setorclear","text":"Sends raw data to core2 for direct chip control. chip : Chip identifier (string, e.g., \"A\", \"B\", \"C\"). x , y : Coordinates for the operation. setOrClear : 1 to set, 0 to clear. You should probably be looking at the schematic if you use this. By bypassing all the routing logic, you can make or break connections in ~1 \u00b5s. Pretty handy if want to do high speed switching between known states.","title":"send_raw(chip, x, y, setOrClear)"},{"location":"09.5-micropythonAPIreference/#change_terminal_colorcolor-flushtrue","text":"Sets the terminal text color using 256-color ANSI codes. color : Color index (0-255), or -1 to reset to default flush (optional): Flush output immediately (default: True ) This is the 6x6x6 color cube that terminals use: Example: change_terminal_color ( 196 ) # Bright red print ( \"Error message\" ) change_terminal_color ( - 1 ) # Reset to default change_terminal_color ( 46 ) # Cyan print ( \"Info message\" )","title":"change_terminal_color(color, [flush=True])"},{"location":"09.5-micropythonAPIreference/#cycle_term_colorresetfalse-step10-flushtrue","text":"Cycles through the terminal color palette. reset (optional): If True , reset to start of color sequence step (optional): Color increment step (defaults to the last one you set) flush (optional): Flush output immediately (default: True ) Useful for creating rainbow effects or visually distinguishing output sections. This is really just a helper function for me, it only uses a subset of the colors (I think ~44 of them?) above that actually look good. It takes a float so you can use fractional values if you have more than 44 things and you want a smooth spectrum. This doesn't currently work in Viper IDE because it strips the escape sequences Example: cycle_term_color ( True , 1.5 ) # Start fresh for i in range ( 10 ): cycle_term_color () # Next color print ( f \"Line { i } in different color\" ) # Visual separator in help output cycle_term_color ( True , step = 5.0 )","title":"cycle_term_color([reset=False], [step=1.0], [flush=True])"},{"location":"09.5-micropythonAPIreference/#force_servicename","text":"Forces immediate execution of a specific system service by name. name : Service name as a string (e.g., \"ProbeButton\" , \"Peripherals\" ). Returns: True if service was found and executed, False otherwise. Useful for manually triggering specific services during tight loops where automatic service scheduling might not run frequently enough. Example: while True : # Fast loop that might miss automatic service updates connect ( 1 , 2 ) force_service ( \"ProbeButton\" ) # Ensure button state updates button = check_button () time . sleep ( 0.001 )","title":"force_service(name)"},{"location":"09.5-micropythonAPIreference/#force_service_by_indexindex","text":"Forces immediate execution of a specific system service by index (faster than name lookup). index : Service index (integer, obtained via get_service_index () ). Returns: True if index valid and service executed, False otherwise. Example: # Cache the index once for maximum speed btn_idx = get_service_index ( \"ProbeButton\" ) while True : connect ( 1 , 2 ) force_service_by_index ( btn_idx ) # Fastest way to force service button = check_button () time . sleep ( 0.001 )","title":"force_service_by_index(index)"},{"location":"09.5-micropythonAPIreference/#get_service_indexname","text":"Gets the index of a service by name for use with force_service_by_index () . name : Service name as a string. Returns: Service index (integer, 0 or higher), or - 1 if not found. Cache the returned index for repeated fast calls to force_service_by_index () . Example: # Look up once, use many times probe_idx = get_service_index ( \"ProbeButton\" ) if probe_idx >= 0 : # Use the cached index in your loop force_service_by_index ( probe_idx )","title":"get_service_index(name)"},{"location":"09.5-micropythonAPIreference/#context_toggle","text":"Toggles the connection context between global and python modes. In global mode: Connection changes persist after exiting Python. In python mode: Connection state is restored when you exit the REPL. Example: context_toggle () # Switch from global to python (or vice versa) print ( \"Now in \" + context_get () + \" mode\" )","title":"context_toggle()"},{"location":"09.5-micropythonAPIreference/#context_get","text":"Gets the current connection context name. Returns \"global\" or \"python\" . Example: if context_get () == \"global\" : print ( \"Changes will persist after exit\" ) else : print ( \"Changes will be discarded on exit\" )","title":"context_get()"},{"location":"09.5-micropythonAPIreference/#status-functions","text":"These functions print detailed status information to the serial console. print_bridges () : Prints all active bridges. print_paths () : Prints all resolved paths between nodes. print_crossbars () : Prints the raw state of the crossbar matrix. print_nets () : Prints the current net list. print_chip_status () : Prints the status of the CH446Q chips.","title":"Status Functions"},{"location":"09.5-micropythonAPIreference/#help-functions","text":"","title":"Help Functions"},{"location":"09.5-micropythonAPIreference/#help","text":"Displays a comprehensive list of all available functions and constants in the jumperless module. You can also pass it sections, so help ( \"GPIO\" ) will just print that section.","title":"help()"},{"location":"09.5-micropythonAPIreference/#nodes_help","text":"Displays a detailed reference for all available node names and their aliases.","title":"nodes_help()"},{"location":"09.5-micropythonAPIreference/#node-names-and-constants","text":"The Jumperless module provides extensive node name support with multiple aliases for each node: # Power rails (multiple aliases supported) TOP_RAIL = 101 # Also: TOPRAIL, T_R, TOP_R BOTTOM_RAIL = 102 # Also: BOT_RAIL, BOTTOMRAIL, BOTRAIL, B_R, BOT_R SUPPLY_3V3 = 103 # Also: 3V3, 3.3V SUPPLY_5V = 105 # Also: 5V, +5V SUPPLY_8V_P = 120 # Also: 8V_P, 8V_POS SUPPLY_8V_N = 121 # Also: 8V_N, 8V_NEG # Ground connections GND = 100 # Also: GROUND TOP_RAIL_GND = 104 # Also: TOP_GND (not actually routable but included for PADs) BOTTOM_RAIL_GND = 126 # Also: BOT_GND, BOTTOM_GND (not actually routable but included for PADs) # DAC outputs DAC0 = 106 # Also: DAC_0, DAC0_5V DAC1 = 107 # Also: DAC_1, DAC1_8V # ADC inputs ADC0 = 110 # Also: ADC_0, ADC0_8V ADC1 = 111 # Also: ADC_1, ADC1_8V ADC2 = 112 # Also: ADC_2, ADC2_8V ADC3 = 113 # Also: ADC_3, ADC3_8V ADC4 = 114 # Also: ADC_4, ADC4_5V ADC7 = 115 # Also: ADC_7, ADC7_PROBE, PROBE # Current sensing ISENSE_PLUS = 108 # Also: ISENSE_POS, ISENSE_P, INA_P, I_P, CURRENT_SENSE_PLUS, ISENSE_POSITIVE, I_POS ISENSE_MINUS = 109 # Also: ISENSE_NEG, ISENSE_N, INA_N, I_N, CURRENT_SENSE_MINUS, ISENSE_NEGATIVE, I_NEG # GPIO pins (multiple naming conventions) GPIO_1 = 131 # Also: RP_GPIO_1, GPIO1, GP_1, GP1 GPIO_2 = 132 # Also: RP_GPIO_2, GPIO2, GP_2, GP2 GPIO_3 = 133 # Also: RP_GPIO_3, GPIO3, GP_3, GP3 GPIO_4 = 134 # Also: RP_GPIO_4, GPIO4, GP_4, GP4 GPIO_5 = 135 # Also: RP_GPIO_5, GPIO5, GP_5, GP5 GPIO_6 = 136 # Also: RP_GPIO_6, GPIO6, GP_6, GP6 GPIO_7 = 137 # Also: RP_GPIO_7, GPIO7, GP_7, GP7 GPIO_8 = 138 # Also: RP_GPIO_8, GPIO8, GP_8, GP8 # UART pins UART_TX = 116 # Also: RP_UART_TX, TX, RP_GPIO_16 UART_RX = 117 # Also: RP_UART_RX, RX, RP_GPIO_17 # Additional RP GPIOs RP_GPIO_18 = 118 # Also: GP_18 RP_GPIO_19 = 119 # Also: GP_19 # Buffer connections BUFFER_IN = 139 # Also: ROUTABLE_BUFFER_IN, BUF_IN, BUFF_IN, BUFFIN BUFFER_OUT = 140 # Also: ROUTABLE_BUFFER_OUT, BUF_OUT, BUFF_OUT, BUFFOUT # Arduino Nano pins (extensive support) D13 = 83 # Also: NANO_D13 D12 = 82 # Also: NANO_D12 D11 = 81 # Also: NANO_D11 D10 = 80 # Also: NANO_D10 D9 = 79 # Also: NANO_D9 D8 = 78 # Also: NANO_D8 D7 = 77 # Also: NANO_D7 D6 = 76 # Also: NANO_D6 D5 = 75 # Also: NANO_D5 D4 = 74 # Also: NANO_D4 D3 = 73 # Also: NANO_D3 D2 = 72 # Also: NANO_D2 D1 = 71 # Also: NANO_D1 D0 = 70 # Also: NANO_D0 # Arduino Nano analog pins A0 = 86 # Also: NANO_A0 A1 = 87 # Also: NANO_A1 A2 = 88 # Also: NANO_A2 A3 = 89 # Also: NANO_A3 A4 = 90 # Also: NANO_A4 A5 = 91 # Also: NANO_A5 A6 = 92 # Also: NANO_A6 A7 = 93 # Also: NANO_A7 # Arduino Nano non-routable hardwired connections VIN = 69 # Unconnected to anything RST0 = 94 # Hardwired to GPIO 18 on the RP2350 RST1 = 95 # Hardwired to GPIO 19 on the RP2350 N_GND0 = 97 # GND N_GND1 = 96 # GND NANO_5V = 99 # Hardwired to USB 5V bus (can also be used to power the Jumperless) NANO_3V3 = 98 # Unconnected (without bridging the solder jumper on the back) # Probe switch position constants SWITCH_MEASURE = 0 # Probe in measure mode SWITCH_SELECT = 1 # Probe in select mode SWITCH_UNKNOWN = - 1 # Position unknown # Clickwheel direction constants CLICKWHEEL_NONE = 0 # No movement CLICKWHEEL_UP = 1 # Turned clockwise CLICKWHEEL_DOWN = 2 # Turned counter-clockwise # Clickwheel button state constants CLICKWHEEL_IDLE = 0 # Not pressed CLICKWHEEL_PRESSED = 1 # Just pressed CLICKWHEEL_HELD = 2 # Being held down CLICKWHEEL_RELEASED = 3 # Just released CLICKWHEEL_DOUBLECLICKED = 4 # Double-clicked","title":"Node Names and Constants"},{"location":"09.5-micropythonAPIreference/#the-entire-output-of-help","text":">>> help () Jumperless Native MicroPython Module Available help sections : help () or help ( \"all\" ) - Show all functions help ( \"DAC\" ) - DAC functions help ( \"ADC\" ) - ADC functions help ( \"GPIO\" ) - GPIO functions help ( \"PWM\" ) - PWM functions help ( \"WAVEGEN\" ) - Waveform generator help ( \"INA\" ) - INA current / power monitor help ( \"NODES\" ) - Node connections help ( \"NETS\" ) - Net info ( names , colors ) help ( \"SLOTS\" ) - Slot management help ( \"OLED\" ) - OLED display help ( \"PROBE\" ) - Probe and button functions help ( \"CLICKWHEEL\" ) - Clickwheel ( rotary encoder ) functions help ( \"FAKEGPIO\" ) - Fake GPIO ( virtual GPIO pins ) help ( \"STATUS\" ) - Status and debug functions help ( \"FILESYSTEM\" ) - Filesystem functions help ( \"MISC\" ) - Miscellaneous functions help ( \"EXAMPLES\" ) - Usage examples DAC ( Digital - to - Analog Converter ): dac_set ( channel , voltage ) - Set DAC output voltage dac_get ( channel ) - Get DAC output voltage set_dac ( channel , voltage ) - Alias for dac_set get_dac ( channel ) - Alias for dac_get channel : 0 - 3 , DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL channel 0 / DAC0 : DAC 0 channel 1 / DAC1 : DAC 1 channel 2 / TOP_RAIL : top rail channel 3 / BOTTOM_RAIL : bottom rail voltage : - 8.0 to 8.0 V ADC ( Analog - to - Digital Converter ): adc_get ( channel ) - Read ADC input voltage get_adc ( channel ) - Alias for adc_get channel : 0 - 4 GPIO : gpio_set ( pin , value ) - Set GPIO pin state gpio_get ( pin ) - Read GPIO pin state gpio_set_dir ( pin , direction ) - Set GPIO pin direction gpio_get_dir ( pin ) - Get GPIO pin direction gpio_set_pull ( pin , pull ) - Set GPIO pull - up / down gpio_get_pull ( pin ) - Get GPIO pull - up / down Aliases : set_gpio , get_gpio , set_gpio_dir , get_gpio_dir , etc . pin 1 - 8 : GPIO 1 - 8 pin 9 : UART Tx pin 10 : UART Rx value : True / False for HIGH / LOW direction : True / False for OUTPUT / INPUT pull : - 1 / 0 / 1 / 2 for PULLDOWN / NO_PULL / PULLUP / BUS_KEEPER PWM ( Pulse Width Modulation ): pwm ( pin , [ frequency ], [ duty ]) - Setup PWM on GPIO pin pwm_set_duty_cycle ( pin , duty ) - Set PWM duty cycle pwm_set_frequency ( pin , freq ) - Set PWM frequency pwm_stop ( pin ) - Stop PWM on pin Aliases : set_pwm , set_pwm_duty_cycle , set_pwm_frequency , stop_pwm pin : 1 - 8 GPIO pins only frequency : 0.001 Hz - 62.5 MHz default 1000 Hz duty_cycle : 0.0 - 1.0 default 0.5 ( 50 % ) WaveGen ( Waveform Generator ): wavegen_set_output ( channel ) - Set output : DAC0 , DAC1 , TOP_RAIL , BOTTOM_RAIL wavegen_set_freq ( hz ) - Set frequency ( 0.0001 - 10000 Hz ) wavegen_set_wave ( shape ) - Set waveform shape wavegen_set_amplitude ( vpp ) - Set amplitude ( 0 - 16 Vpp ) wavegen_set_offset ( v ) - Set DC offset ( - 8 to + 8 V ) wavegen_start () - Start waveform generation wavegen_stop () - Stop waveform generation Getters : wavegen_get_output (), wavegen_get_freq (), wavegen_get_wave (), wavegen_get_amplitude (), wavegen_get_offset (), wavegen_is_running () Waveform constants : SINE , TRIANGLE , SAWTOOTH ( RAMP ), SQUARE INA ( Current / Power Monitor ): ina_get_current ( sensor ) - Read current in amps ina_get_voltage ( sensor ) - Read shunt voltage ina_get_bus_voltage ( sensor ) - Read bus voltage ina_get_power ( sensor ) - Read power in watts Aliases : get_current , get_voltage , get_bus_voltage , get_power sensor : 0 or 1 Node Connections : connect ( node1 , node2 , [ duplicates =- 1 ]) - Connect two nodes disconnect ( node1 , node2 ) - Disconnect nodes fast_connect ( node1 , node2 , [ duplicates =- 1 ]) - Connect , skip LED update fast_disconnect ( node1 , node2 ) - Disconnect , skip LED update is_connected ( node1 , node2 ) - Check if nodes are connected nodes_clear () - Clear all connections set node2 to - 1 to disconnect everything connected to node1 duplicates : - 1 ( add ), 0 ( no duplicates ), N ( force N duplicates ) fast_ * functions skip LED computation ( defer visual updates ) Net Information : get_net_name ( netNum ) - Get net name set_net_name ( netNum , name ) - Set custom net name get_net_color ( netNum ) - Get net color as 0 xRRGGBB get_net_color_name ( netNum ) - Get net color name set_net_color ( netNum , color ) - Set net color by name or hex set_net_color_hsv ( netNum , h , [ s ], [ v ]) - Set by HSV ( auto - detects range ) get_num_nets () - Get number of active nets get_num_bridges () - Get number of bridges get_net_nodes ( netNum ) - Get comma - separated node list get_bridge ( bridgeIdx ) - Get bridge info tuple get_net_info ( netNum ) - Get full net info as dict Colors : red , orange , yellow , green , cyan , blue , purple , pink , etc . HSV : h = 0.0 - 1.0 or 0 - 255 ( auto ), s = 0 - 1 / 0 - 255 ( default max ), v = 0 - 1 / 0 - 255 ( default 32 ) Path Query API : get_num_paths ([ include_duplicates ]) - Get number of routing paths get_path_info ( path_idx ) - Get detailed path info as dict get_all_paths () - Get all paths as list of dicts get_path_between ( node1 , node2 ) - Query specific path between nodes Inspect internal routing through crossbar chips Slot Management : nodes_save ([ slot ]) - Save connections to slot nodes_discard () - Discard unsaved changes nodes_has_changes () - Check for unsaved changes switch_slot ( slot ) - Switch to different slot ( 0 - 7 ) CURRENT_SLOT - Get current slot number Context ( controls persistence ): context_toggle () - Toggle global / python mode context_get () - Get current mode name OLED Display : oled_print ( \"text\" ) - Display text oled_clear () - Clear display oled_connect () - Connect OLED oled_disconnect () - Disconnect OLED Probe Functions : probe_read ([ blocking = True ]) - Read probe ( default : blocking ) read_probe ([ blocking = True ]) - Read probe ( default : blocking ) probe_read_blocking () - Wait for probe touch ( explicit ) probe_read_nonblocking () - Check probe immediately ( explicit ) get_button ([ blocking ], [ consume ]) - Get button ( blocking = True , consume = False ) probe_button ([ blocking ], [ consume ]) - Get button ( blocking = True , consume = False ) check_button ([ consume ]) - Check button non - blocking ( consume = False ) probe_button_blocking ([ consume ]) - Wait for button ( consume = False ) probe_button_nonblocking ([ consume ]) - Check button immediate ( consume = False ) consume = False ( default ): Holding button returns same state ( continuous control ) consume = True : Each press detected once ( one - shot detection ) Probe Switch Functions : get_switch_position () - Get current switch position set_switch_position ( pos ) - Set switch position manually check_switch_position () - Check switch via current sensing Touch returns : ProbePad object ( 1 - 60 , D13_PAD , TOP_RAIL_PAD , LOGO_PAD_TOP , etc . ) Button returns : CONNECT , REMOVE , or NONE ( front = connect , rear = remove ) Switch returns : SWITCH_MEASURE ( 0 ), SWITCH_SELECT ( 1 ), SWITCH_UNKNOWN ( - 1 ) Clickwheel ( Rotary Encoder ): clickwheel_get_position () - Get raw position counter clickwheel_reset_position () - Reset position to 0 clickwheel_get_direction ([ consume = True ]) - Get direction event clickwheel_get_button () - Get button state clickwheel_is_initialized () - Check if clickwheel is ready consume = True ( default ): Direction cleared after reading ( one - shot detection ) consume = False : Direction persists until consumed ( can read multiple times ) Direction returns : CLICKWHEEL_NONE ( 0 ), CLICKWHEEL_UP ( 1 ), CLICKWHEEL_DOWN ( 2 ) Button returns : CLICKWHEEL_IDLE ( 0 ), CLICKWHEEL_PRESSED ( 1 ), CLICKWHEEL_HELD ( 2 ), CLICKWHEEL_RELEASED ( 3 ), CLICKWHEEL_DOUBLECLICKED ( 4 ) Fake GPIO ( Virtual GPIO Pins ): FakeGpioPin ( node , [ mode ], [ v_high ], [ v_low ]) - Create virtual GPIO on any breadboard node pin . on () - Set HIGH ( v_high voltage ) pin . off () - Set LOW ( v_low voltage ) pin . toggle () - Toggle HIGH / LOW pin . value ([ val ]) - Get / set value ( 0 or 1 ) Why use Fake GPIO ? \u2022 More pins : Use any routable node ( breadboard , Arduino pins , special nodes ) \u2022 Any voltage : - 8 V to + 8 V ( not limited to 3.3 V ) \u2022 Industrial protocols : RS - 485 ( \u00b1 8 V ), 5 V TTL , custom logic levels Mode constants : OUTPUT , INPUT Status : print_bridges () - Print all bridges print_paths () - Print path between nodes print_crossbars () - Print crossbar array print_nets () - Print nets print_chip_status () - Print chip status Filesystem : jfs . open ( path , mode ) - Open file jfs . read ( file , size ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . exists ( path ) - Check if file exists jfs . listdir ( path ) - List directory jfs . mkdir ( path ) - Create directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename file jfs . info () - Get filesystem info Misc : arduino_reset () - Reset Arduino run_app ( appName ) - Run built - in app pause_core2 ( pause ) - Pause / unpause Core2 ( True / False ) send_raw ( chip , x , y , set ) - Send raw data to crossbar chip change_terminal_color ( color , [ flush ]) - Set terminal color ( 0 - 255 ) cycle_term_color ([ reset ], [ step ], [ flush ]) - Cycle through colors force_service ( name ) - Force run a specific service ( e . g . , \"ProbeButton\" ) force_service_by_index ( idx ) - Force run service by index ( faster ) get_service_index ( name ) - Get service index by name ( cache for fast calls ) Examples ( all functions available globally ): dac_set ( DAC0 , 5.0 ) # Set DAC0 using node constant voltage = get_adc ( 1 ) # Read ADC1 using alias connect ( TOP_RAIL , D13 ) # Connect using constants connect ( 4 , 20 , duplicates = 2 ) # Force 2 parallel paths fast_connect ( 1 , 5 ) # Connect without LED update top_rail = node ( \"TOP_RAIL\" ) # Create node object oled_print ( \"Hello!\" ) # Display text on OLED current = get_current ( 0 ) # Read current using alias set_gpio ( 1 , True ) # Set GPIO pin high pwm ( 1 , 1000 , 0.5 ) # 1kHz PWM, 50% duty wavegen_set_wave ( SINE ); wavegen_start () # Start sine wave set_net_color ( 0 , \"red\" ) # Color net 0 red set_net_color_hsv ( 1 , 0.5 ) # Cyan net 1 (HSV hue) nodes_save () # Save current connections pad = probe_read () # Wait for probe touch button = get_button () # Wait for button press pos = clickwheel_get_position () # Get encoder position direction = clickwheel_get_direction () # Get turn direction change_terminal_color ( 196 ) # Set red text cycle_term_color () # Next color path = get_path_between ( 1 , 5 ) # Query routing path led = FakeGpioPin ( 25 ) # Virtual GPIO on breadboard node led . toggle () # Digital switching rs485 = FakeGpioPin ( 20 , OUTPUT , 8.0 , - 8.0 ) # RS-485 \u00b18V signal >>>","title":"The entire output of help()"},{"location":"09.5-micropythonAPIreference/#the-entire-output-of-nodes_help","text":">>> nodes_help () Jumperless Node Reference ======================== NODE TYPES : Numbered : 1 - 60 ( breadboard ) Arduino : D0 - D13 , A0 - A7 ( nano header ) GPIO : GPIO_1 - GPIO_8 ( routable GPIO ) Power : TOP_RAIL , BOTTOM_RAIL , GND DAC : DAC0 , DAC1 ( analog outputs ) ADC : ADC0 - ADC4 , PROBE ( analog inputs ) Current : ISENSE_PLUS , ISENSE_MINUS UART : UART_TX , UART_RX Buffer : BUFFER_IN , BUFFER_OUT THREE WAYS TO USE NODES : 1. NUMBERS ( direct breadboard holes ): connect ( 1 , 30 ) # Connect holes 1 and 30 connect ( 15 , 42 ) # Any number 1-60 2. STRINGS ( case - insensitive names ): connect ( \"D13\" , \"TOP_RAIL\" ) # Arduino pin to power rail connect ( \"gpio_1\" , \"adc0\" ) # GPIO to ADC (case-insensitive) connect ( \"15\" , \"dac1\" ) # Mix numbers and names 3. CONSTANTS ( pre - defined objects ): connect ( TOP_RAIL , D13 ) # Using imported constants connect ( GPIO_1 , A0 ) # No quotes needed connect ( DAC0 , 25 ) # Mix constants and numbers MIXED USAGE : my_pin = \"D13\" # Create node object from string connect ( my_pin , TOP_RAIL ) # Use node object with constant oled_print ( my_pin ) # Display shows 'D13' COMMON ALIASES ( many names work for same node ): \"TOP_RAIL\" = \"T_R\" \"GPIO_1\" = \"GPIO1\" = \"GP1\" \"DAC0\" = \"DAC_0\" \"UART_TX\" = \"TX\" NOTES : - String names are case - insensitive : \"d13\" = \"D13\" = \"nAnO_d13\" - Constants are case - sensitive : use D13 , not d13 - All three methods work in any function","title":"The entire output of nodes_help()"},{"location":"09.6-jfs/","text":"JFS (Jumperless FileSystem) The jfs module is basically like MicroPython's vfs and parts of os , but kinda written in a style that's probably more familiar to Arduino-style C++ people (me). It uses the almost standardized API shared by FatFS (the one Jumperless actually uses), LittleFS , and SDFS , but still has been Pythonified to use types that are easier to work with in MicroPython. Quick Reference File Operations: jfs . open ( path , mode ) - Opens file, returns file handle jfs . read ( file , size = 1024 ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . seek ( file , position , whence = 0 ) - Seek in file jfs . tell ( file ) - Get current position jfs . size ( file ) - Get file size jfs . available ( file ) - Get bytes available File Object Methods (after f = jfs . open ( ... ) ): f . print ( data ) - Print to the file (like write but auto-flushes) f . flush () - Flush buffered data to file f . position () - Alias for f . tell () f . name () - Get file name Directory Operations: jfs . exists ( path ) - Check if path exists (returns True/False) jfs . listdir ( path ) - List directory contents (returns list) jfs . mkdir ( path ) - Create directory jfs . rmdir ( path ) - Remove directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename/move file jfs . stat ( path ) - Get file/directory status info Filesystem Info: jfs . info () - Returns (total, used, free) tuple Usage import jfs #you don't actually need this, jfs is imported globally by default # List files in the root directory files = jfs . listdir ( '/' ) # returns a python list print ( files ) Output: [ 'config.txt' , 'nodeFileSlot0.txt' , 'python_scripts/' , 'nodeFileSlot1.txt' , 'nodeFileSlot2.txt' , 'nodeFileSlot3.txt' , 'nodeFileSlot4.txt' , 'nodeFileSlot5.txt' , 'nodeFileSlot6.txt' , 'nodeFileSlot7.txt' , 'net_colors/' ] If you want to make this print with subdirectories files = jfs . listdir ( '/' ) for file in range ( len ( files )): print ( files [ file ]) if files [ file ] . endswith ( \"/\" ): subdir = jfs . listdir ( files [ file ]) for i in range ( len ( subdir )): print ( \" - \" + subdir [ i ]) Output: nodeFileSlot0 . txt python_scripts / - history . txt - examples / - fake_gpio . py - _temp_repl_edit . py - Hey . txt - script_1 . py - script_2 . py - script_3 . py - log . txt - lib / - script_4 . py - pathtest . py nodeFileSlot1 . txt nodeFileSlot2 . txt nodeFileSlot3 . txt nodeFileSlot4 . txt nodeFileSlot5 . txt nodeFileSlot6 . txt nodeFileSlot7 . txt net_colors / - netColorsSlot0 . txt File API File objects returned by jfs . open () support method calls directly on the object: # Object-oriented file operations # Write-only mode f = jfs . open ( 'hello.txt' , 'w' ) f . write ( 'Hello, Jumperless!' ) f . close () # Read from the file (need to reopen or use w+/r+ mode) f = jfs . open ( 'hello.txt' , 'r' ) content = f . read () # Read from file object size = f . size () # Get file size f . close () # Read-write mode (truncates file) f = jfs . open ( 'hello.txt' , 'w+' ) f . write ( 'Hello, Jumperless!' ) f . seek ( 0 ) # Seek to beginning to read what we wrote content = f . read () # Now this works! f . close () # Context manager support (automatically closes file) with jfs . open ( 'data.txt' , 'w+' ) as f : f . write ( 'This file will be automatically closed' ) f . seek ( 0 ) # Reset to beginning content = f . read () # Read back what we wrote pos = f . tell () # Get current position name = f . name () # Get file name Using f . print () for logging The f . print () method works like Python's print () but writes to the file. It automatically converts arguments to strings and flushes after each call - perfect for logging: # Great for logging - auto-converts types and flushes immediately with jfs . open ( 'log.txt' , 'w+' ) as f : f . print ( \"Starting test...\" ) voltage = adc_get ( 0 ) f . print ( \"Voltage:\" , voltage , \"V\" ) # Multiple args work f . print ( \"Test complete!\" ) # Unlike f.write(), f.print() handles non-strings automatically f = jfs . open ( 'data.txt' , 'w' ) f . print ( 123 ) # OK - converts int to string f . print ( 3.14 ) # OK - converts float to string f . print ( \"mixed\" , 42 ) # OK - multiple args joined with spaces f . close () Note: f . print () is a file object method only. There is no jfs . print () module-level function. Other ways to do the same thing ### 2. Module-Level Functions You can also use module-level functions with file handles: f = jfs . open ( 'hello.txt' , 'w' ) jfs . write ( f , 'Hello, Jumperless!' ) # Module-level function jfs . seek ( f , 0 ) # Module-level function content = jfs . read ( f ) # Module-level function jfs . close ( f ) # Module-level function ### 3. Direct String Operations (For simple cases) # Write/read entire files at once (no file handles needed) jfs . write ( 'config.txt' , 'key=value \\n other=setting' ) content = jfs . read ( 'config.txt' ) File Modes When using jfs . open ( path , mode ) , the following modes are supported: Mode Description Read Write Create 'r' Read only \u2705 \u274c \u274c 'w' Write only \u274c \u2705 \u2705 'a' Append only \u274c \u2705 \u2705 'r+' Read + Write \u2705 \u2705 \u274c 'w+' Read + Write \u2705 \u2705 \u2705 'a+' Read + Append \u2705 \u2705 \u2705 Important: You cannot read from a file opened in write-only mode ( 'w' or 'a' ). Use 'w+' , 'r+' , or 'a+' if you need both read and write access. Open a file for writing f = jfs . open ( 'hello.txt' , 'w' ) f . write ( 'Hello, Jumperless!' ) # Now works with object-oriented API! f . close () Directory Operations jfs . listdir ( path ) Returns a list containing the names of the entries in the directory given by path . path (str): The path to the directory. Example: # List contents of the root directory print ( jfs . listdir ( '/' )) # List contents of a subdirectory jfs . mkdir ( '/my_dir' ) print ( jfs . listdir ( '/my_dir' )) jfs . mkdir ( path ) Create a new directory. path (str): The path of the new directory. jfs . rmdir ( path ) Remove an empty directory. path (str): The path of the directory to remove. jfs . remove ( path ) Remove a file. path (str): The path of the file to remove. jfs . rename ( old_path , new_path ) Rename a file or directory. old_path (str): The current path. new_path (str): The new path. jfs . exists ( path ) Check if a file or directory exists. path (str): The path to check. Returns True if it exists, False otherwise. jfs . stat ( path ) Get status of a file or directory. path (str): The path of the file or directory. Returns a tuple with file information (mode, size, etc.), similar to os . stat () . Filesystem Information jfs . info () Get information about the filesystem. Returns a tuple ( total_bytes , used_bytes , free_bytes ) . Example: total , used , free = jfs . info () print ( \"Filesystem Size: \" + str ( total / 1024 ) + \" KB\" ) print ( \"Used: \" + str ( used / 1024 ) + \" KB\" ) print ( \"Free: \" + str ( free / 1024 ) + \" KB\" ) File I/O The jfs module supports standard file opening and handling using jfs . open () and file objects, including support for the with statement for automatic resource management. jfs . open ( path , mode = 'r' ) Open a file and return a corresponding file object. path (str): The path to the file. mode (str, optional): The mode in which the file is opened. Defaults to 'r' . 'r' : Read (default). 'w' : Write (creates a new file or truncates an existing one). 'a' : Append. 'r+' : Read and write. 'w+' : Write and read (creates/truncates). 'a+' : Append and read. Example: # Open a file for reading f = jfs . open ( 'config.txt' , 'r' ) content = f . read () f . close () # Use 'with' for automatic closing with jfs . open ( 'data.log' , 'a' ) as log_file : log_file . write ( 'New log entry. \\\\ n' ) File Object Methods The file object returned by jfs . open () has the following methods: file . read ([ size ]) Read size bytes from the file. If size is omitted or negative, the entire file is read. file . write ( data ) Write the given string or bytes data to the file. Returns the number of bytes written. file . close () Close the file. A closed file cannot be read or written to. file . seek ( offset , [ whence ]) Change the stream position. * offset : The byte offset. * whence (optional): * 0 : Seek from the start of the stream (default). Use jfs . SEEK_SET . * 1 : Seek from the current position. Use jfs . SEEK_CUR . * 2 : Seek from the end of the stream. Use jfs . SEEK_END . file . tell () Return the current stream position. * Aliases : file . position () file . size () Return the total size of the file in bytes. file . available () Return the number of bytes available to be read from the current position to the end of the file. file . name Returns the name of the file. Module-Level File Operations For convenience, the jfs module also provides functions that operate directly on file handles returned by jfs . open () . This can be useful in some scripting scenarios but using file object methods is generally preferred for clarity. jfs . read ( file_handle , [ size ]) jfs . write ( file_handle , data ) jfs . close ( file_handle ) jfs . seek ( file_handle , offset , [ whence ]) jfs . tell ( file_handle ) jfs . size ( file_handle ) jfs . available ( file_handle ) Example: file_handle = jfs . open ( 'temp.txt' , 'w' ) jfs . write ( file_handle , 'some data' ) jfs . close ( file_handle )","title":"JFS (Jumperless FileSystem) Module"},{"location":"09.6-jfs/#jfs-jumperless-filesystem","text":"The jfs module is basically like MicroPython's vfs and parts of os , but kinda written in a style that's probably more familiar to Arduino-style C++ people (me). It uses the almost standardized API shared by FatFS (the one Jumperless actually uses), LittleFS , and SDFS , but still has been Pythonified to use types that are easier to work with in MicroPython.","title":"JFS (Jumperless FileSystem)"},{"location":"09.6-jfs/#quick-reference","text":"File Operations: jfs . open ( path , mode ) - Opens file, returns file handle jfs . read ( file , size = 1024 ) - Read from file jfs . write ( file , data ) - Write to file jfs . close ( file ) - Close file jfs . seek ( file , position , whence = 0 ) - Seek in file jfs . tell ( file ) - Get current position jfs . size ( file ) - Get file size jfs . available ( file ) - Get bytes available File Object Methods (after f = jfs . open ( ... ) ): f . print ( data ) - Print to the file (like write but auto-flushes) f . flush () - Flush buffered data to file f . position () - Alias for f . tell () f . name () - Get file name Directory Operations: jfs . exists ( path ) - Check if path exists (returns True/False) jfs . listdir ( path ) - List directory contents (returns list) jfs . mkdir ( path ) - Create directory jfs . rmdir ( path ) - Remove directory jfs . remove ( path ) - Remove file jfs . rename ( from , to ) - Rename/move file jfs . stat ( path ) - Get file/directory status info Filesystem Info: jfs . info () - Returns (total, used, free) tuple","title":"Quick Reference"},{"location":"09.6-jfs/#usage","text":"import jfs #you don't actually need this, jfs is imported globally by default # List files in the root directory files = jfs . listdir ( '/' ) # returns a python list print ( files ) Output: [ 'config.txt' , 'nodeFileSlot0.txt' , 'python_scripts/' , 'nodeFileSlot1.txt' , 'nodeFileSlot2.txt' , 'nodeFileSlot3.txt' , 'nodeFileSlot4.txt' , 'nodeFileSlot5.txt' , 'nodeFileSlot6.txt' , 'nodeFileSlot7.txt' , 'net_colors/' ] If you want to make this print with subdirectories files = jfs . listdir ( '/' ) for file in range ( len ( files )): print ( files [ file ]) if files [ file ] . endswith ( \"/\" ): subdir = jfs . listdir ( files [ file ]) for i in range ( len ( subdir )): print ( \" - \" + subdir [ i ]) Output: nodeFileSlot0 . txt python_scripts / - history . txt - examples / - fake_gpio . py - _temp_repl_edit . py - Hey . txt - script_1 . py - script_2 . py - script_3 . py - log . txt - lib / - script_4 . py - pathtest . py nodeFileSlot1 . txt nodeFileSlot2 . txt nodeFileSlot3 . txt nodeFileSlot4 . txt nodeFileSlot5 . txt nodeFileSlot6 . txt nodeFileSlot7 . txt net_colors / - netColorsSlot0 . txt","title":"Usage"},{"location":"09.6-jfs/#file-api","text":"File objects returned by jfs . open () support method calls directly on the object: # Object-oriented file operations # Write-only mode f = jfs . open ( 'hello.txt' , 'w' ) f . write ( 'Hello, Jumperless!' ) f . close () # Read from the file (need to reopen or use w+/r+ mode) f = jfs . open ( 'hello.txt' , 'r' ) content = f . read () # Read from file object size = f . size () # Get file size f . close () # Read-write mode (truncates file) f = jfs . open ( 'hello.txt' , 'w+' ) f . write ( 'Hello, Jumperless!' ) f . seek ( 0 ) # Seek to beginning to read what we wrote content = f . read () # Now this works! f . close () # Context manager support (automatically closes file) with jfs . open ( 'data.txt' , 'w+' ) as f : f . write ( 'This file will be automatically closed' ) f . seek ( 0 ) # Reset to beginning content = f . read () # Read back what we wrote pos = f . tell () # Get current position name = f . name () # Get file name","title":"File API"},{"location":"09.6-jfs/#using-fprint-for-logging","text":"The f . print () method works like Python's print () but writes to the file. It automatically converts arguments to strings and flushes after each call - perfect for logging: # Great for logging - auto-converts types and flushes immediately with jfs . open ( 'log.txt' , 'w+' ) as f : f . print ( \"Starting test...\" ) voltage = adc_get ( 0 ) f . print ( \"Voltage:\" , voltage , \"V\" ) # Multiple args work f . print ( \"Test complete!\" ) # Unlike f.write(), f.print() handles non-strings automatically f = jfs . open ( 'data.txt' , 'w' ) f . print ( 123 ) # OK - converts int to string f . print ( 3.14 ) # OK - converts float to string f . print ( \"mixed\" , 42 ) # OK - multiple args joined with spaces f . close () Note: f . print () is a file object method only. There is no jfs . print () module-level function. Other ways to do the same thing ### 2. Module-Level Functions You can also use module-level functions with file handles: f = jfs . open ( 'hello.txt' , 'w' ) jfs . write ( f , 'Hello, Jumperless!' ) # Module-level function jfs . seek ( f , 0 ) # Module-level function content = jfs . read ( f ) # Module-level function jfs . close ( f ) # Module-level function ### 3. Direct String Operations (For simple cases) # Write/read entire files at once (no file handles needed) jfs . write ( 'config.txt' , 'key=value \\n other=setting' ) content = jfs . read ( 'config.txt' )","title":"Using f.print() for logging"},{"location":"09.6-jfs/#file-modes","text":"When using jfs . open ( path , mode ) , the following modes are supported: Mode Description Read Write Create 'r' Read only \u2705 \u274c \u274c 'w' Write only \u274c \u2705 \u2705 'a' Append only \u274c \u2705 \u2705 'r+' Read + Write \u2705 \u2705 \u274c 'w+' Read + Write \u2705 \u2705 \u2705 'a+' Read + Append \u2705 \u2705 \u2705 Important: You cannot read from a file opened in write-only mode ( 'w' or 'a' ). Use 'w+' , 'r+' , or 'a+' if you need both read and write access.","title":"File Modes"},{"location":"09.6-jfs/#open-a-file-for-writing","text":"f = jfs . open ( 'hello.txt' , 'w' ) f . write ( 'Hello, Jumperless!' ) # Now works with object-oriented API! f . close ()","title":"Open a file for writing"},{"location":"09.6-jfs/#directory-operations","text":"","title":"Directory Operations"},{"location":"09.6-jfs/#jfslistdirpath","text":"Returns a list containing the names of the entries in the directory given by path . path (str): The path to the directory. Example: # List contents of the root directory print ( jfs . listdir ( '/' )) # List contents of a subdirectory jfs . mkdir ( '/my_dir' ) print ( jfs . listdir ( '/my_dir' ))","title":"jfs.listdir(path)"},{"location":"09.6-jfs/#jfsmkdirpath","text":"Create a new directory. path (str): The path of the new directory.","title":"jfs.mkdir(path)"},{"location":"09.6-jfs/#jfsrmdirpath","text":"Remove an empty directory. path (str): The path of the directory to remove.","title":"jfs.rmdir(path)"},{"location":"09.6-jfs/#jfsremovepath","text":"Remove a file. path (str): The path of the file to remove.","title":"jfs.remove(path)"},{"location":"09.6-jfs/#jfsrenameold_path-new_path","text":"Rename a file or directory. old_path (str): The current path. new_path (str): The new path.","title":"jfs.rename(old_path, new_path)"},{"location":"09.6-jfs/#jfsexistspath","text":"Check if a file or directory exists. path (str): The path to check. Returns True if it exists, False otherwise.","title":"jfs.exists(path)"},{"location":"09.6-jfs/#jfsstatpath","text":"Get status of a file or directory. path (str): The path of the file or directory. Returns a tuple with file information (mode, size, etc.), similar to os . stat () .","title":"jfs.stat(path)"},{"location":"09.6-jfs/#filesystem-information","text":"","title":"Filesystem Information"},{"location":"09.6-jfs/#jfsinfo","text":"Get information about the filesystem. Returns a tuple ( total_bytes , used_bytes , free_bytes ) . Example: total , used , free = jfs . info () print ( \"Filesystem Size: \" + str ( total / 1024 ) + \" KB\" ) print ( \"Used: \" + str ( used / 1024 ) + \" KB\" ) print ( \"Free: \" + str ( free / 1024 ) + \" KB\" )","title":"jfs.info()"},{"location":"09.6-jfs/#file-io","text":"The jfs module supports standard file opening and handling using jfs . open () and file objects, including support for the with statement for automatic resource management.","title":"File I/O"},{"location":"09.6-jfs/#jfsopenpath-moder","text":"Open a file and return a corresponding file object. path (str): The path to the file. mode (str, optional): The mode in which the file is opened. Defaults to 'r' . 'r' : Read (default). 'w' : Write (creates a new file or truncates an existing one). 'a' : Append. 'r+' : Read and write. 'w+' : Write and read (creates/truncates). 'a+' : Append and read. Example: # Open a file for reading f = jfs . open ( 'config.txt' , 'r' ) content = f . read () f . close () # Use 'with' for automatic closing with jfs . open ( 'data.log' , 'a' ) as log_file : log_file . write ( 'New log entry. \\\\ n' )","title":"jfs.open(path, mode=&#39;r&#39;)"},{"location":"09.6-jfs/#file-object-methods","text":"The file object returned by jfs . open () has the following methods:","title":"File Object Methods"},{"location":"09.6-jfs/#filereadsize","text":"Read size bytes from the file. If size is omitted or negative, the entire file is read.","title":"file.read([size])"},{"location":"09.6-jfs/#filewritedata","text":"Write the given string or bytes data to the file. Returns the number of bytes written.","title":"file.write(data)"},{"location":"09.6-jfs/#fileclose","text":"Close the file. A closed file cannot be read or written to.","title":"file.close()"},{"location":"09.6-jfs/#fileseekoffset-whence","text":"Change the stream position. * offset : The byte offset. * whence (optional): * 0 : Seek from the start of the stream (default). Use jfs . SEEK_SET . * 1 : Seek from the current position. Use jfs . SEEK_CUR . * 2 : Seek from the end of the stream. Use jfs . SEEK_END .","title":"file.seek(offset, [whence])"},{"location":"09.6-jfs/#filetell","text":"Return the current stream position. * Aliases : file . position ()","title":"file.tell()"},{"location":"09.6-jfs/#filesize","text":"Return the total size of the file in bytes.","title":"file.size()"},{"location":"09.6-jfs/#fileavailable","text":"Return the number of bytes available to be read from the current position to the end of the file.","title":"file.available()"},{"location":"09.6-jfs/#filename","text":"Returns the name of the file.","title":"file.name"},{"location":"09.6-jfs/#module-level-file-operations","text":"For convenience, the jfs module also provides functions that operate directly on file handles returned by jfs . open () . This can be useful in some scripting scenarios but using file object methods is generally preferred for clarity. jfs . read ( file_handle , [ size ]) jfs . write ( file_handle , data ) jfs . close ( file_handle ) jfs . seek ( file_handle , offset , [ whence ]) jfs . tell ( file_handle ) jfs . size ( file_handle ) jfs . available ( file_handle ) Example: file_handle = jfs . open ( 'temp.txt' , 'w' ) jfs . write ( file_handle , 'some data' ) jfs . close ( file_handle )","title":"Module-Level File Operations"},{"location":"09.8-odds-and-ends/","text":"Odds and Ends What's New in JumperlOS JumperlOS is now a proper operating system with a priority-based task scheduler! This is a huge refactor from the original firmware: Viper IDE and Micropython raw REPL - Live code on the Jumperless' file system in your browser Priority-based task scheduler - Each component has a service () routine that checks whether it should do anything, replacing the old busy-wait loop Live updating - Edits to the YAML state files will live update with new connections (whether you're editing them in the onboard editor or as a mounted USB MSC device on your computer) Better fonts - New fonts available: Berkeley , Iosevka , Pragmat [ ism ] YAML connection files - More permissive of malformed syntax Unified syntax highlighting - Works consistently in eKilo , python , and normal input after > Encoder-based connections - Use the clickwheel to scroll through and select nodes without touching the probe Current sensing marching ants - Animated visual feedback showing current flow direction between I+ and I- connections Python context switching - Toggle between global and python connection contexts in the MicroPython REPL The JumperlOS firmware repo is at https://github.com/Architeuthis-Flux/JumperlOS Safety Info Here's an image of the little card that should have been inside your box Never put voltages above +9V or below -9V anywhere on this board. Don't use unpowered, the crossbars need power to block voltage too. Don't power externally, use the internal power supplies (rails / DACs). It can be powered from the 5V and GND pins on the Nano header or the FPC adapter instead of USB. External signals are okay, as long as the board remains powered. This board gets fairly warm in normal operation from the LEDs, if it ever gets hot, unplug it immediately and let me know. When the switch on the probe is set to Select Mode, it should only be used on the gold probe sense pads. The probe tip in Select Mode is always at 3.3V. Don't stab yourself or others with the probe, unless it's in self-defense. Do not eat your Jumperless V5. When in doubt, don't hesitate to ask! There are a lot of exceptions to these if you know what you're doing. It's pretty hard to permanently damage this board. Some things (usually external power with the Jumperless off) can cause lockup on the analog CMOS switches , but the current limiting resistors on their power supply pins generally keep them from drawing so much current that they permanently break. In situations where one chip is getting crazy hot, the first thing to try is to unplug the Jumperless, let it cool down, and try it again (obviously, change whatever you think was causing it). Most of the time they go back to normal after some rest. Don't let any of this scare you, I'd rather you just pretend it's indestructable and use it with reckless abandon. So if you manage to break anything, just let me know and I'll send out a fresh one and a return label, no questions asked*. *Actually, a ton of questions asked, so we can figure out how it happened and maybe prevent it from happening to someone else. But the point is I don't care if it's clearly your fault and not some manufacturing defect, I will make sure you have a working Jumperless. It's even printed on the box Joom You can get the .uf2 file here: https://github.com/Architeuthis-Flux/joom/releases/download/0.0.1/joom_full.uf2 You'll need to put the Jumperless in bootloader mode (unplug it, press the button on the back side of the USB port, plug it back in, then drag this UF2 file onto the drive called RP2350 that pops up) Connect a speaker between the lower RST pin (the one closer to the breadboard) on the Nano header and GND for sound. When you're done playing Doom in a blindness simulator, just reload the regular firmware the same way as above. https://github.com/Architeuthis-Flux/JumperlessV5/releases/latest Bandwidth Michael has done some awesome work characterizing the bandwidth of the Jumperless . The TL;DR is just the physical breadboard puts the 3dB rolloff t ~13MHz, and a signal passing through the crossbar matrix brings it down to around ~8MHz. It makes sense these are pretty high, these CH446Qs were originally made for switching video signals so bandwidth was pretty important when they were designing them. Keep in mind this isn't a hard limit, it's just where the signal gets attenuated by the (arbitrarilyish) defined 3dB, so your signal's amplitude is reduced by \u221a2. Animations The Jumperless uses LED animations to show the state of different components on the breadboard. Rail Animations If it's a rail, those are animated and should be a continuous slow pulsing toward the top or bottom depending on the rail. ADC Animations ADCs are green at 0V, and go through the spectrum to red at +5V, and get whiter hot pink toward +8V. Negative voltages are kinda blue/icy and do that same thing with the \"cold\" colors towards -8V. GPIO Animations Input Mode GPIO as inputs are animated with a white pulsing (this might be broken in that FW release, I'm fixing that right now actually, and will just be purple/white) when floating, red for high, green for low Output Mode GPIO outputs will be either green or red depending on their state What's that BUFFER_IN - DAC_0 bridge that's always there? That gets added to power the probe LEDs , it's kinda weird, but to multiplex 3.3V, GND, LED data, 2 buttons, and a +-9V tolerant analog line over the 4 wires on a TRRS cable, the line powering those LEDs is shared. The connect / measure switch is a Dual Pole Dual Throw (DPDT) switch. The probe tip needs to be at a steady 3.3V to be read by the probe sense pads which is a big resistive divider sensed by a single ADC . When you have it in select mode, the probe tip is getting 3.3V from a GPIO on the RP2350B driven high , and the LEDs get their power from the analog line, which is ROUTABLE_BUFFER_IN connected to DAC 0 set to 3.3V. When you switch to measure mode, those roles get swapped, the LEDs are powered by that GPIO , and the probe tip is now ROUTABLE_BUFFER_IN . In the current firmware, that just stays at 3.3V so you can kinda sense pads in either mode (you may notice the sensing is a lot wonkier, that's because the DAC isn't perfectly calibrated to output exactly 3.3V.) But in the future, there will be some other stuff you can do in that mode treating it as an analog line (and of course, I'll forget to update this, if it's after like June 2025, double check this is still true.) A side effect of needing a crossbar connection to light the probe is that the LEDs in Select Mode act as a test of whether the Jumperless is properly making connections. Why am I using one of the precious two DACs and not another GPIO? The answer is switch position sensing. You may notice there's no obvious way for the Jumperless to know where the switch is set, so I had to get creative on this one. DAC 0 's output is hardwired to go through a current sense shunt resistor, so when DAC 0 is powering the probe LEDs , they'll be drawing some current I can measure with one of the INA219 s, and therefore I can be reasonably confident that the switch is in the select position. If you need both DAC s, you can just get rid of this connection and the probe LEDs won't light up, but other than aesthetics, it really has no effect on functionality. Or you connect ROUTABLE_BUFFER_IN to a GPIO and set it high and just lose the ability to sense where the switch is. AI Generated Wiki If you want to read a wiki generated by AI and ask it questions about how this thing works and how to use it, DeepWiki was surprisingly accurate (enough.) The docs on this site are more about how to use your Jumperless, this is more geared toward helping understand the circuitry and code. Onboard Help Use help or [ command ] ? for onboard documentation GitHub Releases If you want more info about each feature when I was particularly excited about it, I usually write about the new features in the Release notes on Github . Schematic Here's the schematic that's printed on the inner flap of the box If you want look at the schematic and PCB together and don't feel like downloading the whole thing and opening it in KiCad, you can open it in the browser with KiCanvas here Writing Native apps Writing Apps Here's a the example app that should show the calls for most of the things you might want to do You can do literally anything the Jumperless can in an app, so if there's a specific thing, lmk and I'll write an example. Until I make this into a proper operating system, what you're doing when you write an App is just writing a function in the main firmware. There's really no guard rails, and the API is just any function in the firmware. First get it PlatformIO set up to flash code So fork the firmware here: https://github.com/Architeuthis-Flux/JumperlOS I'm using PlatformIO in VSCode. And it should just work to open the RP23V50firmware folder in that (you'll probably need to comment out upload_port = / dev / cu . usbmodemJLV5port1 in Platformio . ini so it'll just automatically find it) You should probably try to just load the firmware just to make sure everything works. To write an App Before you go writing your app, follow these steps to make it so it's listed in the App library and you can run it from the menus. Go to menuTree . h and add the name of your app under Apps \\ n \\ (shown as - Custom App \\ n \\ here, it needs to fit in 7x2 chars to show on the breadboard) Go to Apps . h and declare your function where you'll write your app Go to Apps . cpp and add a struct in the struct app apps [ 30 ] for your app { \"Name\" , index , ?? idk , name of the function ( unused )} Go to Apps . cpp > runApp () and add a case for your app's index (this is so you can also find it by index rather than exact matching the name \"Custom App\" Make a function that's the entirety of your app, I just pushed a demo function called customApp ( void ) with some (non exhaustive) examples of things you can do from an app. Run your app with the clickwheel, Apps > Custom App . The quick way run \"Custom App\" is to just enter 2 in the main menu, or just use the clickwheel and go Apps > Custom App. If you want to add your own shortcut, find an unused menu character and add a case '3' : { runApp ( 3 ); // the app index you set above break ; } in the big main menu switch statement in main . cpp . To actually write the app The code for Custom App is an example of the calls available with comments telling you what's going on. There are tons more, but what's shown there are the higher-level helper functions that should roughly do what they say they're doing. LLM Tool Specification for Jumperless V5 A guide for LLMs with some tips to control the Jumperless V5. Quick Reference Category Key Tools Connections connect () , disconnect () , nodes_clear () , save_slot () , load_slot () Voltage dac_set () , adc_get () Current ina_get_current () , ina_get_power () GPIO gpio_set () , gpio_get () , gpio_set_dir () , pwm () User Interaction oled_print () , probe_read_blocking () , probe_button () Graphic Overlays overlay_set () , overlay_clear () , overlay_set_pixel () State get_state () , set_state () (Refer to the full Micropython API Reference ) Communication Methods Method 1: Direct Python Commands (Main Serial Port) Prefix single-line Python with > on the main serial port (Port 1). Best for: Single commands, status checks. > connect ( 1 , 5 ) > voltage = adc_get ( 0 ) > oled_print ( f \"V = { voltage : .2f } \" ) > print ( f \"V = { voltage : .2f } \" ) Method 2: ViperIDE / Raw REPL (3rd USB Port) The third USB port provides a MicroPython Raw REPL. Best for: Complex logic, loops, automated testing scripts. # Full scripts run on port 3 import time for i in range ( 10 ): voltage = adc_get ( 0 ) print ( f \"Reading { i } : { voltage : .2f } V\" ) time . sleep ( 0.5 ) Method 3: Arduino Tags (via UART) From an Arduino connected to the Jumperless. Best for: Hybrid Arduino/Python projects. Serial . print ( \"<p>connect(1, 5)</p>\" ); // Python command Serial . print ( \"<j>n</j>\" ); // Menu command Method 4: Single-Character Commands (Main Serial Port) Raw characters sent to Port 1 trigger immediate menu actions. Best for: Fast state dumps, clearing the board, or manual resets. J <-- Immediate JSON state dump L <-- Immediate JSON state load ( paste JSON after L ) x <-- Immediate board clear USB Port Structure macOS / Linux: | Port | Name | Function | |------|------|----------| | 1 (main) | JLV5port1 | Main terminal, menu, > Python commands | | 2 | JLV5port3 | Arduino UART passthrough | | 3 | JLV5port5 | MicroPython Raw REPL (ViperIDE) | Windows: | Port | Name | Function | |------|------|----------| | 1 (main) | COM1 | Main terminal, menu, > Python commands | | 2 | COM2 | Arduino UART passthrough | | 3 | COM3 | MicroPython Raw REPL (ViperIDE) | Hardware Overview Physical Layout 60 breadboard rows (1-60) with 5 RGB LEDs underneath each Arduino Nano header with routable pins OLED display (128x32, optional but recommended) Probe with touch-sensing tip, 2 buttons, mode switch Clickwheel rotary encoder with button 12 CH446Q crossbar chips (A-L) for routing (~80\u03a9 per path) Power TOP_RAIL / BOTTOM_RAIL : Main power rails (\u00b18V, 300mA) DAC0 / DAC1 : Auxiliary voltage outputs (\u00b18V, 300mA each) DAC0 connects to Probe Tip & INA0 DAC0 and DAC1 are 0-3.3V native but amplified to \u00b18V Current Limits : ~300mA per rail/DAC Measurement ADC0-3 : 4 user analog inputs (\u00b18V range) INA0 : High-side current monitor on DAC0 (Probe Tip) INA1 : High-side current monitor on TOP_RAIL (configurable) GPIO 10 GPIO pins (RP2350B, 3.3V logic) Defined as GPIO_1 - GPIO_8 (physical gpio 20-27 on RP2350B), and UART_TX (gpio 0 on RP2350B) and UART_RX (gpio 1 on RP2350B) 5V Tolerant Inputs : Yes PWM : Hardware PWM 0.1Hz-62.5MHz on all pins Node Addressing Breadboard Rows 1 through 60 Power Rails Node Description TOP_RAIL Top power rail (default 5V) BOTTOM_RAIL Bottom rail (default GND) GND Ground reference DAC0 DAC0 (connected to probe tip and INA0) DAC1 DAC1 (8V tolerant) Arduino Pins D0 - D13 , A0 - A7 , AREF , RESET GPIO GPIO_1 - GPIO_8 , UART_TX , UART_RX ADC/Current Sense ADC0 - ADC3 , ISENSE_PLUS , ISENSE_MINUS Core Tool Definitions Connections & Slots connect ( node1 , node2 , duplicates =- 1 ) # Create connection disconnect ( node1 , node2 ) # Remove connection nodes_clear () # Remove ALL connections is_connected ( node1 , node2 ) # Check if connected # Slot Management save_slot ( slot_id ) # Save current state to slot 0-7 load_slot ( slot_id ) # Load state from slot 0-7 get_current_slot () # Returns active slot number # JSON State API (Recommended for LLMs) get_state () # Get complete state as JSON string set_state ( json , clear_first = True ) # Apply state from JSON string Voltage Control dac_set ( channel , voltage , save = True ) # Set voltage (-8V to +8V) dac_get ( channel ) # Get current setting # Channels: 0/DAC0, 1/DAC1, 2/TOP_RAIL, 3/BOTTOM_RAIL Measurement adc_get ( channel ) # Read ADC voltage (channels 0-3) ina_get_current ( sensor ) # Read current in Amps (0=DAC0/Probe, 1=TOP_RAIL) ina_get_voltage ( sensor ) # Read INA bus voltage ina_get_power ( sensor ) # Read power in Watts GPIO & PWM gpio_set ( pin , value ) # Set output (True=3.3V, False=0V) gpio_get ( pin ) # Returns HIGH, LOW, or FLOATING gpio_set_dir ( pin , direction ) # True=OUTPUT, False=INPUT gpio_set_pull ( pin , pull ) # 1=PULLUP, -1=PULLDOWN, 0=NONE pwm ( pin , frequency , duty ) # Start PWM (duty: 0.0-1.0) pwm_stop ( pin ) # Stop PWM Waveform Generator (WaveGen) # Setup wavegen_set_output ( channel ) # 0=DAC0, 1=DAC1 (Default) wavegen_set_wave ( type ) # 0=Sine, 1=Square, 2=Tri, 3=Saw wavegen_set_freq ( hz ) # Frequency in Hz wavegen_set_amplitude ( vpp ) # Peak-to-Peak Voltage (e.g. 3.3) wavegen_set_offset ( volts ) # DC Offset (e.g. 1.65) # Control wavegen_start ( 1 ) # Start output wavegen_stop () # Stop output User Interaction oled_print ( text , size = 2 ) # Display on OLED oled_clear () # Clear display probe_read_blocking () # Wait for probe touch, return row probe_read_nonblocking () # Check without waiting (-1 if none) probe_button () # Returns CONNECT, REMOVE, or NONE clickwheel_get_direction () # Returns UP, DOWN, or NONE clickwheel_get_button () # Returns PRESSED, HELD, RELEASED Graphic Overlays (Breadboard LEDs) The breadboard LEDs are addressed as a 10x30 grid (Row 1-10, Col 1-30). Rows 1-5 are top half (E-A), Rows 6-10 are bottom half (F-J). # overlay_set(name, x, y, height, width, colors) # Colors can be flat list or 2D list of 0xRRGGBB integers overlay_set ( \"box\" , 1 , 1 , 5 , 5 , [ 0x550000 ] * 25 ) overlay_clear ( \"box\" ) # Remove overlay overlay_clear_all () # Remove all overlay_set_pixel ( x , y , color ) # Set single pixel (1-30, 1-10) System & Filesystem # Standard Python I/O is supported! with open ( '/config.txt' , 'r' ) as f : print ( f . read ()) # List files import os os . listdir ( '/' ) get_net_info ( netNum ) # Get dict with name, color, nodes get_num_nets () # Count of active nets get_num_bridges () # Count of bridges print_bridges () # Print bridge table Single-Character Command Reference (Port 1 Only) These commands are processed immediately when sent as raw characters (no > prefix) to the main serial port. Char Description Action J Show JSON Dumps the complete board state as a JSON string. L Load JSON Prepares the board to receive a JSON state. Paste JSON and end with an empty line. x Clear All Removes all connections and resets paths. n List Nets Prints a human-readable list of all active nets. b Show Bridges Prints the internal bridge array. ~ Show Config Dumps the current config . txt settings. | + | Add | Add connections (e.g., + 1 - 5 , 10 - 12 ). | | - | Remove | Remove connections (e.g., - 1 - 5 ). | | v | Read ADC | Follow with a channel (0-4) to get a quick voltage reading. | | @ | I2C Scan | Scans for I2C devices on a row (e.g., @ 10 ). | | r | Reset Arduino | Follow with t or b to reset the Top or Bottom Arduino. | | A | Connect Arduino UART | Connects Jumperless's UART to the Arduino D0 and D1 pins ( a to disconnect). | | m | Menu | Displays the help menu ( e to show more options). | | [ command ] ? | Help | Displays the help menu for the specified command. | | help | Help Menu | Displays the help menu. | LLM Mental Model File Format LLMs should maintain a persistent JSON model of what they believe is physically on the breadboard. This model has confidence values that increase through user confirmation or automated testing. Mental Model Schema { \"version\" : \"1.0\" , \"last_updated\" : \"2026-02-06T22:00:00Z\" , \"nano_header\" : { \"device\" : \"arduino_nano\" , // \"arduino_nano\", \"rp2040\", \"rpi_40pin_adapter\", \"oled_only\", \"empty\" \"confidence\" : 0.9 , \"notes\" : \"User confirmed Arduino Nano Every\" }, \"power_rails\" : { \"TOP_RAIL\" : { \"voltage\" : 5.0 , \"confidence\" : 1.0 , \"source\" : \"measured\" }, \"BOTTOM_RAIL\" : { \"voltage\" : 0.0 , \"confidence\" : 1.0 , \"source\" : \"measured\" } }, \"components\" : [ { \"id\" : \"comp_001\" , \"type\" : \"resistor\" , \"value\" : 1000 , \"unit\" : \"ohms\" , \"tolerance\" : 0.05 , \"pins\" : [ 5 , 10 ], \"confidence\" : 0.95 , \"detection_method\" : \"measured\" , \"notes\" : \"Measured 987\u03a9 between rows 5-10\" }, { \"id\" : \"comp_002\" , \"type\" : \"led\" , \"color\" : \"red\" , \"forward_voltage\" : 1.8 , \"pins\" : { \"anode\" : 15 , \"cathode\" : 16 }, \"confidence\" : 0.7 , \"detection_method\" : \"user_stated\" , \"notes\" : \"User said 'red LED on rows 15-16'\" }, { \"id\" : \"comp_003\" , \"type\" : \"module\" , \"name\" : \"SSD1306 OLED\" , \"pins\" : { \"GND\" : 20 , \"VCC\" : 21 , \"SCL\" : 22 , \"SDA\" : 23 }, \"confidence\" : 0.6 , \"detection_method\" : \"inferred\" , \"notes\" : \"Searched pinout, user confirmed row 20\" } ], \"wires\" : [ { \"from\" : 1 , \"to\" : 30 , \"confidence\" : 0.8 , \"detection_method\" : \"continuity_test\" } ], \"unknowns\" : [ { \"rows\" : [ 40 , 41 , 42 ], \"notes\" : \"Something detected but not identified\" } ] } Nano Header Device Types Device Description arduino_nano Arduino Nano/Every/RP2040 etc. rp2040 Bare RP2040 board rpi_40pin_adapter RPi GPIO adapter board oled_only SBC/SMD/OLED adapter for just the OLED empty Nothing plugged in Confidence Levels Level Source Meaning 1.0 measured Electrically verified 0.9 user_confirmed User explicitly confirmed 0.7 user_stated User mentioned it casually 0.5 inferred LLM guessed from context 0.3 assumed Default assumption Increasing Confidence Method Confidence Boost User confirms \"yes that's right\" +0.2 Electrical measurement matches +0.3 Multiple consistent tests +0.1 per test User provides datasheet Set to 0.95 Workflows for LLMs 1. Circuit Safe-Check (Mental Model) CRITICAL : The Jumperless prevents internal shorts, but cannot see external wires or components on the breadboard. If a user has a physical wire connecting Row 5 to Row 10, connecting TOP_RAIL -> 5 and GND -> 10 will cause a dead short through the user's wire. Workflow: 1. Ask : \"What is currently on the breadboard? (Wires, components, etc)\" 2. Model : Build the mental model JSON with low confidence 3. Test : Run detect_component () on key rows to verify 4. Update : Increase confidence as tests confirm the model # Safe Power-Up Sequence oled_print ( \"Checking for shorts...\" ) # Find an unused ADC unused_adc = None for i in range ( 4 ): name = f \"ADC { i } \" is_used = False for net in get_all_nets (): if name in net [ 'nodes' ]: is_used = True break if not is_used : unused_adc = i break if unused_adc is not None : connect ( 5 , f \"ADC { unused_adc } \" ) connect ( 10 , DAC1 ) # ... model[\"wires\"].append({\"from\": 5, \"to\": 10, \"confidence\": 0.95}) else: connect(5, TOP_RAIL) connect(10, GND) ### 2. Identifying User Circuits Use the Probe to \"see\" the board . ``` jython oled_print ( \"Touch the input of your circuit\" ) input_row = probe_read_blocking () oled_print ( f \"Input is at row { input_row } \" ) 3. Automated Characterization Use WaveGen and ADC to treat the circuit as a black box. connect ( DAC1 , 1 ) wavegen_set_output ( 1 ) wavegen_set_freq ( 100 ) wavegen_set_wave ( 0 ) # Sine wavegen_start ( 1 ) connect ( ADC0 , 10 ) for i in range ( 5 ): val = adc_get ( 0 ) print ( f \"Sample { i } : { val } V\" ) time . sleep ( 0.01 ) Component Library (Dynamic Lookup) When a user mentions a hardware module, search the web for its pinout and build a JSON definition on the fly. Workflow: 1. User mentions: \"I have an SSD1306 OLED on the breadboard\" 2. LLM searches: \"SSD1306 OLED pinout\" 3. LLM builds JSON from search results and adds it to mental_model [ \"components\" ] Example: NeoPixel Stick { \"name\" : \"NeoPixel Stick 8\" , \"pins\" : { \"GND\" : { \"default\" : \"GND\" , \"offset\" : 0 }, \"5V\" : { \"default\" : \"TOP_RAIL\" , \"offset\" : 1 }, \"DIN\" : { \"default\" : \"GPIO_1\" , \"offset\" : 2 }, \"DOUT\" : { \"default\" : \"NC\" , \"offset\" : 7 } }, \"width\" : 8 , \"voltage\" : \"5V\" , \"notes\" : \"3.3V GPIO works for most NeoPixels. Data on offset 2.\" } Key : The offset field defines pin position relative to pin 1. When user says \"pin 1 is on row X\", calculate absolute rows as row = X + offset . Safety Guidelines for LLMs Voltage Check : ADCs are buffered for \u00b18V. The board is \u00b19V tolerant overall. Short Circuit Prevention : The firmware will ignore requests to connect TOP_RAIL directly to BOTTOM_RAIL or GND . Confirm Power : Ask: \"Is the board powered via USB?\" (No barrel jack exists). Crossbar Resistance : Remember ~80\u03a9 per connection. High current paths will have voltage drop. Measure voltage at the destination with an ADC to compensate. LLM Preferences (Claude's Additions) 1. Structured State Snapshot What I want : A single command that returns the complete board state as structured data (JSON/dict), not just printed text. This lets me reason about the state programmatically. # REQUESTED: get_state() -> dict # Returns something like: { \"slot\" : 0 , \"bridges\" : [[ 1 , 5 ], [ 5 , \"TOP_RAIL\" ], [ 10 , \"GND\" ]], \"rails\" : { \"TOP_RAIL\" : 5.0 , \"BOTTOM_RAIL\" : 0.0 , \"DAC0\" : 3.3 , \"DAC1\" : 0.0 }, \"gpio\" : [ { \"pin\" : 1 , \"dir\" : \"OUTPUT\" , \"value\" : True , \"pull\" : \"NONE\" }, { \"pin\" : 2 , \"dir\" : \"INPUT\" , \"value\" : False , \"pull\" : \"PULLUP\" } ], \"adc_snapshot\" : [ 3.28 , 0.01 , 5.02 , - 0.03 ] # Quick reading of all 4 } Why : Currently I have to call get_num_bridges () , get_net_info () for each net, etc. A single snapshot is faster and less error-prone for building my mental model. 2. Return Values, Not Just Prints For debugging, I prefer return values over print statements : Instead of... I prefer... print_nets () \u2192 prints to serial get_nets () \u2192 returns list of net dicts print_bridges () \u2192 prints to serial get_bridges () \u2192 returns list of bridge tuples print_paths_compact () \u2192 prints get_paths () \u2192 returns routing info Why : When I call a tool, I want to capture the result and reason about it. Print output goes to the user's terminal but isn't easily parsed by my next step. 3. Error Return Conventions Consistent error handling helps me recover: # Good: Returns None or raises exception with message result = connect ( 999 , 5 ) # Invalid node # Returns: None (or {\"error\": \"Invalid node: 999\"}) # Good: Returns success/failure boolean with reason success , msg = disconnect ( 1 , 5 ) # Returns: (True, \"Disconnected\") or (False, \"No such connection\") 4. Undo via Slot Backup For destructive operations like nodes_clear () , the existing slot system provides an undo mechanism: # Before destructive operation, save current state to a backup slot save_slot ( 7 ) # Save to slot 7 as backup nodes_clear () # Now safe to clear # If user wants to undo: load_slot ( 7 ) # Restore from backup Pattern : Always save the current slot to an unused slot (7 is a good \"scratch\" slot) before any destructive action. This provides a built-in undo without needing special confirm flags. 5. Measurement with Context When measuring, I often want multiple samples or statistics: # REQUESTED: adc_get_stats(channel, samples=10) # Returns: {\"mean\": 3.28, \"min\": 3.25, \"max\": 3.31, \"stddev\": 0.02} Why : A single ADC reading might be noisy. Having built-in averaging/stats means I don't have to write loops for every measurement. 6. Interactive Conversation Patterns When helping users debug, I find these patterns effective: Explore First, Act Later : User : \"My LED isn't lighting up\" Me : 1. \"Where is your LED connected? (Touch the anode with the probe)\" 2. [ probe_read_blocking () \u2192 row 15 ] 3. \"I see row 15. Let me check the voltage there...\" 4. [ connect ( ADC0 , 15 ), adc_get ( 0 ) \u2192 0.02 V ] 5. \"Row 15 is at 0V. Is it supposed to be connected to power?\" Show, Don't Just Do : # Before making a connection, describe it: oled_print ( \"Connecting row 5 to 5V...\" ) connect ( 5 , TOP_RAIL ) oled_print ( \"Done! LED should light now\" ) Verify After Acting : # After connecting power, verify it worked: connect ( 5 , TOP_RAIL ) connect ( ADC0 , 5 ) v = adc_get ( 0 ) if abs ( v - 5.0 ) < 0.5 : oled_print ( f \"\u2713 Row 5 at { v : .1f } V\" ) else : oled_print ( f \"\u26a0 Expected 5V, got { v : .1f } V\" ) disconnect ( ADC0 , 5 ) LLM Best Practices & Future Tools This section consolidates recommendations for reliable, high-context hardware interaction. 1. Explicit State Verification Trust but verify. Confirm hardware state after critical operations. # Goal: Set DAC0 to 3.3V current = dac_get ( 0 ) if abs ( current - 3.3 ) > 0.1 : dac_set ( 0 , 3.3 ) time . sleep ( 0.01 ) # Allow settling new_val = dac_get ( 0 ) if abs ( new_val - 3.3 ) > 0.1 : print ( f \"Error: DAC0 failed to set. Got { new_val } V\" ) 2. Structured State Snapshot A single command to return the complete board state as a formatted JSON string, enabling detailed programmatic reasoning and full state management. # Get the complete current state as a formatted JSON string snapshot = get_state () # The snapshot includes: # - power: Settings for TOP_RAIL, BOTTOM_RAIL, DAC0, DAC1 # - nets: All active connections, names, colors, and voltage assignments # - gpio: Current configuration and state of all GPIO pins # Apply a state back to the hardware # set_state(json_string, clear_first=True) # If clear_first=True (default), it resets the board before applying set_state ( snapshot ) 3. Search-First Component Handling Ground knowledge by searching for pinouts before asking the user. Workflow: 1. User: \"I have a BME280.\" 2. Agent: search_web ( \"BME280 pinout SPI I2C\" ) 3. Agent: \"I see the BME280 supports both SPI and I2C. Which one are you using?\" 4. Batch Operations Process information efficiently in large chunks to reduce round-trips and ensure atomic updates. The recommended way to perform complex batch reconfigurations is to fetch the current state, modify it in Python, and re-apply it. # Recommended Batch Workflow: state_json = get_state () state = json . loads ( state_json ) # 1. Modify connections state [ 'nets' ] . append ({ \"index\" : 10 , \"name\" : \"SIGNAL\" , \"nodes\" : [ 5 , 12 , \"D7\" ]}) # 2. Update power settings state [ 'power' ][ 'top_rail' ] = 3.3 # 3. Configure GPIO state [ 'gpio' ][ 0 ][ 'dir' ] = \"OUTPUT\" state [ 'gpio' ][ 0 ][ 'value' ] = True # 4. Apply all changes at once set_state ( json . dumps ( state )) 5. Return Values Over Prints Tools should return data structures (lists, dicts) for programmatic use, not just print to stdout. 6. undo via Slot Backup Always save the current state to a scratch slot (e.g. slot 7) before destructive operations like nodes_clear () . 7. Context-Aware Error Recovery Error messages should include suggested_fix fields to allow self-correction without user intervention. 8. Interactive Conversation Patterns Explore First, Act Later : Probe and measure before applying power to unknown circuits. Show, Don't Just Do : Explain actions via oled_print () and print () before executing them to keep the user informed. Implementation Status Feature Status connect () , disconnect () , is_connected () \u2705 Implemented dac_set () , adc_get () , ina_ * () \u2705 Implemented gpio_ * () , pwm () \u2705 Implemented oled_print () , probe_ * () \u2705 Implemented WaveGen tools \u2705 Implemented Slot management \u2705 Implemented get_state () / set_state () snapshot \u2705 Implemented Slot backup for undo \u2705 Implemented (use save_slot ( 7 ) before destructive ops)","title":"Odds and Ends"},{"location":"09.8-odds-and-ends/#odds-and-ends","text":"","title":"Odds and Ends"},{"location":"09.8-odds-and-ends/#whats-new-in-jumperlos","text":"JumperlOS is now a proper operating system with a priority-based task scheduler! This is a huge refactor from the original firmware: Viper IDE and Micropython raw REPL - Live code on the Jumperless' file system in your browser Priority-based task scheduler - Each component has a service () routine that checks whether it should do anything, replacing the old busy-wait loop Live updating - Edits to the YAML state files will live update with new connections (whether you're editing them in the onboard editor or as a mounted USB MSC device on your computer) Better fonts - New fonts available: Berkeley , Iosevka , Pragmat [ ism ] YAML connection files - More permissive of malformed syntax Unified syntax highlighting - Works consistently in eKilo , python , and normal input after > Encoder-based connections - Use the clickwheel to scroll through and select nodes without touching the probe Current sensing marching ants - Animated visual feedback showing current flow direction between I+ and I- connections Python context switching - Toggle between global and python connection contexts in the MicroPython REPL The JumperlOS firmware repo is at https://github.com/Architeuthis-Flux/JumperlOS","title":"What's New in JumperlOS"},{"location":"09.8-odds-and-ends/#safety-info","text":"Here's an image of the little card that should have been inside your box Never put voltages above +9V or below -9V anywhere on this board. Don't use unpowered, the crossbars need power to block voltage too. Don't power externally, use the internal power supplies (rails / DACs). It can be powered from the 5V and GND pins on the Nano header or the FPC adapter instead of USB. External signals are okay, as long as the board remains powered. This board gets fairly warm in normal operation from the LEDs, if it ever gets hot, unplug it immediately and let me know. When the switch on the probe is set to Select Mode, it should only be used on the gold probe sense pads. The probe tip in Select Mode is always at 3.3V. Don't stab yourself or others with the probe, unless it's in self-defense. Do not eat your Jumperless V5. When in doubt, don't hesitate to ask! There are a lot of exceptions to these if you know what you're doing. It's pretty hard to permanently damage this board. Some things (usually external power with the Jumperless off) can cause lockup on the analog CMOS switches , but the current limiting resistors on their power supply pins generally keep them from drawing so much current that they permanently break. In situations where one chip is getting crazy hot, the first thing to try is to unplug the Jumperless, let it cool down, and try it again (obviously, change whatever you think was causing it). Most of the time they go back to normal after some rest. Don't let any of this scare you, I'd rather you just pretend it's indestructable and use it with reckless abandon. So if you manage to break anything, just let me know and I'll send out a fresh one and a return label, no questions asked*. *Actually, a ton of questions asked, so we can figure out how it happened and maybe prevent it from happening to someone else. But the point is I don't care if it's clearly your fault and not some manufacturing defect, I will make sure you have a working Jumperless. It's even printed on the box","title":"Safety Info"},{"location":"09.8-odds-and-ends/#joom","text":"You can get the .uf2 file here: https://github.com/Architeuthis-Flux/joom/releases/download/0.0.1/joom_full.uf2 You'll need to put the Jumperless in bootloader mode (unplug it, press the button on the back side of the USB port, plug it back in, then drag this UF2 file onto the drive called RP2350 that pops up) Connect a speaker between the lower RST pin (the one closer to the breadboard) on the Nano header and GND for sound. When you're done playing Doom in a blindness simulator, just reload the regular firmware the same way as above. https://github.com/Architeuthis-Flux/JumperlessV5/releases/latest","title":"Joom"},{"location":"09.8-odds-and-ends/#bandwidth","text":"Michael has done some awesome work characterizing the bandwidth of the Jumperless . The TL;DR is just the physical breadboard puts the 3dB rolloff t ~13MHz, and a signal passing through the crossbar matrix brings it down to around ~8MHz. It makes sense these are pretty high, these CH446Qs were originally made for switching video signals so bandwidth was pretty important when they were designing them. Keep in mind this isn't a hard limit, it's just where the signal gets attenuated by the (arbitrarilyish) defined 3dB, so your signal's amplitude is reduced by \u221a2.","title":"Bandwidth"},{"location":"09.8-odds-and-ends/#animations","text":"The Jumperless uses LED animations to show the state of different components on the breadboard.","title":"Animations"},{"location":"09.8-odds-and-ends/#rail-animations","text":"If it's a rail, those are animated and should be a continuous slow pulsing toward the top or bottom depending on the rail.","title":"Rail Animations"},{"location":"09.8-odds-and-ends/#adc-animations","text":"ADCs are green at 0V, and go through the spectrum to red at +5V, and get whiter hot pink toward +8V. Negative voltages are kinda blue/icy and do that same thing with the \"cold\" colors towards -8V.","title":"ADC Animations"},{"location":"09.8-odds-and-ends/#gpio-animations","text":"","title":"GPIO Animations"},{"location":"09.8-odds-and-ends/#input-mode","text":"GPIO as inputs are animated with a white pulsing (this might be broken in that FW release, I'm fixing that right now actually, and will just be purple/white) when floating, red for high, green for low","title":"Input Mode"},{"location":"09.8-odds-and-ends/#output-mode","text":"GPIO outputs will be either green or red depending on their state","title":"Output Mode"},{"location":"09.8-odds-and-ends/#whats-that-buffer_in-dac_0-bridge-thats-always-there","text":"That gets added to power the probe LEDs , it's kinda weird, but to multiplex 3.3V, GND, LED data, 2 buttons, and a +-9V tolerant analog line over the 4 wires on a TRRS cable, the line powering those LEDs is shared. The connect / measure switch is a Dual Pole Dual Throw (DPDT) switch. The probe tip needs to be at a steady 3.3V to be read by the probe sense pads which is a big resistive divider sensed by a single ADC . When you have it in select mode, the probe tip is getting 3.3V from a GPIO on the RP2350B driven high , and the LEDs get their power from the analog line, which is ROUTABLE_BUFFER_IN connected to DAC 0 set to 3.3V. When you switch to measure mode, those roles get swapped, the LEDs are powered by that GPIO , and the probe tip is now ROUTABLE_BUFFER_IN . In the current firmware, that just stays at 3.3V so you can kinda sense pads in either mode (you may notice the sensing is a lot wonkier, that's because the DAC isn't perfectly calibrated to output exactly 3.3V.) But in the future, there will be some other stuff you can do in that mode treating it as an analog line (and of course, I'll forget to update this, if it's after like June 2025, double check this is still true.)","title":"What's that BUFFER_IN - DAC_0 bridge that's always there?"},{"location":"09.8-odds-and-ends/#a-side-effect-of-needing-a-crossbar-connection-to-light-the-probe-is-that-the-leds-in-select-mode-act-as-a-test-of-whether-the-jumperless-is-properly-making-connections","text":"","title":"A side effect of needing a crossbar connection to light the probe is that the LEDs in Select Mode act as a test of whether the Jumperless is properly making connections."},{"location":"09.8-odds-and-ends/#why-am-i-using-one-of-the-precious-two-dacs-and-not-another-gpio","text":"The answer is switch position sensing. You may notice there's no obvious way for the Jumperless to know where the switch is set, so I had to get creative on this one. DAC 0 's output is hardwired to go through a current sense shunt resistor, so when DAC 0 is powering the probe LEDs , they'll be drawing some current I can measure with one of the INA219 s, and therefore I can be reasonably confident that the switch is in the select position. If you need both DAC s, you can just get rid of this connection and the probe LEDs won't light up, but other than aesthetics, it really has no effect on functionality. Or you connect ROUTABLE_BUFFER_IN to a GPIO and set it high and just lose the ability to sense where the switch is.","title":"Why am I using one of the precious two DACs and not another GPIO?"},{"location":"09.8-odds-and-ends/#ai-generated-wiki","text":"If you want to read a wiki generated by AI and ask it questions about how this thing works and how to use it, DeepWiki was surprisingly accurate (enough.) The docs on this site are more about how to use your Jumperless, this is more geared toward helping understand the circuitry and code.","title":"AI Generated Wiki"},{"location":"09.8-odds-and-ends/#onboard-help","text":"Use help or [ command ] ? for onboard documentation","title":"Onboard Help"},{"location":"09.8-odds-and-ends/#github-releases","text":"If you want more info about each feature when I was particularly excited about it, I usually write about the new features in the Release notes on Github .","title":"GitHub Releases"},{"location":"09.8-odds-and-ends/#schematic","text":"Here's the schematic that's printed on the inner flap of the box If you want look at the schematic and PCB together and don't feel like downloading the whole thing and opening it in KiCad, you can open it in the browser with KiCanvas here","title":"Schematic"},{"location":"09.8-odds-and-ends/#writing-native-apps","text":"Writing Apps","title":"Writing Native apps"},{"location":"09.8-odds-and-ends/#heres-a-the-example-app-that-should-show-the-calls-for-most-of-the-things-you-might-want-to-do","text":"You can do literally anything the Jumperless can in an app, so if there's a specific thing, lmk and I'll write an example. Until I make this into a proper operating system, what you're doing when you write an App is just writing a function in the main firmware. There's really no guard rails, and the API is just any function in the firmware.","title":"Here's a the example app that should show the calls for most of the things you might want to do"},{"location":"09.8-odds-and-ends/#first-get-it-platformio-set-up-to-flash-code","text":"So fork the firmware here: https://github.com/Architeuthis-Flux/JumperlOS I'm using PlatformIO in VSCode. And it should just work to open the RP23V50firmware folder in that (you'll probably need to comment out upload_port = / dev / cu . usbmodemJLV5port1 in Platformio . ini so it'll just automatically find it) You should probably try to just load the firmware just to make sure everything works.","title":"First get it PlatformIO set up to flash code"},{"location":"09.8-odds-and-ends/#to-write-an-app","text":"Before you go writing your app, follow these steps to make it so it's listed in the App library and you can run it from the menus. Go to menuTree . h and add the name of your app under Apps \\ n \\ (shown as - Custom App \\ n \\ here, it needs to fit in 7x2 chars to show on the breadboard) Go to Apps . h and declare your function where you'll write your app Go to Apps . cpp and add a struct in the struct app apps [ 30 ] for your app { \"Name\" , index , ?? idk , name of the function ( unused )} Go to Apps . cpp > runApp () and add a case for your app's index (this is so you can also find it by index rather than exact matching the name \"Custom App\" Make a function that's the entirety of your app, I just pushed a demo function called customApp ( void ) with some (non exhaustive) examples of things you can do from an app. Run your app with the clickwheel, Apps > Custom App . The quick way run \"Custom App\" is to just enter 2 in the main menu, or just use the clickwheel and go Apps > Custom App. If you want to add your own shortcut, find an unused menu character and add a case '3' : { runApp ( 3 ); // the app index you set above break ; } in the big main menu switch statement in main . cpp .","title":"To write an App"},{"location":"09.8-odds-and-ends/#to-actually-write-the-app","text":"The code for Custom App is an example of the calls available with comments telling you what's going on. There are tons more, but what's shown there are the higher-level helper functions that should roughly do what they say they're doing.","title":"To actually write the app"},{"location":"09.8-odds-and-ends/#llm-tool-specification-for-jumperless-v5","text":"A guide for LLMs with some tips to control the Jumperless V5.","title":"LLM Tool Specification for Jumperless V5"},{"location":"09.8-odds-and-ends/#quick-reference","text":"Category Key Tools Connections connect () , disconnect () , nodes_clear () , save_slot () , load_slot () Voltage dac_set () , adc_get () Current ina_get_current () , ina_get_power () GPIO gpio_set () , gpio_get () , gpio_set_dir () , pwm () User Interaction oled_print () , probe_read_blocking () , probe_button () Graphic Overlays overlay_set () , overlay_clear () , overlay_set_pixel () State get_state () , set_state () (Refer to the full Micropython API Reference )","title":"Quick Reference"},{"location":"09.8-odds-and-ends/#communication-methods","text":"","title":"Communication Methods"},{"location":"09.8-odds-and-ends/#method-1-direct-python-commands-main-serial-port","text":"Prefix single-line Python with > on the main serial port (Port 1). Best for: Single commands, status checks. > connect ( 1 , 5 ) > voltage = adc_get ( 0 ) > oled_print ( f \"V = { voltage : .2f } \" ) > print ( f \"V = { voltage : .2f } \" )","title":"Method 1: Direct Python Commands (Main Serial Port)"},{"location":"09.8-odds-and-ends/#method-2-viperide-raw-repl-3rd-usb-port","text":"The third USB port provides a MicroPython Raw REPL. Best for: Complex logic, loops, automated testing scripts. # Full scripts run on port 3 import time for i in range ( 10 ): voltage = adc_get ( 0 ) print ( f \"Reading { i } : { voltage : .2f } V\" ) time . sleep ( 0.5 )","title":"Method 2: ViperIDE / Raw REPL (3rd USB Port)"},{"location":"09.8-odds-and-ends/#method-3-arduino-tags-via-uart","text":"From an Arduino connected to the Jumperless. Best for: Hybrid Arduino/Python projects. Serial . print ( \"<p>connect(1, 5)</p>\" ); // Python command Serial . print ( \"<j>n</j>\" ); // Menu command","title":"Method 3: Arduino Tags (via UART)"},{"location":"09.8-odds-and-ends/#method-4-single-character-commands-main-serial-port","text":"Raw characters sent to Port 1 trigger immediate menu actions. Best for: Fast state dumps, clearing the board, or manual resets. J <-- Immediate JSON state dump L <-- Immediate JSON state load ( paste JSON after L ) x <-- Immediate board clear","title":"Method 4: Single-Character Commands (Main Serial Port)"},{"location":"09.8-odds-and-ends/#usb-port-structure","text":"macOS / Linux: | Port | Name | Function | |------|------|----------| | 1 (main) | JLV5port1 | Main terminal, menu, > Python commands | | 2 | JLV5port3 | Arduino UART passthrough | | 3 | JLV5port5 | MicroPython Raw REPL (ViperIDE) | Windows: | Port | Name | Function | |------|------|----------| | 1 (main) | COM1 | Main terminal, menu, > Python commands | | 2 | COM2 | Arduino UART passthrough | | 3 | COM3 | MicroPython Raw REPL (ViperIDE) |","title":"USB Port Structure"},{"location":"09.8-odds-and-ends/#hardware-overview","text":"","title":"Hardware Overview"},{"location":"09.8-odds-and-ends/#physical-layout","text":"60 breadboard rows (1-60) with 5 RGB LEDs underneath each Arduino Nano header with routable pins OLED display (128x32, optional but recommended) Probe with touch-sensing tip, 2 buttons, mode switch Clickwheel rotary encoder with button 12 CH446Q crossbar chips (A-L) for routing (~80\u03a9 per path)","title":"Physical Layout"},{"location":"09.8-odds-and-ends/#power","text":"TOP_RAIL / BOTTOM_RAIL : Main power rails (\u00b18V, 300mA) DAC0 / DAC1 : Auxiliary voltage outputs (\u00b18V, 300mA each) DAC0 connects to Probe Tip & INA0 DAC0 and DAC1 are 0-3.3V native but amplified to \u00b18V Current Limits : ~300mA per rail/DAC","title":"Power"},{"location":"09.8-odds-and-ends/#measurement","text":"ADC0-3 : 4 user analog inputs (\u00b18V range) INA0 : High-side current monitor on DAC0 (Probe Tip) INA1 : High-side current monitor on TOP_RAIL (configurable)","title":"Measurement"},{"location":"09.8-odds-and-ends/#gpio","text":"10 GPIO pins (RP2350B, 3.3V logic) Defined as GPIO_1 - GPIO_8 (physical gpio 20-27 on RP2350B), and UART_TX (gpio 0 on RP2350B) and UART_RX (gpio 1 on RP2350B) 5V Tolerant Inputs : Yes PWM : Hardware PWM 0.1Hz-62.5MHz on all pins","title":"GPIO"},{"location":"09.8-odds-and-ends/#node-addressing","text":"","title":"Node Addressing"},{"location":"09.8-odds-and-ends/#breadboard-rows","text":"1 through 60","title":"Breadboard Rows"},{"location":"09.8-odds-and-ends/#power-rails","text":"Node Description TOP_RAIL Top power rail (default 5V) BOTTOM_RAIL Bottom rail (default GND) GND Ground reference DAC0 DAC0 (connected to probe tip and INA0) DAC1 DAC1 (8V tolerant)","title":"Power Rails"},{"location":"09.8-odds-and-ends/#arduino-pins","text":"D0 - D13 , A0 - A7 , AREF , RESET","title":"Arduino Pins"},{"location":"09.8-odds-and-ends/#gpio_1","text":"GPIO_1 - GPIO_8 , UART_TX , UART_RX","title":"GPIO"},{"location":"09.8-odds-and-ends/#adccurrent-sense","text":"ADC0 - ADC3 , ISENSE_PLUS , ISENSE_MINUS","title":"ADC/Current Sense"},{"location":"09.8-odds-and-ends/#core-tool-definitions","text":"","title":"Core Tool Definitions"},{"location":"09.8-odds-and-ends/#connections-slots","text":"connect ( node1 , node2 , duplicates =- 1 ) # Create connection disconnect ( node1 , node2 ) # Remove connection nodes_clear () # Remove ALL connections is_connected ( node1 , node2 ) # Check if connected # Slot Management save_slot ( slot_id ) # Save current state to slot 0-7 load_slot ( slot_id ) # Load state from slot 0-7 get_current_slot () # Returns active slot number # JSON State API (Recommended for LLMs) get_state () # Get complete state as JSON string set_state ( json , clear_first = True ) # Apply state from JSON string","title":"Connections &amp; Slots"},{"location":"09.8-odds-and-ends/#voltage-control","text":"dac_set ( channel , voltage , save = True ) # Set voltage (-8V to +8V) dac_get ( channel ) # Get current setting # Channels: 0/DAC0, 1/DAC1, 2/TOP_RAIL, 3/BOTTOM_RAIL","title":"Voltage Control"},{"location":"09.8-odds-and-ends/#measurement_1","text":"adc_get ( channel ) # Read ADC voltage (channels 0-3) ina_get_current ( sensor ) # Read current in Amps (0=DAC0/Probe, 1=TOP_RAIL) ina_get_voltage ( sensor ) # Read INA bus voltage ina_get_power ( sensor ) # Read power in Watts","title":"Measurement"},{"location":"09.8-odds-and-ends/#gpio-pwm","text":"gpio_set ( pin , value ) # Set output (True=3.3V, False=0V) gpio_get ( pin ) # Returns HIGH, LOW, or FLOATING gpio_set_dir ( pin , direction ) # True=OUTPUT, False=INPUT gpio_set_pull ( pin , pull ) # 1=PULLUP, -1=PULLDOWN, 0=NONE pwm ( pin , frequency , duty ) # Start PWM (duty: 0.0-1.0) pwm_stop ( pin ) # Stop PWM","title":"GPIO &amp; PWM"},{"location":"09.8-odds-and-ends/#waveform-generator-wavegen","text":"# Setup wavegen_set_output ( channel ) # 0=DAC0, 1=DAC1 (Default) wavegen_set_wave ( type ) # 0=Sine, 1=Square, 2=Tri, 3=Saw wavegen_set_freq ( hz ) # Frequency in Hz wavegen_set_amplitude ( vpp ) # Peak-to-Peak Voltage (e.g. 3.3) wavegen_set_offset ( volts ) # DC Offset (e.g. 1.65) # Control wavegen_start ( 1 ) # Start output wavegen_stop () # Stop output","title":"Waveform Generator (WaveGen)"},{"location":"09.8-odds-and-ends/#user-interaction","text":"oled_print ( text , size = 2 ) # Display on OLED oled_clear () # Clear display probe_read_blocking () # Wait for probe touch, return row probe_read_nonblocking () # Check without waiting (-1 if none) probe_button () # Returns CONNECT, REMOVE, or NONE clickwheel_get_direction () # Returns UP, DOWN, or NONE clickwheel_get_button () # Returns PRESSED, HELD, RELEASED","title":"User Interaction"},{"location":"09.8-odds-and-ends/#graphic-overlays-breadboard-leds","text":"The breadboard LEDs are addressed as a 10x30 grid (Row 1-10, Col 1-30). Rows 1-5 are top half (E-A), Rows 6-10 are bottom half (F-J). # overlay_set(name, x, y, height, width, colors) # Colors can be flat list or 2D list of 0xRRGGBB integers overlay_set ( \"box\" , 1 , 1 , 5 , 5 , [ 0x550000 ] * 25 ) overlay_clear ( \"box\" ) # Remove overlay overlay_clear_all () # Remove all overlay_set_pixel ( x , y , color ) # Set single pixel (1-30, 1-10)","title":"Graphic Overlays (Breadboard LEDs)"},{"location":"09.8-odds-and-ends/#system-filesystem","text":"# Standard Python I/O is supported! with open ( '/config.txt' , 'r' ) as f : print ( f . read ()) # List files import os os . listdir ( '/' ) get_net_info ( netNum ) # Get dict with name, color, nodes get_num_nets () # Count of active nets get_num_bridges () # Count of bridges print_bridges () # Print bridge table","title":"System &amp; Filesystem"},{"location":"09.8-odds-and-ends/#single-character-command-reference-port-1-only","text":"These commands are processed immediately when sent as raw characters (no > prefix) to the main serial port. Char Description Action J Show JSON Dumps the complete board state as a JSON string. L Load JSON Prepares the board to receive a JSON state. Paste JSON and end with an empty line. x Clear All Removes all connections and resets paths. n List Nets Prints a human-readable list of all active nets. b Show Bridges Prints the internal bridge array. ~ Show Config Dumps the current config . txt settings. | + | Add | Add connections (e.g., + 1 - 5 , 10 - 12 ). | | - | Remove | Remove connections (e.g., - 1 - 5 ). | | v | Read ADC | Follow with a channel (0-4) to get a quick voltage reading. | | @ | I2C Scan | Scans for I2C devices on a row (e.g., @ 10 ). | | r | Reset Arduino | Follow with t or b to reset the Top or Bottom Arduino. | | A | Connect Arduino UART | Connects Jumperless's UART to the Arduino D0 and D1 pins ( a to disconnect). | | m | Menu | Displays the help menu ( e to show more options). | | [ command ] ? | Help | Displays the help menu for the specified command. | | help | Help Menu | Displays the help menu. |","title":"Single-Character Command Reference (Port 1 Only)"},{"location":"09.8-odds-and-ends/#llm-mental-model-file-format","text":"LLMs should maintain a persistent JSON model of what they believe is physically on the breadboard. This model has confidence values that increase through user confirmation or automated testing.","title":"LLM Mental Model File Format"},{"location":"09.8-odds-and-ends/#mental-model-schema","text":"{ \"version\" : \"1.0\" , \"last_updated\" : \"2026-02-06T22:00:00Z\" , \"nano_header\" : { \"device\" : \"arduino_nano\" , // \"arduino_nano\", \"rp2040\", \"rpi_40pin_adapter\", \"oled_only\", \"empty\" \"confidence\" : 0.9 , \"notes\" : \"User confirmed Arduino Nano Every\" }, \"power_rails\" : { \"TOP_RAIL\" : { \"voltage\" : 5.0 , \"confidence\" : 1.0 , \"source\" : \"measured\" }, \"BOTTOM_RAIL\" : { \"voltage\" : 0.0 , \"confidence\" : 1.0 , \"source\" : \"measured\" } }, \"components\" : [ { \"id\" : \"comp_001\" , \"type\" : \"resistor\" , \"value\" : 1000 , \"unit\" : \"ohms\" , \"tolerance\" : 0.05 , \"pins\" : [ 5 , 10 ], \"confidence\" : 0.95 , \"detection_method\" : \"measured\" , \"notes\" : \"Measured 987\u03a9 between rows 5-10\" }, { \"id\" : \"comp_002\" , \"type\" : \"led\" , \"color\" : \"red\" , \"forward_voltage\" : 1.8 , \"pins\" : { \"anode\" : 15 , \"cathode\" : 16 }, \"confidence\" : 0.7 , \"detection_method\" : \"user_stated\" , \"notes\" : \"User said 'red LED on rows 15-16'\" }, { \"id\" : \"comp_003\" , \"type\" : \"module\" , \"name\" : \"SSD1306 OLED\" , \"pins\" : { \"GND\" : 20 , \"VCC\" : 21 , \"SCL\" : 22 , \"SDA\" : 23 }, \"confidence\" : 0.6 , \"detection_method\" : \"inferred\" , \"notes\" : \"Searched pinout, user confirmed row 20\" } ], \"wires\" : [ { \"from\" : 1 , \"to\" : 30 , \"confidence\" : 0.8 , \"detection_method\" : \"continuity_test\" } ], \"unknowns\" : [ { \"rows\" : [ 40 , 41 , 42 ], \"notes\" : \"Something detected but not identified\" } ] }","title":"Mental Model Schema"},{"location":"09.8-odds-and-ends/#nano-header-device-types","text":"Device Description arduino_nano Arduino Nano/Every/RP2040 etc. rp2040 Bare RP2040 board rpi_40pin_adapter RPi GPIO adapter board oled_only SBC/SMD/OLED adapter for just the OLED empty Nothing plugged in","title":"Nano Header Device Types"},{"location":"09.8-odds-and-ends/#confidence-levels","text":"Level Source Meaning 1.0 measured Electrically verified 0.9 user_confirmed User explicitly confirmed 0.7 user_stated User mentioned it casually 0.5 inferred LLM guessed from context 0.3 assumed Default assumption","title":"Confidence Levels"},{"location":"09.8-odds-and-ends/#increasing-confidence","text":"Method Confidence Boost User confirms \"yes that's right\" +0.2 Electrical measurement matches +0.3 Multiple consistent tests +0.1 per test User provides datasheet Set to 0.95","title":"Increasing Confidence"},{"location":"09.8-odds-and-ends/#workflows-for-llms","text":"","title":"Workflows for LLMs"},{"location":"09.8-odds-and-ends/#1-circuit-safe-check-mental-model","text":"CRITICAL : The Jumperless prevents internal shorts, but cannot see external wires or components on the breadboard. If a user has a physical wire connecting Row 5 to Row 10, connecting TOP_RAIL -> 5 and GND -> 10 will cause a dead short through the user's wire. Workflow: 1. Ask : \"What is currently on the breadboard? (Wires, components, etc)\" 2. Model : Build the mental model JSON with low confidence 3. Test : Run detect_component () on key rows to verify 4. Update : Increase confidence as tests confirm the model # Safe Power-Up Sequence oled_print ( \"Checking for shorts...\" ) # Find an unused ADC unused_adc = None for i in range ( 4 ): name = f \"ADC { i } \" is_used = False for net in get_all_nets (): if name in net [ 'nodes' ]: is_used = True break if not is_used : unused_adc = i break if unused_adc is not None : connect ( 5 , f \"ADC { unused_adc } \" ) connect ( 10 , DAC1 ) # ... model[\"wires\"].append({\"from\": 5, \"to\": 10, \"confidence\": 0.95}) else: connect(5, TOP_RAIL) connect(10, GND) ### 2. Identifying User Circuits Use the Probe to \"see\" the board . ``` jython oled_print ( \"Touch the input of your circuit\" ) input_row = probe_read_blocking () oled_print ( f \"Input is at row { input_row } \" )","title":"1. Circuit Safe-Check (Mental Model)"},{"location":"09.8-odds-and-ends/#3-automated-characterization","text":"Use WaveGen and ADC to treat the circuit as a black box. connect ( DAC1 , 1 ) wavegen_set_output ( 1 ) wavegen_set_freq ( 100 ) wavegen_set_wave ( 0 ) # Sine wavegen_start ( 1 ) connect ( ADC0 , 10 ) for i in range ( 5 ): val = adc_get ( 0 ) print ( f \"Sample { i } : { val } V\" ) time . sleep ( 0.01 )","title":"3. Automated Characterization"},{"location":"09.8-odds-and-ends/#component-library-dynamic-lookup","text":"When a user mentions a hardware module, search the web for its pinout and build a JSON definition on the fly. Workflow: 1. User mentions: \"I have an SSD1306 OLED on the breadboard\" 2. LLM searches: \"SSD1306 OLED pinout\" 3. LLM builds JSON from search results and adds it to mental_model [ \"components\" ] Example: NeoPixel Stick { \"name\" : \"NeoPixel Stick 8\" , \"pins\" : { \"GND\" : { \"default\" : \"GND\" , \"offset\" : 0 }, \"5V\" : { \"default\" : \"TOP_RAIL\" , \"offset\" : 1 }, \"DIN\" : { \"default\" : \"GPIO_1\" , \"offset\" : 2 }, \"DOUT\" : { \"default\" : \"NC\" , \"offset\" : 7 } }, \"width\" : 8 , \"voltage\" : \"5V\" , \"notes\" : \"3.3V GPIO works for most NeoPixels. Data on offset 2.\" } Key : The offset field defines pin position relative to pin 1. When user says \"pin 1 is on row X\", calculate absolute rows as row = X + offset .","title":"Component Library (Dynamic Lookup)"},{"location":"09.8-odds-and-ends/#safety-guidelines-for-llms","text":"Voltage Check : ADCs are buffered for \u00b18V. The board is \u00b19V tolerant overall. Short Circuit Prevention : The firmware will ignore requests to connect TOP_RAIL directly to BOTTOM_RAIL or GND . Confirm Power : Ask: \"Is the board powered via USB?\" (No barrel jack exists). Crossbar Resistance : Remember ~80\u03a9 per connection. High current paths will have voltage drop. Measure voltage at the destination with an ADC to compensate.","title":"Safety Guidelines for LLMs"},{"location":"09.8-odds-and-ends/#llm-preferences-claudes-additions","text":"","title":"LLM Preferences (Claude's Additions)"},{"location":"09.8-odds-and-ends/#1-structured-state-snapshot","text":"What I want : A single command that returns the complete board state as structured data (JSON/dict), not just printed text. This lets me reason about the state programmatically. # REQUESTED: get_state() -> dict # Returns something like: { \"slot\" : 0 , \"bridges\" : [[ 1 , 5 ], [ 5 , \"TOP_RAIL\" ], [ 10 , \"GND\" ]], \"rails\" : { \"TOP_RAIL\" : 5.0 , \"BOTTOM_RAIL\" : 0.0 , \"DAC0\" : 3.3 , \"DAC1\" : 0.0 }, \"gpio\" : [ { \"pin\" : 1 , \"dir\" : \"OUTPUT\" , \"value\" : True , \"pull\" : \"NONE\" }, { \"pin\" : 2 , \"dir\" : \"INPUT\" , \"value\" : False , \"pull\" : \"PULLUP\" } ], \"adc_snapshot\" : [ 3.28 , 0.01 , 5.02 , - 0.03 ] # Quick reading of all 4 } Why : Currently I have to call get_num_bridges () , get_net_info () for each net, etc. A single snapshot is faster and less error-prone for building my mental model.","title":"1. Structured State Snapshot"},{"location":"09.8-odds-and-ends/#2-return-values-not-just-prints","text":"For debugging, I prefer return values over print statements : Instead of... I prefer... print_nets () \u2192 prints to serial get_nets () \u2192 returns list of net dicts print_bridges () \u2192 prints to serial get_bridges () \u2192 returns list of bridge tuples print_paths_compact () \u2192 prints get_paths () \u2192 returns routing info Why : When I call a tool, I want to capture the result and reason about it. Print output goes to the user's terminal but isn't easily parsed by my next step.","title":"2. Return Values, Not Just Prints"},{"location":"09.8-odds-and-ends/#3-error-return-conventions","text":"Consistent error handling helps me recover: # Good: Returns None or raises exception with message result = connect ( 999 , 5 ) # Invalid node # Returns: None (or {\"error\": \"Invalid node: 999\"}) # Good: Returns success/failure boolean with reason success , msg = disconnect ( 1 , 5 ) # Returns: (True, \"Disconnected\") or (False, \"No such connection\")","title":"3. Error Return Conventions"},{"location":"09.8-odds-and-ends/#4-undo-via-slot-backup","text":"For destructive operations like nodes_clear () , the existing slot system provides an undo mechanism: # Before destructive operation, save current state to a backup slot save_slot ( 7 ) # Save to slot 7 as backup nodes_clear () # Now safe to clear # If user wants to undo: load_slot ( 7 ) # Restore from backup Pattern : Always save the current slot to an unused slot (7 is a good \"scratch\" slot) before any destructive action. This provides a built-in undo without needing special confirm flags.","title":"4. Undo via Slot Backup"},{"location":"09.8-odds-and-ends/#5-measurement-with-context","text":"When measuring, I often want multiple samples or statistics: # REQUESTED: adc_get_stats(channel, samples=10) # Returns: {\"mean\": 3.28, \"min\": 3.25, \"max\": 3.31, \"stddev\": 0.02} Why : A single ADC reading might be noisy. Having built-in averaging/stats means I don't have to write loops for every measurement.","title":"5. Measurement with Context"},{"location":"09.8-odds-and-ends/#6-interactive-conversation-patterns","text":"When helping users debug, I find these patterns effective: Explore First, Act Later : User : \"My LED isn't lighting up\" Me : 1. \"Where is your LED connected? (Touch the anode with the probe)\" 2. [ probe_read_blocking () \u2192 row 15 ] 3. \"I see row 15. Let me check the voltage there...\" 4. [ connect ( ADC0 , 15 ), adc_get ( 0 ) \u2192 0.02 V ] 5. \"Row 15 is at 0V. Is it supposed to be connected to power?\" Show, Don't Just Do : # Before making a connection, describe it: oled_print ( \"Connecting row 5 to 5V...\" ) connect ( 5 , TOP_RAIL ) oled_print ( \"Done! LED should light now\" ) Verify After Acting : # After connecting power, verify it worked: connect ( 5 , TOP_RAIL ) connect ( ADC0 , 5 ) v = adc_get ( 0 ) if abs ( v - 5.0 ) < 0.5 : oled_print ( f \"\u2713 Row 5 at { v : .1f } V\" ) else : oled_print ( f \"\u26a0 Expected 5V, got { v : .1f } V\" ) disconnect ( ADC0 , 5 )","title":"6. Interactive Conversation Patterns"},{"location":"09.8-odds-and-ends/#llm-best-practices-future-tools","text":"This section consolidates recommendations for reliable, high-context hardware interaction.","title":"LLM Best Practices &amp; Future Tools"},{"location":"09.8-odds-and-ends/#1-explicit-state-verification","text":"Trust but verify. Confirm hardware state after critical operations. # Goal: Set DAC0 to 3.3V current = dac_get ( 0 ) if abs ( current - 3.3 ) > 0.1 : dac_set ( 0 , 3.3 ) time . sleep ( 0.01 ) # Allow settling new_val = dac_get ( 0 ) if abs ( new_val - 3.3 ) > 0.1 : print ( f \"Error: DAC0 failed to set. Got { new_val } V\" )","title":"1. Explicit State Verification"},{"location":"09.8-odds-and-ends/#2-structured-state-snapshot","text":"A single command to return the complete board state as a formatted JSON string, enabling detailed programmatic reasoning and full state management. # Get the complete current state as a formatted JSON string snapshot = get_state () # The snapshot includes: # - power: Settings for TOP_RAIL, BOTTOM_RAIL, DAC0, DAC1 # - nets: All active connections, names, colors, and voltage assignments # - gpio: Current configuration and state of all GPIO pins # Apply a state back to the hardware # set_state(json_string, clear_first=True) # If clear_first=True (default), it resets the board before applying set_state ( snapshot )","title":"2. Structured State Snapshot"},{"location":"09.8-odds-and-ends/#3-search-first-component-handling","text":"Ground knowledge by searching for pinouts before asking the user. Workflow: 1. User: \"I have a BME280.\" 2. Agent: search_web ( \"BME280 pinout SPI I2C\" ) 3. Agent: \"I see the BME280 supports both SPI and I2C. Which one are you using?\"","title":"3. Search-First Component Handling"},{"location":"09.8-odds-and-ends/#4-batch-operations","text":"Process information efficiently in large chunks to reduce round-trips and ensure atomic updates. The recommended way to perform complex batch reconfigurations is to fetch the current state, modify it in Python, and re-apply it. # Recommended Batch Workflow: state_json = get_state () state = json . loads ( state_json ) # 1. Modify connections state [ 'nets' ] . append ({ \"index\" : 10 , \"name\" : \"SIGNAL\" , \"nodes\" : [ 5 , 12 , \"D7\" ]}) # 2. Update power settings state [ 'power' ][ 'top_rail' ] = 3.3 # 3. Configure GPIO state [ 'gpio' ][ 0 ][ 'dir' ] = \"OUTPUT\" state [ 'gpio' ][ 0 ][ 'value' ] = True # 4. Apply all changes at once set_state ( json . dumps ( state ))","title":"4. Batch Operations"},{"location":"09.8-odds-and-ends/#5-return-values-over-prints","text":"Tools should return data structures (lists, dicts) for programmatic use, not just print to stdout.","title":"5. Return Values Over Prints"},{"location":"09.8-odds-and-ends/#6-undo-via-slot-backup","text":"Always save the current state to a scratch slot (e.g. slot 7) before destructive operations like nodes_clear () .","title":"6. undo via Slot Backup"},{"location":"09.8-odds-and-ends/#7-context-aware-error-recovery","text":"Error messages should include suggested_fix fields to allow self-correction without user intervention.","title":"7. Context-Aware Error Recovery"},{"location":"09.8-odds-and-ends/#8-interactive-conversation-patterns","text":"Explore First, Act Later : Probe and measure before applying power to unknown circuits. Show, Don't Just Do : Explain actions via oled_print () and print () before executing them to keep the user informed.","title":"8. Interactive Conversation Patterns"},{"location":"09.8-odds-and-ends/#implementation-status","text":"Feature Status connect () , disconnect () , is_connected () \u2705 Implemented dac_set () , adc_get () , ina_ * () \u2705 Implemented gpio_ * () , pwm () \u2705 Implemented oled_print () , probe_ * () \u2705 Implemented WaveGen tools \u2705 Implemented Slot management \u2705 Implemented get_state () / set_state () snapshot \u2705 Implemented Slot backup for undo \u2705 Implemented (use save_slot ( 7 ) before destructive ops)","title":"Implementation Status"},{"location":"10-3d-stand/","text":"3D Printable Stand Here are the 3D models for you to print your own stand for your Jumperless. It's extremely handy to have it propped up like this to read text on the breadboard. Printing Tips Yes, the model is at a weird angle, just drop it down in the slicer, if you want it to hold at a shallower angle, just drop the model through the bed a bit when you slice. Rubber Feet These stick-on rubber feet also make it a lot more solid on your desk (and having the different sizes lets you shim the angle by putting different ones on the front and back.)","title":"3D Printable Stand"},{"location":"10-3d-stand/#3d-printable-stand","text":"Here are the 3D models for you to print your own stand for your Jumperless. It's extremely handy to have it propped up like this to read text on the breadboard.","title":"3D Printable Stand"},{"location":"10-3d-stand/#printing-tips","text":"Yes, the model is at a weird angle, just drop it down in the slicer, if you want it to hold at a shallower angle, just drop the model through the bed a bit when you slice.","title":"Printing Tips"},{"location":"10-3d-stand/#rubber-feet","text":"These stick-on rubber feet also make it a lot more solid on your desk (and having the different sizes lets you shim the angle by putting different ones on the front and back.)","title":"Rubber Feet"},{"location":"10.1-JumperIDE/","text":"# Jumperless Online (JumperIDE) This page hosts JumperIDE , a custom fork of ViperIDE tailored for Jumperless. It\u2019s a browser-based MicroPython IDE so you can write, run, and debug scripts without leaving the docs. Use the IDE The IDE runs in your browser. Connect your Jumperless via USB and use the in-page connection (e.g. WebSerial) to get a REPL, file manager, and editor. If the Jumperless-customized build is deployed, this embed can be switched to that URL (e.g. GitHub Pages for JumperIDE ). About JumperIDE Fork: Architeuthis-Flux/JumperIDE \u2014 ViperIDE with Jumperless-oriented defaults and tweaks. Upstream: ViperIDE by Volodymyr Shymanskyy \u2014 MicroPython/CircuitPython IDE for web and mobile. For full MicroPython workflow (including using the built-in REPL and jumperless module), see MicroPython . Community scripts JumperIDE can load a list of community scripts so you can open or add them from the Scripts tab in the side menu. The script index URL is: Script index: https://docs.jumperless.org/scripts/index.json The index is a JSON file with a scripts array. Each entry has name , description , and url (direct link to the raw . py file). To add your own script, open a pull request that adds an entry to this repo\u2019s docs / scripts / index . json (and optionally add the script file under docs / scripts / or link to a raw URL elsewhere).","title":"10.1 JumperIDE"},{"location":"10.1-JumperIDE/#use-the-ide","text":"The IDE runs in your browser. Connect your Jumperless via USB and use the in-page connection (e.g. WebSerial) to get a REPL, file manager, and editor. If the Jumperless-customized build is deployed, this embed can be switched to that URL (e.g. GitHub Pages for JumperIDE ).","title":"Use the IDE"},{"location":"10.1-JumperIDE/#about-jumperide","text":"Fork: Architeuthis-Flux/JumperIDE \u2014 ViperIDE with Jumperless-oriented defaults and tweaks. Upstream: ViperIDE by Volodymyr Shymanskyy \u2014 MicroPython/CircuitPython IDE for web and mobile. For full MicroPython workflow (including using the built-in REPL and jumperless module), see MicroPython .","title":"About JumperIDE"},{"location":"10.1-JumperIDE/#community-scripts","text":"JumperIDE can load a list of community scripts so you can open or add them from the Scripts tab in the side menu. The script index URL is: Script index: https://docs.jumperless.org/scripts/index.json The index is a JSON file with a scripts array. Each entry has name , description , and url (direct link to the raw . py file). To add your own script, open a pull request that adds an entry to this repo\u2019s docs / scripts / index . json (and optionally add the script file under docs / scripts / or link to a raw URL elsewhere).","title":"Community scripts"},{"location":"11-WritingApps/","text":"- Writing Apps Here's a the example app that should show the calls for most of the things you might want to do You can do literally anything the Jumperless can in an app, so if there's a specific thing, lmk and I'll write an example. Until I make this into a proper operating system, what you're doing when you write an App is just writing a function in the main firmware. There's really no guard rails, and the API is just any function in the firmware. First get it PlatformIO set up to flash code So fork the firmware here: https://github.com/Architeuthis-Flux/JumperlessV5 I'm using PlatformIO in VSCode. And it should just work to open the RP23V50firmware folder in that (you'll probably need to comment out upload_port = / dev / cu . usbmodem101 in Platformio . ini so it'll just automatically find it) You should just open the RP23V50firmware folder, not the entire JumperlessV5 repo, in VSCode. You should probably try to just load the firmware just to make sure everything works. To write an App Before you go writing your app, follow these steps to make it so it's listed in the App library and you can run it from the menus. Go to menuTree . h and add the name of your app under Apps \\ n \\ (shown as - Custom App \\ n \\ here, it needs to fit in 7x2 chars to show on the breadboard) Go to Apps . h and declare your function where you'll write your app Go to Apps . cpp and add a struct in the struct app apps [ 30 ] for your app { \"Name\" , index , ?? idk , name of the function ( unused )} Go to Apps . cpp > runApp () and add a case for your app's index (this is so you can also find it by index rather than exact matching the name \"Custom App\" Make a function that's the entirety of your app, I just pushed a demo function called customApp ( void ) with some (non exhaustive) examples of things you can do from an app. Run your app with the clickwheel, Apps > Custom App . The quick way run \"Custom App\" is to just enter 2 in the main menu, or just use the clickwheel and go Apps > Custom App. If you want to add your own shortcut, find an unused menu character and add a case '3' : { runApp ( 3 ); // the app index you set above break ; } in the big main menu switch statement in main . cpp . To actually write the app The code for Custom App is an example of the calls available with comments telling you what's going on. There are tons more, but what's shown there are the higher-level helper functions that should roughly do what they say they're doing. -","title":"11 WritingApps"},{"location":"11-WritingApps/#writing-apps","text":"","title":"Writing Apps"},{"location":"11-WritingApps/#heres-a-the-example-app-that-should-show-the-calls-for-most-of-the-things-you-might-want-to-do","text":"You can do literally anything the Jumperless can in an app, so if there's a specific thing, lmk and I'll write an example. Until I make this into a proper operating system, what you're doing when you write an App is just writing a function in the main firmware. There's really no guard rails, and the API is just any function in the firmware.","title":"Here's a the example app that should show the calls for most of the things you might want to do"},{"location":"11-WritingApps/#first-get-it-platformio-set-up-to-flash-code","text":"So fork the firmware here: https://github.com/Architeuthis-Flux/JumperlessV5 I'm using PlatformIO in VSCode. And it should just work to open the RP23V50firmware folder in that (you'll probably need to comment out upload_port = / dev / cu . usbmodem101 in Platformio . ini so it'll just automatically find it) You should just open the RP23V50firmware folder, not the entire JumperlessV5 repo, in VSCode. You should probably try to just load the firmware just to make sure everything works.","title":"First get it PlatformIO set up to flash code"},{"location":"11-WritingApps/#to-write-an-app","text":"Before you go writing your app, follow these steps to make it so it's listed in the App library and you can run it from the menus. Go to menuTree . h and add the name of your app under Apps \\ n \\ (shown as - Custom App \\ n \\ here, it needs to fit in 7x2 chars to show on the breadboard) Go to Apps . h and declare your function where you'll write your app Go to Apps . cpp and add a struct in the struct app apps [ 30 ] for your app { \"Name\" , index , ?? idk , name of the function ( unused )} Go to Apps . cpp > runApp () and add a case for your app's index (this is so you can also find it by index rather than exact matching the name \"Custom App\" Make a function that's the entirety of your app, I just pushed a demo function called customApp ( void ) with some (non exhaustive) examples of things you can do from an app. Run your app with the clickwheel, Apps > Custom App . The quick way run \"Custom App\" is to just enter 2 in the main menu, or just use the clickwheel and go Apps > Custom App. If you want to add your own shortcut, find an unused menu character and add a case '3' : { runApp ( 3 ); // the app index you set above break ; } in the big main menu switch statement in main . cpp .","title":"To write an App"},{"location":"11-WritingApps/#to-actually-write-the-app","text":"The code for Custom App is an example of the calls available with comments telling you what's going on. There are tons more, but what's shown there are the higher-level helper functions that should roughly do what they say they're doing. -","title":"To actually write the app"},{"location":"12-llm-tools-specification/","text":"LLM Tool Specification for Jumperless V5 A guide for LLMs with some tips to control the Jumperless V5. Quick Reference Category Key Tools Connections connect () , disconnect () , nodes_clear () , save_slot () , load_slot () Voltage dac_set () , adc_get () Current ina_get_current () , ina_get_power () GPIO gpio_set () , gpio_get () , gpio_set_dir () , pwm () User Interaction oled_print () , probe_read_blocking () , probe_button () Graphic Overlays overlay_set () , overlay_clear () , overlay_set_pixel () State get_state () , set_state () (Refer to the full Micropython API Reference ) Communication Methods Method 1: Direct Python Commands (Main Serial Port) Prefix single-line Python with > on the main serial port (Port 1). Best for: Single commands, status checks. > connect ( 1 , 5 ) > voltage = adc_get ( 0 ) > oled_print ( f \"V = { voltage : .2f } \" ) > print ( f \"V = { voltage : .2f } \" ) Method 2: ViperIDE / Raw REPL (3rd USB Port) The third USB port provides a MicroPython Raw REPL. Best for: Complex logic, loops, automated testing scripts. # Full scripts run on port 3 import time for i in range ( 10 ): voltage = adc_get ( 0 ) print ( f \"Reading { i } : { voltage : .2f } V\" ) time . sleep ( 0.5 ) Method 3: Arduino Tags (via UART) From an Arduino connected to the Jumperless. Best for: Hybrid Arduino/Python projects. Serial . print ( \"<p>connect(1, 5)</p>\" ); // Python command Serial . print ( \"<j>n</j>\" ); // Menu command Method 4: Single-Character Commands (Main Serial Port) Raw characters sent to Port 1 trigger immediate menu actions. Best for: Fast state dumps, clearing the board, or manual resets. J <-- Immediate JSON state dump L <-- Immediate JSON state load ( paste JSON after L ) x <-- Immediate board clear USB Port Structure macOS / Linux: | Port | Name | Function | |------|------|----------| | 1 (main) | JLV5port1 | Main terminal, menu, > Python commands | | 2 | JLV5port3 | Arduino UART passthrough | | 3 | JLV5port5 | MicroPython Raw REPL (ViperIDE) | Windows: | Port | Name | Function | |------|------|----------| | 1 (main) | COM1 | Main terminal, menu, > Python commands | | 2 | COM2 | Arduino UART passthrough | | 3 | COM3 | MicroPython Raw REPL (ViperIDE) | Hardware Overview Physical Layout 60 breadboard rows (1-60) with 5 RGB LEDs underneath each Arduino Nano header with routable pins OLED display (128x32, optional but recommended) Probe with touch-sensing tip, 2 buttons, mode switch Clickwheel rotary encoder with button 12 CH446Q crossbar chips (A-L) for routing (~80\u03a9 per path) Power TOP_RAIL / BOTTOM_RAIL : Main power rails (\u00b18V, 300mA) DAC0 / DAC1 : Auxiliary voltage outputs (\u00b18V, 300mA each) DAC0 connects to Probe Tip & INA0 DAC0 and DAC1 are 0-3.3V native but amplified to \u00b18V Current Limits : ~300mA per rail/DAC Measurement ADC0-3 : 4 user analog inputs (\u00b18V range) INA0 : High-side current monitor on DAC0 (Probe Tip) INA1 : High-side current monitor on TOP_RAIL (configurable) GPIO 10 GPIO pins (RP2350B, 3.3V logic) Defined as GPIO_1 - GPIO_8 (physical gpio 20-27 on RP2350B), and UART_TX (gpio 0 on RP2350B) and UART_RX (gpio 1 on RP2350B) 5V Tolerant Inputs : Yes PWM : Hardware PWM 0.1Hz-62.5MHz on all pins Node Addressing Breadboard Rows 1 through 60 Power Rails Node Description TOP_RAIL Top power rail (default 5V) BOTTOM_RAIL Bottom rail (default GND) GND Ground reference DAC0 DAC0 (connected to probe tip and INA0) DAC1 DAC1 (8V tolerant) Arduino Pins D0 - D13 , A0 - A7 , AREF , RESET GPIO GPIO_1 - GPIO_8 , UART_TX , UART_RX ADC/Current Sense ADC0 - ADC3 , ISENSE_PLUS , ISENSE_MINUS Core Tool Definitions Connections & Slots connect ( node1 , node2 , duplicates =- 1 ) # Create connection disconnect ( node1 , node2 ) # Remove connection nodes_clear () # Remove ALL connections is_connected ( node1 , node2 ) # Check if connected # Slot Management save_slot ( slot_id ) # Save current state to slot 0-7 load_slot ( slot_id ) # Load state from slot 0-7 get_current_slot () # Returns active slot number # JSON State API (Recommended for LLMs) get_state () # Get complete state as JSON string set_state ( json , clear_first = True ) # Apply state from JSON string Voltage Control dac_set ( channel , voltage , save = True ) # Set voltage (-8V to +8V) dac_get ( channel ) # Get current setting # Channels: 0/DAC0, 1/DAC1, 2/TOP_RAIL, 3/BOTTOM_RAIL Measurement adc_get ( channel ) # Read ADC voltage (channels 0-3) ina_get_current ( sensor ) # Read current in Amps (0=DAC0/Probe, 1=TOP_RAIL) ina_get_voltage ( sensor ) # Read INA bus voltage ina_get_power ( sensor ) # Read power in Watts GPIO & PWM gpio_set ( pin , value ) # Set output (True=3.3V, False=0V) gpio_get ( pin ) # Returns HIGH, LOW, or FLOATING gpio_set_dir ( pin , direction ) # True=OUTPUT, False=INPUT gpio_set_pull ( pin , pull ) # 1=PULLUP, -1=PULLDOWN, 0=NONE pwm ( pin , frequency , duty ) # Start PWM (duty: 0.0-1.0) pwm_stop ( pin ) # Stop PWM Waveform Generator (WaveGen) # Setup wavegen_set_output ( channel ) # 0=DAC0, 1=DAC1 (Default) wavegen_set_wave ( type ) # 0=Sine, 1=Square, 2=Tri, 3=Saw wavegen_set_freq ( hz ) # Frequency in Hz wavegen_set_amplitude ( vpp ) # Peak-to-Peak Voltage (e.g. 3.3) wavegen_set_offset ( volts ) # DC Offset (e.g. 1.65) # Control wavegen_start ( 1 ) # Start output wavegen_stop () # Stop output User Interaction oled_print ( text , size = 2 ) # Display on OLED oled_clear () # Clear display probe_read_blocking () # Wait for probe touch, return row probe_read_nonblocking () # Check without waiting (-1 if none) probe_button () # Returns CONNECT, REMOVE, or NONE clickwheel_get_direction () # Returns UP, DOWN, or NONE clickwheel_get_button () # Returns PRESSED, HELD, RELEASED Graphic Overlays (Breadboard LEDs) The breadboard LEDs are addressed as a 10x30 grid (Row 1-10, Col 1-30). Rows 1-5 are top half (E-A), Rows 6-10 are bottom half (F-J). # overlay_set(name, x, y, height, width, colors) # Colors can be flat list or 2D list of 0xRRGGBB integers overlay_set ( \"box\" , 1 , 1 , 5 , 5 , [ 0x550000 ] * 25 ) overlay_clear ( \"box\" ) # Remove overlay overlay_clear_all () # Remove all overlay_set_pixel ( x , y , color ) # Set single pixel (1-30, 1-10) System & Filesystem # Standard Python I/O is supported! with open ( '/config.txt' , 'r' ) as f : print ( f . read ()) # List files import os os . listdir ( '/' ) get_net_info ( netNum ) # Get dict with name, color, nodes get_num_nets () # Count of active nets get_num_bridges () # Count of bridges print_bridges () # Print bridge table Single-Character Command Reference (Port 1 Only) These commands are processed immediately when sent as raw characters (no > prefix) to the main serial port. Char Description Action J Show JSON Dumps the complete board state as a JSON string. L Load JSON Prepares the board to receive a JSON state. Paste JSON and end with an empty line. x Clear All Removes all connections and resets paths. n List Nets Prints a human-readable list of all active nets. b Show Bridges Prints the internal bridge array. ~ Show Config Dumps the current config . txt settings. | + | Add | Add connections (e.g., + 1 - 5 , 10 - 12 ). | | - | Remove | Remove connections (e.g., - 1 - 5 ). | | v | Read ADC | Follow with a channel (0-4) to get a quick voltage reading. | | @ | I2C Scan | Scans for I2C devices on a row (e.g., @ 10 ). | | r | Reset Arduino | Follow with t or b to reset the Top or Bottom Arduino. | | A | Connect Arduino UART | Connects Jumperless's UART to the Arduino D0 and D1 pins ( a to disconnect). | | m | Menu | Displays the help menu ( e to show more options). | | [ command ] ? | Help | Displays the help menu for the specified command. | | help | Help Menu | Displays the help menu. | LLM Mental Model File Format LLMs should maintain a persistent JSON model of what they believe is physically on the breadboard. This model has confidence values that increase through user confirmation or automated testing. Mental Model Schema { \"version\" : \"1.0\" , \"last_updated\" : \"2026-02-06T22:00:00Z\" , \"nano_header\" : { \"device\" : \"arduino_nano\" , // \"arduino_nano\", \"rp2040\", \"rpi_40pin_adapter\", \"oled_only\", \"empty\" \"confidence\" : 0.9 , \"notes\" : \"User confirmed Arduino Nano Every\" }, \"power_rails\" : { \"TOP_RAIL\" : { \"voltage\" : 5.0 , \"confidence\" : 1.0 , \"source\" : \"measured\" }, \"BOTTOM_RAIL\" : { \"voltage\" : 0.0 , \"confidence\" : 1.0 , \"source\" : \"measured\" } }, \"components\" : [ { \"id\" : \"comp_001\" , \"type\" : \"resistor\" , \"value\" : 1000 , \"unit\" : \"ohms\" , \"tolerance\" : 0.05 , \"pins\" : [ 5 , 10 ], \"confidence\" : 0.95 , \"detection_method\" : \"measured\" , \"notes\" : \"Measured 987\u03a9 between rows 5-10\" }, { \"id\" : \"comp_002\" , \"type\" : \"led\" , \"color\" : \"red\" , \"forward_voltage\" : 1.8 , \"pins\" : { \"anode\" : 15 , \"cathode\" : 16 }, \"confidence\" : 0.7 , \"detection_method\" : \"user_stated\" , \"notes\" : \"User said 'red LED on rows 15-16'\" }, { \"id\" : \"comp_003\" , \"type\" : \"module\" , \"name\" : \"SSD1306 OLED\" , \"pins\" : { \"GND\" : 20 , \"VCC\" : 21 , \"SCL\" : 22 , \"SDA\" : 23 }, \"confidence\" : 0.6 , \"detection_method\" : \"inferred\" , \"notes\" : \"Searched pinout, user confirmed row 20\" } ], \"wires\" : [ { \"from\" : 1 , \"to\" : 30 , \"confidence\" : 0.8 , \"detection_method\" : \"continuity_test\" } ], \"unknowns\" : [ { \"rows\" : [ 40 , 41 , 42 ], \"notes\" : \"Something detected but not identified\" } ] } Nano Header Device Types Device Description arduino_nano Arduino Nano/Every/RP2040 etc. rp2040 Bare RP2040 board rpi_40pin_adapter RPi GPIO adapter board oled_only SBC/SMD/OLED adapter for just the OLED empty Nothing plugged in Confidence Levels Level Source Meaning 1.0 measured Electrically verified 0.9 user_confirmed User explicitly confirmed 0.7 user_stated User mentioned it casually 0.5 inferred LLM guessed from context 0.3 assumed Default assumption Increasing Confidence Method Confidence Boost User confirms \"yes that's right\" +0.2 Electrical measurement matches +0.3 Multiple consistent tests +0.1 per test User provides datasheet Set to 0.95 Workflows for LLMs 1. Circuit Safe-Check (Mental Model) CRITICAL : The Jumperless prevents internal shorts, but cannot see external wires or components on the breadboard. If a user has a physical wire connecting Row 5 to Row 10, connecting TOP_RAIL -> 5 and GND -> 10 will cause a dead short through the user's wire. Workflow: 1. Ask : \"What is currently on the breadboard? (Wires, components, etc)\" 2. Model : Build the mental model JSON with low confidence 3. Test : Run detect_component () on key rows to verify 4. Update : Increase confidence as tests confirm the model # Safe Power-Up Sequence oled_print ( \"Checking for shorts...\" ) # Find an unused ADC unused_adc = None for i in range ( 4 ): name = f \"ADC { i } \" is_used = False for net in get_all_nets (): if name in net [ 'nodes' ]: is_used = True break if not is_used : unused_adc = i break if unused_adc is not None : connect ( 5 , f \"ADC { unused_adc } \" ) connect ( 10 , DAC1 ) # ... model[\"wires\"].append({\"from\": 5, \"to\": 10, \"confidence\": 0.95}) else: connect(5, TOP_RAIL) connect(10, GND) ### 2. Identifying User Circuits Use the Probe to \"see\" the board . ``` jython oled_print ( \"Touch the input of your circuit\" ) input_row = probe_read_blocking () oled_print ( f \"Input is at row { input_row } \" ) 3. Automated Characterization Use WaveGen and ADC to treat the circuit as a black box. connect ( DAC1 , 1 ) wavegen_set_output ( 1 ) wavegen_set_freq ( 100 ) wavegen_set_wave ( 0 ) # Sine wavegen_start ( 1 ) connect ( ADC0 , 10 ) for i in range ( 5 ): val = adc_get ( 0 ) print ( f \"Sample { i } : { val } V\" ) time . sleep ( 0.01 ) Component Library (Dynamic Lookup) When a user mentions a hardware module, search the web for its pinout and build a JSON definition on the fly. Workflow: 1. User mentions: \"I have an SSD1306 OLED on the breadboard\" 2. LLM searches: \"SSD1306 OLED pinout\" 3. LLM builds JSON from search results and adds it to mental_model [ \"components\" ] Example: NeoPixel Stick { \"name\" : \"NeoPixel Stick 8\" , \"pins\" : { \"GND\" : { \"default\" : \"GND\" , \"offset\" : 0 }, \"5V\" : { \"default\" : \"TOP_RAIL\" , \"offset\" : 1 }, \"DIN\" : { \"default\" : \"GPIO_1\" , \"offset\" : 2 }, \"DOUT\" : { \"default\" : \"NC\" , \"offset\" : 7 } }, \"width\" : 8 , \"voltage\" : \"5V\" , \"notes\" : \"3.3V GPIO works for most NeoPixels. Data on offset 2.\" } Key : The offset field defines pin position relative to pin 1. When user says \"pin 1 is on row X\", calculate absolute rows as row = X + offset . Safety Guidelines for LLMs Voltage Check : ADCs are buffered for \u00b18V. The board is \u00b19V tolerant overall. Short Circuit Prevention : The firmware will ignore requests to connect TOP_RAIL directly to BOTTOM_RAIL or GND . Confirm Power : Ask: \"Is the board powered via USB?\" (No barrel jack exists). Crossbar Resistance : Remember ~80\u03a9 per connection. High current paths will have voltage drop. Measure voltage at the destination with an ADC to compensate. LLM Preferences (Claude's Additions) 1. Structured State Snapshot What I want : A single command that returns the complete board state as structured data (JSON/dict), not just printed text. This lets me reason about the state programmatically. # REQUESTED: get_state() -> dict # Returns something like: { \"slot\" : 0 , \"bridges\" : [[ 1 , 5 ], [ 5 , \"TOP_RAIL\" ], [ 10 , \"GND\" ]], \"rails\" : { \"TOP_RAIL\" : 5.0 , \"BOTTOM_RAIL\" : 0.0 , \"DAC0\" : 3.3 , \"DAC1\" : 0.0 }, \"gpio\" : [ { \"pin\" : 1 , \"dir\" : \"OUTPUT\" , \"value\" : True , \"pull\" : \"NONE\" }, { \"pin\" : 2 , \"dir\" : \"INPUT\" , \"value\" : False , \"pull\" : \"PULLUP\" } ], \"adc_snapshot\" : [ 3.28 , 0.01 , 5.02 , - 0.03 ] # Quick reading of all 4 } Why : Currently I have to call get_num_bridges () , get_net_info () for each net, etc. A single snapshot is faster and less error-prone for building my mental model. 2. Return Values, Not Just Prints For debugging, I prefer return values over print statements : Instead of... I prefer... print_nets () \u2192 prints to serial get_nets () \u2192 returns list of net dicts print_bridges () \u2192 prints to serial get_bridges () \u2192 returns list of bridge tuples print_paths_compact () \u2192 prints get_paths () \u2192 returns routing info Why : When I call a tool, I want to capture the result and reason about it. Print output goes to the user's terminal but isn't easily parsed by my next step. 3. Error Return Conventions Consistent error handling helps me recover: # Good: Returns None or raises exception with message result = connect ( 999 , 5 ) # Invalid node # Returns: None (or {\"error\": \"Invalid node: 999\"}) # Good: Returns success/failure boolean with reason success , msg = disconnect ( 1 , 5 ) # Returns: (True, \"Disconnected\") or (False, \"No such connection\") 4. Undo via Slot Backup For destructive operations like nodes_clear () , the existing slot system provides an undo mechanism: # Before destructive operation, save current state to a backup slot save_slot ( 7 ) # Save to slot 7 as backup nodes_clear () # Now safe to clear # If user wants to undo: load_slot ( 7 ) # Restore from backup Pattern : Always save the current slot to an unused slot (7 is a good \"scratch\" slot) before any destructive action. This provides a built-in undo without needing special confirm flags. 5. Measurement with Context When measuring, I often want multiple samples or statistics: # REQUESTED: adc_get_stats(channel, samples=10) # Returns: {\"mean\": 3.28, \"min\": 3.25, \"max\": 3.31, \"stddev\": 0.02} Why : A single ADC reading might be noisy. Having built-in averaging/stats means I don't have to write loops for every measurement. 6. Interactive Conversation Patterns When helping users debug, I find these patterns effective: Explore First, Act Later : User : \"My LED isn't lighting up\" Me : 1. \"Where is your LED connected? (Touch the anode with the probe)\" 2. [ probe_read_blocking () \u2192 row 15 ] 3. \"I see row 15. Let me check the voltage there...\" 4. [ connect ( ADC0 , 15 ), adc_get ( 0 ) \u2192 0.02 V ] 5. \"Row 15 is at 0V. Is it supposed to be connected to power?\" Show, Don't Just Do : # Before making a connection, describe it: oled_print ( \"Connecting row 5 to 5V...\" ) connect ( 5 , TOP_RAIL ) oled_print ( \"Done! LED should light now\" ) Verify After Acting : # After connecting power, verify it worked: connect ( 5 , TOP_RAIL ) connect ( ADC0 , 5 ) v = adc_get ( 0 ) if abs ( v - 5.0 ) < 0.5 : oled_print ( f \"\u2713 Row 5 at { v : .1f } V\" ) else : oled_print ( f \"\u26a0 Expected 5V, got { v : .1f } V\" ) disconnect ( ADC0 , 5 ) LLM Best Practices & Future Tools This section consolidates recommendations for reliable, high-context hardware interaction. 1. Explicit State Verification Trust but verify. Confirm hardware state after critical operations. # Goal: Set DAC0 to 3.3V current = dac_get ( 0 ) if abs ( current - 3.3 ) > 0.1 : dac_set ( 0 , 3.3 ) time . sleep ( 0.01 ) # Allow settling new_val = dac_get ( 0 ) if abs ( new_val - 3.3 ) > 0.1 : print ( f \"Error: DAC0 failed to set. Got { new_val } V\" ) 2. Structured State Snapshot A single command to return the complete board state as a formatted JSON string, enabling detailed programmatic reasoning and full state management. # Get the complete current state as a formatted JSON string snapshot = get_state () # The snapshot includes: # - power: Settings for TOP_RAIL, BOTTOM_RAIL, DAC0, DAC1 # - nets: All active connections, names, colors, and voltage assignments # - gpio: Current configuration and state of all GPIO pins # Apply a state back to the hardware # set_state(json_string, clear_first=True) # If clear_first=True (default), it resets the board before applying set_state ( snapshot ) 3. Search-First Component Handling Ground knowledge by searching for pinouts before asking the user. Workflow: 1. User: \"I have a BME280.\" 2. Agent: search_web ( \"BME280 pinout SPI I2C\" ) 3. Agent: \"I see the BME280 supports both SPI and I2C. Which one are you using?\" 4. Batch Operations Process information efficiently in large chunks to reduce round-trips and ensure atomic updates. The recommended way to perform complex batch reconfigurations is to fetch the current state, modify it in Python, and re-apply it. # Recommended Batch Workflow: state_json = get_state () state = json . loads ( state_json ) # 1. Modify connections state [ 'nets' ] . append ({ \"index\" : 10 , \"name\" : \"SIGNAL\" , \"nodes\" : [ 5 , 12 , \"D7\" ]}) # 2. Update power settings state [ 'power' ][ 'top_rail' ] = 3.3 # 3. Configure GPIO state [ 'gpio' ][ 0 ][ 'dir' ] = \"OUTPUT\" state [ 'gpio' ][ 0 ][ 'value' ] = True # 4. Apply all changes at once set_state ( json . dumps ( state )) 5. Return Values Over Prints Tools should return data structures (lists, dicts) for programmatic use, not just print to stdout. 6. undo via Slot Backup Always save the current state to a scratch slot (e.g. slot 7) before destructive operations like nodes_clear () . 7. Context-Aware Error Recovery Error messages should include suggested_fix fields to allow self-correction without user intervention. 8. Interactive Conversation Patterns Explore First, Act Later : Probe and measure before applying power to unknown circuits. Show, Don't Just Do : Explain actions via oled_print () and print () before executing them to keep the user informed. Implementation Status Feature Status connect () , disconnect () , is_connected () \u2705 Implemented dac_set () , adc_get () , ina_ * () \u2705 Implemented gpio_ * () , pwm () \u2705 Implemented oled_print () , probe_ * () \u2705 Implemented WaveGen tools \u2705 Implemented Slot management \u2705 Implemented get_state () / set_state () snapshot \u2705 Implemented Slot backup for undo \u2705 Implemented (use save_slot ( 7 ) before destructive ops)","title":"LLM Tool Specification for Jumperless V5"},{"location":"12-llm-tools-specification/#llm-tool-specification-for-jumperless-v5","text":"A guide for LLMs with some tips to control the Jumperless V5.","title":"LLM Tool Specification for Jumperless V5"},{"location":"12-llm-tools-specification/#quick-reference","text":"Category Key Tools Connections connect () , disconnect () , nodes_clear () , save_slot () , load_slot () Voltage dac_set () , adc_get () Current ina_get_current () , ina_get_power () GPIO gpio_set () , gpio_get () , gpio_set_dir () , pwm () User Interaction oled_print () , probe_read_blocking () , probe_button () Graphic Overlays overlay_set () , overlay_clear () , overlay_set_pixel () State get_state () , set_state () (Refer to the full Micropython API Reference )","title":"Quick Reference"},{"location":"12-llm-tools-specification/#communication-methods","text":"","title":"Communication Methods"},{"location":"12-llm-tools-specification/#method-1-direct-python-commands-main-serial-port","text":"Prefix single-line Python with > on the main serial port (Port 1). Best for: Single commands, status checks. > connect ( 1 , 5 ) > voltage = adc_get ( 0 ) > oled_print ( f \"V = { voltage : .2f } \" ) > print ( f \"V = { voltage : .2f } \" )","title":"Method 1: Direct Python Commands (Main Serial Port)"},{"location":"12-llm-tools-specification/#method-2-viperide-raw-repl-3rd-usb-port","text":"The third USB port provides a MicroPython Raw REPL. Best for: Complex logic, loops, automated testing scripts. # Full scripts run on port 3 import time for i in range ( 10 ): voltage = adc_get ( 0 ) print ( f \"Reading { i } : { voltage : .2f } V\" ) time . sleep ( 0.5 )","title":"Method 2: ViperIDE / Raw REPL (3rd USB Port)"},{"location":"12-llm-tools-specification/#method-3-arduino-tags-via-uart","text":"From an Arduino connected to the Jumperless. Best for: Hybrid Arduino/Python projects. Serial . print ( \"<p>connect(1, 5)</p>\" ); // Python command Serial . print ( \"<j>n</j>\" ); // Menu command","title":"Method 3: Arduino Tags (via UART)"},{"location":"12-llm-tools-specification/#method-4-single-character-commands-main-serial-port","text":"Raw characters sent to Port 1 trigger immediate menu actions. Best for: Fast state dumps, clearing the board, or manual resets. J <-- Immediate JSON state dump L <-- Immediate JSON state load ( paste JSON after L ) x <-- Immediate board clear","title":"Method 4: Single-Character Commands (Main Serial Port)"},{"location":"12-llm-tools-specification/#usb-port-structure","text":"macOS / Linux: | Port | Name | Function | |------|------|----------| | 1 (main) | JLV5port1 | Main terminal, menu, > Python commands | | 2 | JLV5port3 | Arduino UART passthrough | | 3 | JLV5port5 | MicroPython Raw REPL (ViperIDE) | Windows: | Port | Name | Function | |------|------|----------| | 1 (main) | COM1 | Main terminal, menu, > Python commands | | 2 | COM2 | Arduino UART passthrough | | 3 | COM3 | MicroPython Raw REPL (ViperIDE) |","title":"USB Port Structure"},{"location":"12-llm-tools-specification/#hardware-overview","text":"","title":"Hardware Overview"},{"location":"12-llm-tools-specification/#physical-layout","text":"60 breadboard rows (1-60) with 5 RGB LEDs underneath each Arduino Nano header with routable pins OLED display (128x32, optional but recommended) Probe with touch-sensing tip, 2 buttons, mode switch Clickwheel rotary encoder with button 12 CH446Q crossbar chips (A-L) for routing (~80\u03a9 per path)","title":"Physical Layout"},{"location":"12-llm-tools-specification/#power","text":"TOP_RAIL / BOTTOM_RAIL : Main power rails (\u00b18V, 300mA) DAC0 / DAC1 : Auxiliary voltage outputs (\u00b18V, 300mA each) DAC0 connects to Probe Tip & INA0 DAC0 and DAC1 are 0-3.3V native but amplified to \u00b18V Current Limits : ~300mA per rail/DAC","title":"Power"},{"location":"12-llm-tools-specification/#measurement","text":"ADC0-3 : 4 user analog inputs (\u00b18V range) INA0 : High-side current monitor on DAC0 (Probe Tip) INA1 : High-side current monitor on TOP_RAIL (configurable)","title":"Measurement"},{"location":"12-llm-tools-specification/#gpio","text":"10 GPIO pins (RP2350B, 3.3V logic) Defined as GPIO_1 - GPIO_8 (physical gpio 20-27 on RP2350B), and UART_TX (gpio 0 on RP2350B) and UART_RX (gpio 1 on RP2350B) 5V Tolerant Inputs : Yes PWM : Hardware PWM 0.1Hz-62.5MHz on all pins","title":"GPIO"},{"location":"12-llm-tools-specification/#node-addressing","text":"","title":"Node Addressing"},{"location":"12-llm-tools-specification/#breadboard-rows","text":"1 through 60","title":"Breadboard Rows"},{"location":"12-llm-tools-specification/#power-rails","text":"Node Description TOP_RAIL Top power rail (default 5V) BOTTOM_RAIL Bottom rail (default GND) GND Ground reference DAC0 DAC0 (connected to probe tip and INA0) DAC1 DAC1 (8V tolerant)","title":"Power Rails"},{"location":"12-llm-tools-specification/#arduino-pins","text":"D0 - D13 , A0 - A7 , AREF , RESET","title":"Arduino Pins"},{"location":"12-llm-tools-specification/#gpio_1","text":"GPIO_1 - GPIO_8 , UART_TX , UART_RX","title":"GPIO"},{"location":"12-llm-tools-specification/#adccurrent-sense","text":"ADC0 - ADC3 , ISENSE_PLUS , ISENSE_MINUS","title":"ADC/Current Sense"},{"location":"12-llm-tools-specification/#core-tool-definitions","text":"","title":"Core Tool Definitions"},{"location":"12-llm-tools-specification/#connections-slots","text":"connect ( node1 , node2 , duplicates =- 1 ) # Create connection disconnect ( node1 , node2 ) # Remove connection nodes_clear () # Remove ALL connections is_connected ( node1 , node2 ) # Check if connected # Slot Management save_slot ( slot_id ) # Save current state to slot 0-7 load_slot ( slot_id ) # Load state from slot 0-7 get_current_slot () # Returns active slot number # JSON State API (Recommended for LLMs) get_state () # Get complete state as JSON string set_state ( json , clear_first = True ) # Apply state from JSON string","title":"Connections &amp; Slots"},{"location":"12-llm-tools-specification/#voltage-control","text":"dac_set ( channel , voltage , save = True ) # Set voltage (-8V to +8V) dac_get ( channel ) # Get current setting # Channels: 0/DAC0, 1/DAC1, 2/TOP_RAIL, 3/BOTTOM_RAIL","title":"Voltage Control"},{"location":"12-llm-tools-specification/#measurement_1","text":"adc_get ( channel ) # Read ADC voltage (channels 0-3) ina_get_current ( sensor ) # Read current in Amps (0=DAC0/Probe, 1=TOP_RAIL) ina_get_voltage ( sensor ) # Read INA bus voltage ina_get_power ( sensor ) # Read power in Watts","title":"Measurement"},{"location":"12-llm-tools-specification/#gpio-pwm","text":"gpio_set ( pin , value ) # Set output (True=3.3V, False=0V) gpio_get ( pin ) # Returns HIGH, LOW, or FLOATING gpio_set_dir ( pin , direction ) # True=OUTPUT, False=INPUT gpio_set_pull ( pin , pull ) # 1=PULLUP, -1=PULLDOWN, 0=NONE pwm ( pin , frequency , duty ) # Start PWM (duty: 0.0-1.0) pwm_stop ( pin ) # Stop PWM","title":"GPIO &amp; PWM"},{"location":"12-llm-tools-specification/#waveform-generator-wavegen","text":"# Setup wavegen_set_output ( channel ) # 0=DAC0, 1=DAC1 (Default) wavegen_set_wave ( type ) # 0=Sine, 1=Square, 2=Tri, 3=Saw wavegen_set_freq ( hz ) # Frequency in Hz wavegen_set_amplitude ( vpp ) # Peak-to-Peak Voltage (e.g. 3.3) wavegen_set_offset ( volts ) # DC Offset (e.g. 1.65) # Control wavegen_start ( 1 ) # Start output wavegen_stop () # Stop output","title":"Waveform Generator (WaveGen)"},{"location":"12-llm-tools-specification/#user-interaction","text":"oled_print ( text , size = 2 ) # Display on OLED oled_clear () # Clear display probe_read_blocking () # Wait for probe touch, return row probe_read_nonblocking () # Check without waiting (-1 if none) probe_button () # Returns CONNECT, REMOVE, or NONE clickwheel_get_direction () # Returns UP, DOWN, or NONE clickwheel_get_button () # Returns PRESSED, HELD, RELEASED","title":"User Interaction"},{"location":"12-llm-tools-specification/#graphic-overlays-breadboard-leds","text":"The breadboard LEDs are addressed as a 10x30 grid (Row 1-10, Col 1-30). Rows 1-5 are top half (E-A), Rows 6-10 are bottom half (F-J). # overlay_set(name, x, y, height, width, colors) # Colors can be flat list or 2D list of 0xRRGGBB integers overlay_set ( \"box\" , 1 , 1 , 5 , 5 , [ 0x550000 ] * 25 ) overlay_clear ( \"box\" ) # Remove overlay overlay_clear_all () # Remove all overlay_set_pixel ( x , y , color ) # Set single pixel (1-30, 1-10)","title":"Graphic Overlays (Breadboard LEDs)"},{"location":"12-llm-tools-specification/#system-filesystem","text":"# Standard Python I/O is supported! with open ( '/config.txt' , 'r' ) as f : print ( f . read ()) # List files import os os . listdir ( '/' ) get_net_info ( netNum ) # Get dict with name, color, nodes get_num_nets () # Count of active nets get_num_bridges () # Count of bridges print_bridges () # Print bridge table","title":"System &amp; Filesystem"},{"location":"12-llm-tools-specification/#single-character-command-reference-port-1-only","text":"These commands are processed immediately when sent as raw characters (no > prefix) to the main serial port. Char Description Action J Show JSON Dumps the complete board state as a JSON string. L Load JSON Prepares the board to receive a JSON state. Paste JSON and end with an empty line. x Clear All Removes all connections and resets paths. n List Nets Prints a human-readable list of all active nets. b Show Bridges Prints the internal bridge array. ~ Show Config Dumps the current config . txt settings. | + | Add | Add connections (e.g., + 1 - 5 , 10 - 12 ). | | - | Remove | Remove connections (e.g., - 1 - 5 ). | | v | Read ADC | Follow with a channel (0-4) to get a quick voltage reading. | | @ | I2C Scan | Scans for I2C devices on a row (e.g., @ 10 ). | | r | Reset Arduino | Follow with t or b to reset the Top or Bottom Arduino. | | A | Connect Arduino UART | Connects Jumperless's UART to the Arduino D0 and D1 pins ( a to disconnect). | | m | Menu | Displays the help menu ( e to show more options). | | [ command ] ? | Help | Displays the help menu for the specified command. | | help | Help Menu | Displays the help menu. |","title":"Single-Character Command Reference (Port 1 Only)"},{"location":"12-llm-tools-specification/#llm-mental-model-file-format","text":"LLMs should maintain a persistent JSON model of what they believe is physically on the breadboard. This model has confidence values that increase through user confirmation or automated testing.","title":"LLM Mental Model File Format"},{"location":"12-llm-tools-specification/#mental-model-schema","text":"{ \"version\" : \"1.0\" , \"last_updated\" : \"2026-02-06T22:00:00Z\" , \"nano_header\" : { \"device\" : \"arduino_nano\" , // \"arduino_nano\", \"rp2040\", \"rpi_40pin_adapter\", \"oled_only\", \"empty\" \"confidence\" : 0.9 , \"notes\" : \"User confirmed Arduino Nano Every\" }, \"power_rails\" : { \"TOP_RAIL\" : { \"voltage\" : 5.0 , \"confidence\" : 1.0 , \"source\" : \"measured\" }, \"BOTTOM_RAIL\" : { \"voltage\" : 0.0 , \"confidence\" : 1.0 , \"source\" : \"measured\" } }, \"components\" : [ { \"id\" : \"comp_001\" , \"type\" : \"resistor\" , \"value\" : 1000 , \"unit\" : \"ohms\" , \"tolerance\" : 0.05 , \"pins\" : [ 5 , 10 ], \"confidence\" : 0.95 , \"detection_method\" : \"measured\" , \"notes\" : \"Measured 987\u03a9 between rows 5-10\" }, { \"id\" : \"comp_002\" , \"type\" : \"led\" , \"color\" : \"red\" , \"forward_voltage\" : 1.8 , \"pins\" : { \"anode\" : 15 , \"cathode\" : 16 }, \"confidence\" : 0.7 , \"detection_method\" : \"user_stated\" , \"notes\" : \"User said 'red LED on rows 15-16'\" }, { \"id\" : \"comp_003\" , \"type\" : \"module\" , \"name\" : \"SSD1306 OLED\" , \"pins\" : { \"GND\" : 20 , \"VCC\" : 21 , \"SCL\" : 22 , \"SDA\" : 23 }, \"confidence\" : 0.6 , \"detection_method\" : \"inferred\" , \"notes\" : \"Searched pinout, user confirmed row 20\" } ], \"wires\" : [ { \"from\" : 1 , \"to\" : 30 , \"confidence\" : 0.8 , \"detection_method\" : \"continuity_test\" } ], \"unknowns\" : [ { \"rows\" : [ 40 , 41 , 42 ], \"notes\" : \"Something detected but not identified\" } ] }","title":"Mental Model Schema"},{"location":"12-llm-tools-specification/#nano-header-device-types","text":"Device Description arduino_nano Arduino Nano/Every/RP2040 etc. rp2040 Bare RP2040 board rpi_40pin_adapter RPi GPIO adapter board oled_only SBC/SMD/OLED adapter for just the OLED empty Nothing plugged in","title":"Nano Header Device Types"},{"location":"12-llm-tools-specification/#confidence-levels","text":"Level Source Meaning 1.0 measured Electrically verified 0.9 user_confirmed User explicitly confirmed 0.7 user_stated User mentioned it casually 0.5 inferred LLM guessed from context 0.3 assumed Default assumption","title":"Confidence Levels"},{"location":"12-llm-tools-specification/#increasing-confidence","text":"Method Confidence Boost User confirms \"yes that's right\" +0.2 Electrical measurement matches +0.3 Multiple consistent tests +0.1 per test User provides datasheet Set to 0.95","title":"Increasing Confidence"},{"location":"12-llm-tools-specification/#workflows-for-llms","text":"","title":"Workflows for LLMs"},{"location":"12-llm-tools-specification/#1-circuit-safe-check-mental-model","text":"CRITICAL : The Jumperless prevents internal shorts, but cannot see external wires or components on the breadboard. If a user has a physical wire connecting Row 5 to Row 10, connecting TOP_RAIL -> 5 and GND -> 10 will cause a dead short through the user's wire. Workflow: 1. Ask : \"What is currently on the breadboard? (Wires, components, etc)\" 2. Model : Build the mental model JSON with low confidence 3. Test : Run detect_component () on key rows to verify 4. Update : Increase confidence as tests confirm the model # Safe Power-Up Sequence oled_print ( \"Checking for shorts...\" ) # Find an unused ADC unused_adc = None for i in range ( 4 ): name = f \"ADC { i } \" is_used = False for net in get_all_nets (): if name in net [ 'nodes' ]: is_used = True break if not is_used : unused_adc = i break if unused_adc is not None : connect ( 5 , f \"ADC { unused_adc } \" ) connect ( 10 , DAC1 ) # ... model[\"wires\"].append({\"from\": 5, \"to\": 10, \"confidence\": 0.95}) else: connect(5, TOP_RAIL) connect(10, GND) ### 2. Identifying User Circuits Use the Probe to \"see\" the board . ``` jython oled_print ( \"Touch the input of your circuit\" ) input_row = probe_read_blocking () oled_print ( f \"Input is at row { input_row } \" )","title":"1. Circuit Safe-Check (Mental Model)"},{"location":"12-llm-tools-specification/#3-automated-characterization","text":"Use WaveGen and ADC to treat the circuit as a black box. connect ( DAC1 , 1 ) wavegen_set_output ( 1 ) wavegen_set_freq ( 100 ) wavegen_set_wave ( 0 ) # Sine wavegen_start ( 1 ) connect ( ADC0 , 10 ) for i in range ( 5 ): val = adc_get ( 0 ) print ( f \"Sample { i } : { val } V\" ) time . sleep ( 0.01 )","title":"3. Automated Characterization"},{"location":"12-llm-tools-specification/#component-library-dynamic-lookup","text":"When a user mentions a hardware module, search the web for its pinout and build a JSON definition on the fly. Workflow: 1. User mentions: \"I have an SSD1306 OLED on the breadboard\" 2. LLM searches: \"SSD1306 OLED pinout\" 3. LLM builds JSON from search results and adds it to mental_model [ \"components\" ] Example: NeoPixel Stick { \"name\" : \"NeoPixel Stick 8\" , \"pins\" : { \"GND\" : { \"default\" : \"GND\" , \"offset\" : 0 }, \"5V\" : { \"default\" : \"TOP_RAIL\" , \"offset\" : 1 }, \"DIN\" : { \"default\" : \"GPIO_1\" , \"offset\" : 2 }, \"DOUT\" : { \"default\" : \"NC\" , \"offset\" : 7 } }, \"width\" : 8 , \"voltage\" : \"5V\" , \"notes\" : \"3.3V GPIO works for most NeoPixels. Data on offset 2.\" } Key : The offset field defines pin position relative to pin 1. When user says \"pin 1 is on row X\", calculate absolute rows as row = X + offset .","title":"Component Library (Dynamic Lookup)"},{"location":"12-llm-tools-specification/#safety-guidelines-for-llms","text":"Voltage Check : ADCs are buffered for \u00b18V. The board is \u00b19V tolerant overall. Short Circuit Prevention : The firmware will ignore requests to connect TOP_RAIL directly to BOTTOM_RAIL or GND . Confirm Power : Ask: \"Is the board powered via USB?\" (No barrel jack exists). Crossbar Resistance : Remember ~80\u03a9 per connection. High current paths will have voltage drop. Measure voltage at the destination with an ADC to compensate.","title":"Safety Guidelines for LLMs"},{"location":"12-llm-tools-specification/#llm-preferences-claudes-additions","text":"","title":"LLM Preferences (Claude's Additions)"},{"location":"12-llm-tools-specification/#1-structured-state-snapshot","text":"What I want : A single command that returns the complete board state as structured data (JSON/dict), not just printed text. This lets me reason about the state programmatically. # REQUESTED: get_state() -> dict # Returns something like: { \"slot\" : 0 , \"bridges\" : [[ 1 , 5 ], [ 5 , \"TOP_RAIL\" ], [ 10 , \"GND\" ]], \"rails\" : { \"TOP_RAIL\" : 5.0 , \"BOTTOM_RAIL\" : 0.0 , \"DAC0\" : 3.3 , \"DAC1\" : 0.0 }, \"gpio\" : [ { \"pin\" : 1 , \"dir\" : \"OUTPUT\" , \"value\" : True , \"pull\" : \"NONE\" }, { \"pin\" : 2 , \"dir\" : \"INPUT\" , \"value\" : False , \"pull\" : \"PULLUP\" } ], \"adc_snapshot\" : [ 3.28 , 0.01 , 5.02 , - 0.03 ] # Quick reading of all 4 } Why : Currently I have to call get_num_bridges () , get_net_info () for each net, etc. A single snapshot is faster and less error-prone for building my mental model.","title":"1. Structured State Snapshot"},{"location":"12-llm-tools-specification/#2-return-values-not-just-prints","text":"For debugging, I prefer return values over print statements : Instead of... I prefer... print_nets () \u2192 prints to serial get_nets () \u2192 returns list of net dicts print_bridges () \u2192 prints to serial get_bridges () \u2192 returns list of bridge tuples print_paths_compact () \u2192 prints get_paths () \u2192 returns routing info Why : When I call a tool, I want to capture the result and reason about it. Print output goes to the user's terminal but isn't easily parsed by my next step.","title":"2. Return Values, Not Just Prints"},{"location":"12-llm-tools-specification/#3-error-return-conventions","text":"Consistent error handling helps me recover: # Good: Returns None or raises exception with message result = connect ( 999 , 5 ) # Invalid node # Returns: None (or {\"error\": \"Invalid node: 999\"}) # Good: Returns success/failure boolean with reason success , msg = disconnect ( 1 , 5 ) # Returns: (True, \"Disconnected\") or (False, \"No such connection\")","title":"3. Error Return Conventions"},{"location":"12-llm-tools-specification/#4-undo-via-slot-backup","text":"For destructive operations like nodes_clear () , the existing slot system provides an undo mechanism: # Before destructive operation, save current state to a backup slot save_slot ( 7 ) # Save to slot 7 as backup nodes_clear () # Now safe to clear # If user wants to undo: load_slot ( 7 ) # Restore from backup Pattern : Always save the current slot to an unused slot (7 is a good \"scratch\" slot) before any destructive action. This provides a built-in undo without needing special confirm flags.","title":"4. Undo via Slot Backup"},{"location":"12-llm-tools-specification/#5-measurement-with-context","text":"When measuring, I often want multiple samples or statistics: # REQUESTED: adc_get_stats(channel, samples=10) # Returns: {\"mean\": 3.28, \"min\": 3.25, \"max\": 3.31, \"stddev\": 0.02} Why : A single ADC reading might be noisy. Having built-in averaging/stats means I don't have to write loops for every measurement.","title":"5. Measurement with Context"},{"location":"12-llm-tools-specification/#6-interactive-conversation-patterns","text":"When helping users debug, I find these patterns effective: Explore First, Act Later : User : \"My LED isn't lighting up\" Me : 1. \"Where is your LED connected? (Touch the anode with the probe)\" 2. [ probe_read_blocking () \u2192 row 15 ] 3. \"I see row 15. Let me check the voltage there...\" 4. [ connect ( ADC0 , 15 ), adc_get ( 0 ) \u2192 0.02 V ] 5. \"Row 15 is at 0V. Is it supposed to be connected to power?\" Show, Don't Just Do : # Before making a connection, describe it: oled_print ( \"Connecting row 5 to 5V...\" ) connect ( 5 , TOP_RAIL ) oled_print ( \"Done! LED should light now\" ) Verify After Acting : # After connecting power, verify it worked: connect ( 5 , TOP_RAIL ) connect ( ADC0 , 5 ) v = adc_get ( 0 ) if abs ( v - 5.0 ) < 0.5 : oled_print ( f \"\u2713 Row 5 at { v : .1f } V\" ) else : oled_print ( f \"\u26a0 Expected 5V, got { v : .1f } V\" ) disconnect ( ADC0 , 5 )","title":"6. Interactive Conversation Patterns"},{"location":"12-llm-tools-specification/#llm-best-practices-future-tools","text":"This section consolidates recommendations for reliable, high-context hardware interaction.","title":"LLM Best Practices &amp; Future Tools"},{"location":"12-llm-tools-specification/#1-explicit-state-verification","text":"Trust but verify. Confirm hardware state after critical operations. # Goal: Set DAC0 to 3.3V current = dac_get ( 0 ) if abs ( current - 3.3 ) > 0.1 : dac_set ( 0 , 3.3 ) time . sleep ( 0.01 ) # Allow settling new_val = dac_get ( 0 ) if abs ( new_val - 3.3 ) > 0.1 : print ( f \"Error: DAC0 failed to set. Got { new_val } V\" )","title":"1. Explicit State Verification"},{"location":"12-llm-tools-specification/#2-structured-state-snapshot","text":"A single command to return the complete board state as a formatted JSON string, enabling detailed programmatic reasoning and full state management. # Get the complete current state as a formatted JSON string snapshot = get_state () # The snapshot includes: # - power: Settings for TOP_RAIL, BOTTOM_RAIL, DAC0, DAC1 # - nets: All active connections, names, colors, and voltage assignments # - gpio: Current configuration and state of all GPIO pins # Apply a state back to the hardware # set_state(json_string, clear_first=True) # If clear_first=True (default), it resets the board before applying set_state ( snapshot )","title":"2. Structured State Snapshot"},{"location":"12-llm-tools-specification/#3-search-first-component-handling","text":"Ground knowledge by searching for pinouts before asking the user. Workflow: 1. User: \"I have a BME280.\" 2. Agent: search_web ( \"BME280 pinout SPI I2C\" ) 3. Agent: \"I see the BME280 supports both SPI and I2C. Which one are you using?\"","title":"3. Search-First Component Handling"},{"location":"12-llm-tools-specification/#4-batch-operations","text":"Process information efficiently in large chunks to reduce round-trips and ensure atomic updates. The recommended way to perform complex batch reconfigurations is to fetch the current state, modify it in Python, and re-apply it. # Recommended Batch Workflow: state_json = get_state () state = json . loads ( state_json ) # 1. Modify connections state [ 'nets' ] . append ({ \"index\" : 10 , \"name\" : \"SIGNAL\" , \"nodes\" : [ 5 , 12 , \"D7\" ]}) # 2. Update power settings state [ 'power' ][ 'top_rail' ] = 3.3 # 3. Configure GPIO state [ 'gpio' ][ 0 ][ 'dir' ] = \"OUTPUT\" state [ 'gpio' ][ 0 ][ 'value' ] = True # 4. Apply all changes at once set_state ( json . dumps ( state ))","title":"4. Batch Operations"},{"location":"12-llm-tools-specification/#5-return-values-over-prints","text":"Tools should return data structures (lists, dicts) for programmatic use, not just print to stdout.","title":"5. Return Values Over Prints"},{"location":"12-llm-tools-specification/#6-undo-via-slot-backup","text":"Always save the current state to a scratch slot (e.g. slot 7) before destructive operations like nodes_clear () .","title":"6. undo via Slot Backup"},{"location":"12-llm-tools-specification/#7-context-aware-error-recovery","text":"Error messages should include suggested_fix fields to allow self-correction without user intervention.","title":"7. Context-Aware Error Recovery"},{"location":"12-llm-tools-specification/#8-interactive-conversation-patterns","text":"Explore First, Act Later : Probe and measure before applying power to unknown circuits. Show, Don't Just Do : Explain actions via oled_print () and print () before executing them to keep the user informed.","title":"8. Interactive Conversation Patterns"},{"location":"12-llm-tools-specification/#implementation-status","text":"Feature Status connect () , disconnect () , is_connected () \u2705 Implemented dac_set () , adc_get () , ina_ * () \u2705 Implemented gpio_ * () , pwm () \u2705 Implemented oled_print () , probe_ * () \u2705 Implemented WaveGen tools \u2705 Implemented Slot management \u2705 Implemented get_state () / set_state () snapshot \u2705 Implemented Slot backup for undo \u2705 Implemented (use save_slot ( 7 ) before destructive ops)","title":"Implementation Status"},{"location":"99-glossary/","text":"Glossary of Terms Basic Concepts net = a group of all the node s that are connected together (enter n to see the list) node = anything the crossbar array can connect to, which includes everything on the breadboard and Nano header, as well as the internal special function node s like routable GPIO , ADC s, DAC s row = kinda the same thing as node but I generally use it to mean stuff on the breadboard (so special function things like routable GPIO , ADC s, DAC s that don't have a set location are excluded) rail = I use this to refer to the 4 horizontal power rails on the top and bottom ( top_rail , bottom_rail , gnd ), I will never call a vertical row a rail . (I know they're columns but it's easier to say a lot) bridge = a pair of exactly two node s (this is what you're making when you connect stuff with the probe, enter b to see the bridge array) path = the set of crossbar connections needed to make a single bridge , so it can have multiple hop s if it doesn't have a direct connection and needs to make a bounce through an intermediate chip (enter c to see the crossbar array) Hardware chip = shorthand for the CH446Qs specifically, lettered A-L. The first 8 (A-H) are considered \"breadboard chips \", and the last 4 (I-L) are considered \"special function\" chips (enter c to see their connections) menu = I generally mean the onboard clickwheel menu when I say this ( click the wheel to enter those and scroll around.) Sometimes I mean the main menu which is the list of single character command that gets presented over serial. Slots and Files slot = one of 10 saved circuit configurations (slots 0-9) that you can switch between. Use < to cycle forward through slots, or use the menus to jump to a specific slot. The active slot is the one currently loaded and affecting the hardware. slot file = a YAML file on the filesystem that stores a complete circuit configuration including bridges, power settings, and colors. Located at / slots / slotN . yaml where N is 0-9. These files are human-readable and can be edited directly! active slot = the currently loaded slot. Only the active slot affects the hardware. Use Q command to query which slot is active. When you make connections with the probe, they're saved to the active slot automatically. Slot Management Commands < = cycle to next slot (0\u21921\u21922...\u21927\u21920) Q = query which slot is currently active (returns ACTIVE_SLOT : X ) Y = print YAML YAML Format Slot files use YAML format with named nodes for readability: bridges : - { n1 : 1 , n2 : 10 , dup : 2 , color : red } - { n1 : NANO_D5 , n2 : GPIO_1 , dup : 2 } power : topRail : 3.30 bottomRail : 2.50 Named nodes: NANO_D0 - D13 , NANO_A0 - A7 , GPIO_1 - 8 , TOP_RAIL , BOTTOM_RAIL , GND , DAC0_5V , DAC1_5V , etc. You can view and edit these files in the File Manager or via USB Mass Storage mode ( U command). Wokwi Import W = Import circuit from Wokwi simulator Design circuit on wokwi.com Copy diagram . json content Type W in Jumperless Paste JSON content Circuit is converted and saved to active slot The parser automatically maps Wokwi breadboard pins, Arduino Nano pins, and logic analyzer channels to Jumperless nodes, and preserves your wire colors from Wokwi!","title":"Glossary of Terms"},{"location":"99-glossary/#glossary-of-terms","text":"","title":"Glossary of Terms"},{"location":"99-glossary/#basic-concepts","text":"net = a group of all the node s that are connected together (enter n to see the list) node = anything the crossbar array can connect to, which includes everything on the breadboard and Nano header, as well as the internal special function node s like routable GPIO , ADC s, DAC s row = kinda the same thing as node but I generally use it to mean stuff on the breadboard (so special function things like routable GPIO , ADC s, DAC s that don't have a set location are excluded) rail = I use this to refer to the 4 horizontal power rails on the top and bottom ( top_rail , bottom_rail , gnd ), I will never call a vertical row a rail . (I know they're columns but it's easier to say a lot) bridge = a pair of exactly two node s (this is what you're making when you connect stuff with the probe, enter b to see the bridge array) path = the set of crossbar connections needed to make a single bridge , so it can have multiple hop s if it doesn't have a direct connection and needs to make a bounce through an intermediate chip (enter c to see the crossbar array)","title":"Basic Concepts"},{"location":"99-glossary/#hardware","text":"chip = shorthand for the CH446Qs specifically, lettered A-L. The first 8 (A-H) are considered \"breadboard chips \", and the last 4 (I-L) are considered \"special function\" chips (enter c to see their connections) menu = I generally mean the onboard clickwheel menu when I say this ( click the wheel to enter those and scroll around.) Sometimes I mean the main menu which is the list of single character command that gets presented over serial.","title":"Hardware"},{"location":"99-glossary/#slots-and-files","text":"slot = one of 10 saved circuit configurations (slots 0-9) that you can switch between. Use < to cycle forward through slots, or use the menus to jump to a specific slot. The active slot is the one currently loaded and affecting the hardware. slot file = a YAML file on the filesystem that stores a complete circuit configuration including bridges, power settings, and colors. Located at / slots / slotN . yaml where N is 0-9. These files are human-readable and can be edited directly! active slot = the currently loaded slot. Only the active slot affects the hardware. Use Q command to query which slot is active. When you make connections with the probe, they're saved to the active slot automatically.","title":"Slots and Files"},{"location":"99-glossary/#slot-management-commands","text":"< = cycle to next slot (0\u21921\u21922...\u21927\u21920) Q = query which slot is currently active (returns ACTIVE_SLOT : X ) Y = print YAML","title":"Slot Management Commands"},{"location":"99-glossary/#yaml-format","text":"Slot files use YAML format with named nodes for readability: bridges : - { n1 : 1 , n2 : 10 , dup : 2 , color : red } - { n1 : NANO_D5 , n2 : GPIO_1 , dup : 2 } power : topRail : 3.30 bottomRail : 2.50 Named nodes: NANO_D0 - D13 , NANO_A0 - A7 , GPIO_1 - 8 , TOP_RAIL , BOTTOM_RAIL , GND , DAC0_5V , DAC1_5V , etc. You can view and edit these files in the File Manager or via USB Mass Storage mode ( U command).","title":"YAML Format"},{"location":"99-glossary/#wokwi-import","text":"W = Import circuit from Wokwi simulator Design circuit on wokwi.com Copy diagram . json content Type W in Jumperless Paste JSON content Circuit is converted and saved to active slot The parser automatically maps Wokwi breadboard pins, Arduino Nano pins, and logic analyzer channels to Jumperless nodes, and preserves your wire colors from Wokwi!","title":"Wokwi Import"},{"location":"assets/","text":"I'm just gonna use this to dump images so I can link them in the docs. 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16 17 18 19 20 21 22 https://github.com/user-attachments/assets/81a1ade9-c043-483b-a5a2-f40c33d0a1b2 23 https://github.com/user-attachments/assets/f77f6fd5-d005-45db-9c4c-b256390b91fc 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 https://github.com/user-attachments/assets/7fa478f0-bbdf-4d48-b6a3-dcb1a36f23d0 39 40 41 42 43 44 45 https://github.com/user-attachments/assets/fcdae6a6-ef4c-4fe7-9d5c-74cee5946c08 46","title":"Index"}]}