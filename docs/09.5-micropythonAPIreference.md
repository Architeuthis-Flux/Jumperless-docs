# Jumperless MicroPython API Reference

This document provides a comprehensive reference for the `jumperless` MicroPython module, which allows for direct control over the Jumperless hardware.

## A Note on Usage

All functions and constants from the `jumperless` module are automatically imported into the global namespace. This means you can call them directly (e.g., `connect(1, 5)`) without needing the `jumperless.` prefix.

There are three primary ways to specify nodes in functions:
1.  **By Number**: Use the integer corresponding to the breadboard row (1-60).
2.  **By String Name**: Use a case-insensitive string for any named node (e.g., `"d13"`, `"TOP_RAIL"`).
3.  **By Constant**: Use the predefined, case-sensitive constant for a node (e.g., `D13`, `TOP_RAIL`).



---


[DAC](#dac-digital-to-analog-converter) (Digital-to-Analog Converter) - *[Examples](08-micropython.md#dac-output-voltage)*:

  - `dac_set(channel, voltage)`         - Set DAC output voltage
  - `dac_get(channel)`                  - Get DAC output voltage
  - `set_dac(channel, voltage) `        - Alias for dac_set
  - `get_dac(channel)`                  - Alias for dac_get

          channel: 0-3, DAC0, DAC1, TOP_RAIL, BOTTOM_RAIL
          channel 0/DAC0: DAC 0
          channel 1/DAC1: DAC 1
          channel 2/TOP_RAIL: top rail
          channel 3/BOTTOM_RAIL: bottom rail
          voltage: -8.0 to 8.0V

[ADC](#adc-analog-to-digital-converter) (Analog-to-Digital Converter) - *[Examples](08-micropython.md#adc-measure-voltage)*:

 - `adc_get(channel)`                  - Read ADC input voltage
 - `get_adc(channel) `                 - Alias for adc_get

          channel: 0-4 (and 7 for the probe tip in Measure mode)

[INA](#ina-currentpower-monitor) (Current/Power Monitor) - *[Examples](08-micropython.md#current-sensing-ina219)*:

  - `ina_get_current(sensor)`          - Read current in amps
  - `ina_get_voltage(sensor)`          - Read shunt voltage
  - `ina_get_bus_voltage(sensor)`      - Read bus voltage
  - `ina_get_power(sensor)`            - Read power in watts
  
  Aliases: `get_current`, `get_voltage`, `get_bus_voltage`, `get_power`

          sensor: 0 or 1

[GPIO](#gpio-general-purpose-inputoutput) - *[Examples](08-micropython.md#gpio-general-purpose-io)*:

 - `gpio_set(pin, value)`             - Set GPIO pin state
 - `gpio_get(pin)`                    - Read GPIO pin state
 - `gpio_set_dir(pin, direction)`     - Set GPIO pin direction
 - `gpio_get_dir(pin)`                - Get GPIO pin direction
 - `gpio_set_pull(pin, pull)`         - Set GPIO pull-up/down
 - `gpio_get_pull(pin)`               - Get GPIO pull-up/down
  
  Aliases: `set_gpio`, `get_gpio`, `set_gpio_dir`, `get_gpio_dir`, etc.

          pin 1-8: GPIO 1-8
          pin   9: UART Tx
          pin  10: UART Rx
            value: True/False   for HIGH/LOW
        direction: True/False   for OUTPUT/INPUT
             pull: -1/0/1       for PULL_DOWN/NONE/PULL_UP

[PWM](#pwm-pulse-width-modulation) (Pulse Width Modulation) - *[Examples](08-micropython.md#pwm-pulse-width-modulation)*:
  
- `pwm(pin, [frequency], [duty])`    - Setup PWM on GPIO pin
 - `pwm_set_duty_cycle(pin, duty)`    - Set PWM duty cycle
 - `pwm_set_frequency(pin, freq)`     - Set PWM frequency
 - `pwm_stop(pin)`                    - Stop PWM on pin

  Aliases: `set_pwm`, `set_pwm_duty_cycle`, `set_pwm_frequency`, `stop_pwm `

             pin: 1-8         GPIO pins only
       frequency: 0.001-62500000 default 1000Hz
      duty_cycle: 0.0-1.0     default 0.5 (50%)


  **Frequency Ranges:**
  - Hardware PWM: 10Hz to 62.5MHz (high precision)
  - Slow PWM: 0.001Hz to 10Hz (hardware timer based)
  - Automatic mode selection based on frequency

[Node Connections](#node-connections) - *[Examples](08-micropython.md#node-connections)*:

 - `connect(node1, node2)`            - Connect two nodes
 - `disconnect(node1, node2)`         - Disconnect nodes
 - `is_connected(node1, node2)`       - Check if nodes are connected
 - `nodes_clear()`                    - Clear all connections 
 - `nodes_save([slot])`               - Save connections to slot
 - `nodes_discard()`                  - Discard unsaved changes
 - `nodes_has_changes()`              - Check for unsaved changes
 - `switch_slot(slot)`                - Switch to a different slot
  
         set node2 to -1 to disconnect everything connected to node1

[Net Information](#net-information-api):

 - `get_net_name(netNum)`             - Get the name of a net
 - `set_net_name(netNum, name)`       - Set a custom net name
 - `get_net_color(netNum)`            - Get net color as 0xRRGGBB
 - `get_net_color_name(netNum)`       - Get net color as name string
 - `set_net_color(netNum, color)`     - Set net color by name or RGB
 - `get_num_nets()`                   - Get number of active nets
 - `get_num_bridges()`                - Get number of bridges
 - `get_net_nodes(netNum)`            - Get comma-separated node list
 - `get_bridge(bridgeIdx)`            - Get bridge info tuple
 - `get_net_info(netNum)`             - Get full net info as dict

[OLED Display](#oled-display) - *[Examples](08-micropython.md#oled-display)*:

 - `oled_print("text")`               - Display text
 - `oled_clear()`                     - Clear display
 - `oled_connect()`                   - Connect OLED
 - `oled_disconnect()`                - Disconnect OLED

<!-- Clickwheel:
  `clickwheel_up([clicks])          - Scroll up
  `clickwheel_down([clicks])        - Scroll down
  `clickwheel_press()               - Press button
           clicks: number of steps -->

[Status](#status-functions) - *[Examples](#the-entire-output-of-help)*:

 -  `print_bridges()`                  - Print all bridges
 - `print_paths()`                    - Print path between nodes
 - `print_crossbars()`                - Print crossbar array
 - `print_nets()`                     - Print nets
 - `print_chip_status()`              - Print chip status

[Probe Functions](#probe) - *[Examples](08-micropython.md#probe-functions)*:

 - `probe_read_blocking()`            - Wait for probe touch (don't return until a pad is touched)
 - `probe_read_nonblocking()`         - Check probe immediately (return -1 if no pad is touched)
 - `get_button([blocking=True])`      - Get button state (default: blocking)
 - `probe_button([blocking=True])`    - Get button state (default: blocking)
 - `probe_button_blocking()`          - Wait for button press
 - `probe_button_nonblocking()`       - Check buttons immediately 
-  `check_button()`                   - Check for probe button presses
  
```
  Touch returns: ProbePad object (1-60, D13_PAD, TOP_RAIL_PAD, LOGO_PAD_TOP, etc.)
  Button returns: CONNECT, REMOVE, or NONE (front=connect, rear=remove)
```

[JFS](08.5-jfs.md) (Jumperless File System):

- `jfs.open(path, mode)` - Opens file, returns file handle
- `jfs.read(file, size=1024)` - Read from file
- `jfs.write(file, data)` - Write to file
- `jfs.close(file)` - Close file
- `jfs.seek(file, position, whence=0)` - Seek in file
- `jfs.tell(file)` - Get current position
- `jfs.size(file)` - Get file size
- `jfs.available(file)` - Get bytes available
- `jfs.exists(path)` - Check if path exists (returns True/False)
- `jfs.listdir(path)` - List directory contents (returns list)
- `jfs.mkdir(path)` - Create directory 
- `jfs.rmdir(path)` - Remove directory
- `jfs.remove(path)` - Remove file
- `jfs.rename(from, to)` - Rename/move file
- `jfs.stat(path)` - Get file/directory status info
- `jfs.info()` - Returns (total, used, free) tuple


[Misc](#system-functions) - *[Examples](08-micropython.md#system-functions)*:

 - `arduino_reset()`                  - Reset Arduino
 - `run_app('appName')`               - Run app
 - `pause_core2(pause)`               - Pause/resume core2 processing
 - `send_raw(chip, x, y, setOrClear)` - Send raw data to core2
 - `context_toggle()`                 - Toggle connection context (global/python)
 - `context_get()`                    - Get current context name

[Help](#help-functions) - *[Examples](#the-entire-output-of-help)*:

 - `help()`                           - Display help
 - `nodes_help()`                     - Show available nodes and how to address them



  ---
## Node Connections

These functions manage the connections between nodes on the breadboard and special function pins.

### `connect(node1, node2)`
Creates a bridge between two nodes.

*   `node1`, `node2`: The nodes to connect. Can be integers, strings, or constants.
*   `save` (optional): If `True` (default), the connection is saved to the current slot's node file. If `False`, it's a temporary connection for the current session.

**Example:**
```jython
# Connect breadboard row 1 to row 30
connect(1, 30)

# Connect Arduino D13 to the top power rail
connect(D13, TOP_RAIL)

# Connect GPIO 1 to ADC 0 using strings
connect("GPIO_1", "ADC0")
```

### `disconnect(node1, node2)`
Removes a specific bridge between two nodes.

*   `node1`, `node2`: The two nodes to disconnect.
*   To remove all connections from a single node, set `node2` to `-1`.

**Example:**
```jython
# Remove the bridge between rows 1 and 30
disconnect(1, 30)

# Remove all connections from GPIO_1
disconnect(GPIO_1, -1)
```

### `is_connected(node1, node2)`
Checks if a direct or indirect connection exists between two nodes.

*   Returns a custom `ConnectionState` object which evaluates to `True` if connected (`CONNECTED`) and `False` if not (`DISCONNECTED`).

**Example:**
```jython
if is_connected(D13, TOP_RAIL):
    print("D13 is connected to the top rail.")

state = is_connected(1, 2)
print(state)  # Prints "CONNECTED" or "DISCONNECTED"
```

### `nodes_clear()`
Removes all connections from the board.

**Example:**
```jython
nodes_clear()
print("All connections cleared.")
```

### `node(name_or_id)`
Creates a node object from a string name or integer ID. This is useful for storing a node reference in a variable.

**Node Type:**

`Node` objects support arithmetic and comparison operations with integers:

*   **Comparisons**: `==`, `!=`, `<`, `<=`, `>`, `>=`
*   **Arithmetic**: `+`, `-`, `*`, `//`, `%`
*   **Conversions**: `int(node)` converts to integer value

**Example:**
```jython
my_pin = node("D7")
led_pin = node(15)

connect(my_pin, led_pin)
oled_print(my_pin) # Displays 'D7' on the OLED

# Arithmetic and comparison work!
if my_pin <= 20:
    next_pin = my_pin + 1  # Returns int 8
    connect(next_pin, led_pin)
```

### `nodes_save([slot])`
Saves the current connections to a slot file.

*   `slot` (optional): The slot number to save to. Defaults to the current active slot.
*   Returns the slot number that was saved to.

**Example:**
```jython
# Save to current slot
nodes_save()

# Save to a specific slot
nodes_save(3)
```

### `nodes_discard()`
Discards all unsaved changes and restores the last saved state.

**Example:**
```jython
connect(1, 5)  # Make a change
nodes_discard()  # Undo it
```

### `nodes_has_changes()`
Checks if there are unsaved changes since the last save.

*   Returns `True` if there are unsaved changes, `False` otherwise.

**Example:**
```jython
if nodes_has_changes():
    print("You have unsaved changes!")
```

### `switch_slot(slot)`
Switches to a different connection slot.

*   `slot`: The slot number to switch to (0-7).
*   Returns the previous slot number.

**Example:**
```jython
old_slot = switch_slot(2)  # Switch to slot 2
print("Was in slot: " + str(old_slot))
```

---

## Net Information API

Functions for querying and modifying net metadata. Nets are groups of connected nodes.

### `get_net_name(netNum)`
Gets the name of a specific net.

*   `netNum`: The net number (0 to number of nets - 1).
*   Returns the net name string, or `None` if the net doesn't exist.

**Example:**
```jython
name = get_net_name(0)
print("Net 0 is called: " + str(name))
```

### `set_net_name(netNum, name)`
Sets a custom name for a net.

*   `netNum`: The net number.
*   `name`: The new name string. Pass empty string or `None` to reset to default.

**Example:**
```jython
set_net_name(0, "VCC")
set_net_name(1, "Signal_A")
```

### `get_net_color(netNum)`
Gets the color of a net as a 32-bit RGB value.

*   `netNum`: The net number.
*   Returns the color as `0xRRGGBB`.

**Example:**
```jython
color = get_net_color(0)
print("Net color: " + hex(color))  # e.g., "0xff0000" for red
```

### `get_net_color_name(netNum)`
Gets the color name of a net as a human-readable string.

*   `netNum`: The net number.
*   Returns a color name like "red", "blue", "green", etc.

**Example:**
```jython
color_name = get_net_color_name(0)
print("Net 0 is " + color_name)  # e.g., "Net 0 is red"
```

### `set_net_color(netNum, color, [r], [g], [b])`
Sets the color of a net by name, hex string, or RGB values.

*   `netNum`: The net number.
*   `color`: Color as a name ("red", "blue", "pink") or hex string ("#FF0000", "0xFF0000").
*   `r`, `g`, `b` (optional): If providing RGB values directly, pass them as separate arguments.
*   Returns `1` on success, `0` on failure (invalid color).

**Available color names:** red, orange, amber, yellow, chartreuse, green, seafoam, cyan, blue, royal blue, indigo, violet, purple, pink, magenta, brown, white, black, grey

**Example:**
```jython
# Set by color name
set_net_color(0, "red")
set_net_color(1, "cyan")

# Set by hex string
set_net_color(2, "#FF00FF")  # Magenta
set_net_color(3, "0x00FF00")  # Green

# Set by RGB values
set_net_color(4, 255, 128, 0)  # Orange
```

### `set_net_color_hsv(netNum, h, [s], [v])`
Sets the color of a net using HSV (Hue, Saturation, Value) color space. Automatically detects whether you're using normalized (0.0-1.0) or full-range (0-255) values based on the hue parameter.

*   `netNum`: The net number.
*   `h`: Hue value. If `h` is between 0.0-1.0, all HSV values are treated as normalized (0.0-1.0). Otherwise, values are treated as 0-255 range.
*   `s` (optional): Saturation value. Defaults to maximum saturation (255) if not provided or negative.
*   `v` (optional): Value/brightness. Defaults to 32 (reasonable LED brightness) if not provided or negative.
*   Returns `1` on success, `0` on failure.

**Range auto-detection:**
- If `h` ≤ 1.0: Normalized mode (0.0-1.0 for all values)
- If `h` > 1.0: Full-range mode (0-255 for all values)

**Default brightness (32):** This provides good visibility without being overly bright. For maximum brightness, explicitly set `v` to 1.0 (normalized) or 255 (full-range).

**Example:**
```jython
# Normalized mode (0.0-1.0) - detected because h <= 1.0
set_net_color_hsv(0, 0.0)           # Pure red, max saturation, default brightness (32)
set_net_color_hsv(1, 0.33)          # Green, max saturation, default brightness (32)
set_net_color_hsv(2, 0.66)          # Blue, max saturation, default brightness (32)
set_net_color_hsv(3, 0.5, 0.8)      # Cyan with 80% saturation, default brightness (32)
set_net_color_hsv(4, 0.5, 1.0, 0.5) # Cyan with max saturation, 50% brightness
set_net_color_hsv(5, 0.0, 1.0, 1.0) # Pure red at MAXIMUM brightness (255)

# Full-range mode (0-255) - detected because h > 1.0
set_net_color_hsv(6, 0)             # Pure red, max saturation, default brightness (32)
set_net_color_hsv(7, 85)            # Green (85 ≈ 255/3), default brightness (32)
set_net_color_hsv(8, 170)           # Blue (170 ≈ 2*255/3), default brightness (32)
set_net_color_hsv(9, 128, 200)      # Cyan-ish with 200/255 saturation, default brightness
set_net_color_hsv(10, 128, 255, 128)# Cyan with max saturation, 50% brightness
set_net_color_hsv(11, 128, 255, 255)# Cyan at MAXIMUM brightness (255)

# Using all defaults (h only)
set_net_color_hsv(12, 0.25)         # Yellow with full saturation, brightness 32
set_net_color_hsv(13, 64)           # Yellow in 0-255 mode, brightness 32
```

**Why use HSV?**
HSV is often more intuitive for color selection than RGB:
- **Hue** represents the actual color (red → yellow → green → cyan → blue → magenta → red)
- **Saturation** controls color intensity (0 = grayscale, max = vivid color)
- **Value** controls brightness (0 = black, max = full brightness)

### `get_num_nets()`
Gets the number of currently active nets.

*   Returns an integer.

**Example:**
```jython
num = get_num_nets()
print("There are " + str(num) + " nets")
```

### `get_num_bridges()`
Gets the total number of bridges (connections).

*   Returns an integer.

**Example:**
```jython
num = get_num_bridges()
print("There are " + str(num) + " bridges")
```

### `get_net_nodes(netNum)`
Gets all nodes in a net as a comma-separated string.

*   `netNum`: The net number.
*   Returns a string like "D13,TOP_RAIL,GPIO_1".

**Example:**
```jython
nodes = get_net_nodes(0)
print("Net 0 contains: " + nodes)
```

### `get_bridge(bridgeIdx)`
Gets information about a specific bridge.

*   `bridgeIdx`: The bridge index (0 to number of bridges - 1).
*   Returns a tuple `(node1, node2, duplicates)`.

**Example:**
```jython
bridge = get_bridge(0)
print("Bridge 0: " + str(bridge[0]) + " to " + str(bridge[1]))
```

### `get_net_info(netNum)`
Gets comprehensive information about a net as a dictionary.

*   `netNum`: The net number.
*   Returns a dict with keys: `name`, `number`, `color`, `color_name`, `nodes`.

**Example:**
```jython
info = get_net_info(0)
print("Net name: " + info['name'])
print("Net color: " + info['color_name'])
print("Net nodes: " + info['nodes'])
```

---

## DAC (Digital-to-Analog Converter)

Functions for controlling the analog voltage outputs.

### `dac_set(channel, voltage, [save=True])`
Sets the output voltage for a specific DAC channel.

*   `channel`: The DAC channel to set. Can be an integer (0-3) or a node constant (`DAC0`, `DAC1`, `TOP_RAIL`, `BOTTOM_RAIL`).
*   `voltage`: The desired voltage (from -8.0V to 8.0V).
*   `save` (optional): If `True` (default), the setting is saved to the config file.
*   **Aliases**: `set_dac()`

**Channels:**
*   `0` or `DAC0`: The 5V tolerant DAC output.
*   `1` or `DAC1`: The 8V tolerant DAC output.
*   `2` or `TOP_RAIL`: The top power rail.
*   `3` or `BOTTOM_RAIL`: The bottom power rail.

**Example:**
```jython
# Set the top rail to 5V
dac_set(TOP_RAIL, 5.0)

# Set DAC0 to 1.25V
set_dac(DAC0, 1.25)
```

### `dac_get(channel)`
Reads the currently set voltage for a DAC channel.

*   `channel`: The DAC channel to read.
*   Returns a float.
*   **Aliases**: `get_dac()`

**Example:**
```jython
voltage = dac_get(TOP_RAIL)
print("Top Rail voltage: " + str(voltage))
```

---

## ADC (Analog-to-Digital Converter)

Functions for measuring analog voltages.

### `adc_get(channel)`
Reads the voltage from a specific ADC channel.

*   `channel`: The ADC channel to read (0-4).
*   Returns a float.
*   **Aliases**: `get_adc()`

**Channels:**
*   `0-3`: 8V tolerant ADC inputs.
*   `4`: 5V tolerant ADC input.

**Example:**
```jython
voltage = adc_get(0)
print("ADC0 voltage: " + str(voltage))
```

---

## GPIO (General Purpose Input/Output)

Functions for controlling the digital I/O pins.

### `gpio_set(pin, value)`
Sets the output state of a GPIO pin.

*   `pin`: The GPIO pin number (1-10).
*   `value`: `True` for HIGH, `False` for LOW.
*   **Aliases**: `set_gpio()`

### `gpio_get(pin)`
Reads the state of a GPIO pin.

*   `pin`: The GPIO pin number (1-10).
*   Returns a `GPIOState` object (`HIGH`, `LOW`, or `FLOATING`).
*   **Aliases**: `get_gpio()`

### `gpio_set_dir(pin, direction)`
Sets the direction of a GPIO pin.

*   `pin`: The GPIO pin number (1-10).
*   `direction`: `True` for OUTPUT, `False` for INPUT.
*   **Aliases**: `set_gpio_dir()`

### `gpio_get_dir(pin)`
Reads the direction of a GPIO pin.

*   `pin`: The GPIO pin number (1-10).
*   Returns a `GPIODirection` object (`INPUT` or `OUTPUT`).
*   **Aliases**: `get_gpio_dir()`

### `gpio_set_pull(pin, pull)`
Configures the internal pull resistor for a GPIO pin.

*   `pin`: The GPIO pin number (1-10).
*   `pull`: `1` for PULLUP, `-1` for PULLDOWN, `0` for NONE.
*   **Aliases**: `set_gpio_pull()`

### `gpio_get_pull(pin)`
Reads the pull resistor configuration of a GPIO pin.

*   `pin`: The GPIO pin number (1-10).
*   Returns a `GPIOPull` object (`PULLUP`, `PULLDOWN`, or `NONE`).
*   **Aliases**: `get_gpio_pull()`

**Pinout:**
*   `1-8`: Routable GPIO pins `GPIO_1` to `GPIO_8`.
*   `9`: `UART_TX`.
*   `10`: `UART_RX`.

**Example:**
```jython
# Set GPIO 1 as an output and turn it on
gpio_set_dir(1, True)
gpio_set(1, True)

# Set GPIO 2 as an input with a pull-up
gpio_set_dir(2, False)
gpio_set_pull(2, 1)

# Read the state of GPIO 2
state = gpio_get(2)
if state:  # GPIOState is truthy when HIGH, falsy when LOW or FLOATING
    print("GPIO 2 is HIGH")
# You can also print it directly - shows "HIGH", "LOW", or "FLOATING"
print("State: " + str(state))
```

---

## PWM (Pulse-Width Modulation)

Functions for generating PWM signals on GPIO pins.

### `pwm(pin, [frequency], [duty_cycle])`
Sets up and starts a PWM signal on a GPIO pin.

*   `pin`: The GPIO pin to use (1-8).
*   `frequency` (optional): The PWM frequency in Hz (0.001 to 62500000). Defaults to 1000.
*   `duty_cycle` (optional): The duty cycle from 0.0 to 1.0. Defaults to 0.5.
*   **Aliases**: `set_pwm()`

**Frequency Ranges:**
*   **Hardware PWM**: 10Hz to 62.5MHz (high precision, hardware peripheral)
*   **Slow PWM**: 0.001Hz to 10Hz (hardware timer based, precise timing)
*   **Automatic Selection**: System automatically chooses the appropriate mode based on frequency

### `pwm_set_duty_cycle(pin, duty_cycle)`
Changes the duty cycle of an existing PWM signal.

*   `pin`: The GPIO pin number (1-8).
*   `duty_cycle`: The new duty cycle (0.0 to 1.0).
*   **Aliases**: `set_pwm_duty_cycle()`

### `pwm_set_frequency(pin, frequency)`
Changes the frequency of an existing PWM signal.

*   `pin`: The GPIO pin number (1-8).
*   `frequency`: The new frequency in Hz (0.001 to 62500000).
*   **Aliases**: `set_pwm_frequency()`

### `pwm_stop(pin)`
Stops the PWM signal on a GPIO pin.

*   `pin`: The GPIO pin number (1-8).
*   **Aliases**: `stop_pwm()`

**Example:**
```jython
# Hardware PWM: 1kHz, 25% duty cycle on GPIO_1
pwm(GPIO_1, 1000, 0.25)

# Slow PWM: 0.1Hz (10 second period), 50% duty cycle on GPIO_2
pwm(GPIO_2, 0.1, 0.5)

# Ultra-slow PWM: 0.001Hz (1000 second period), 25% duty cycle on GPIO_3
pwm(GPIO_3, 0.001, 0.25)

# Change the duty cycle to 75%
pwm_set_duty_cycle(GPIO_1, 0.75)

# Change frequency (will automatically switch between hardware/slow PWM)
pwm_set_frequency(GPIO_1, 500)  # 500Hz (hardware PWM)
pwm_set_frequency(GPIO_1, 5)    # 5Hz (slow PWM)

# Stop the PWM signal
pwm_stop(GPIO_1)
```

---

## WaveGen (Waveform Generator)

Functions for generating analog waveforms on DAC outputs.

**Setters:**

- `wavegen_set_output(output)`          - Select output: `DAC0`, `DAC1`, `TOP_RAIL`, `BOTTOM_RAIL` (default `DAC1`)
- `wavegen_set_freq(hz)`                - Set frequency: 0.0001–10000.0 Hz (default 100 Hz)
- `wavegen_set_wave(shape)`             - Set waveform shape (see constants below)
- `wavegen_set_sweep(start_hz, end_hz, seconds)` - Configure a linear sweep
- `wavegen_set_amplitude(vpp)`          - 0.0–16.0 Vpp (default 3.3 Vpp)
- `wavegen_set_offset(v)`               - -8.0–+8.0 V (default 1.65 V for 0–3.3 V centered)
- `wavegen_start([run=True])`           - Start/stop output; calling with False stops
- `wavegen_stop()`                      - Stop output immediately

**Getters:**

- `wavegen_get_output()`                - Get current output channel
- `wavegen_get_freq()`                  - Get current frequency
- `wavegen_get_wave()`                  - Get current waveform
- `wavegen_get_amplitude()`             - Get current amplitude (Vpp)
- `wavegen_get_offset()`                - Get current offset
- `wavegen_is_running()`                - Check if wavegen is active

**Aliases:** All setters/getters have `set_wavegen_*` and `get_wavegen_*` aliases.

**Waveform Constants:**

- `SINE` (0)       - Sine wave
- `TRIANGLE` (1)   - Triangle wave  
- `SAWTOOTH` (2)   - Sawtooth/ramp wave
- `RAMP` (2)       - Alias for SAWTOOTH
- `SQUARE` (3)     - Square wave
- `ARBITRARY` (4)  - Arbitrary waveform (not yet implemented)

**Example:**
```jython
# Generate a 100Hz sine wave on DAC1
wavegen_set_output(DAC1)
wavegen_set_wave(SINE)
wavegen_set_freq(100)
wavegen_set_amplitude(3.3)  # 3.3V peak-to-peak
wavegen_set_offset(1.65)    # Center at 1.65V (0-3.3V range)
wavegen_start()

# Check if running
if wavegen_is_running():
    print("Wavegen active at " + str(wavegen_get_freq()) + "Hz")

# Change waveform while running
wavegen_set_wave(TRIANGLE)

# Stop
wavegen_stop()
```

**Notes:**
- Wavegen runs on core 2 and is fully blocking while active; LEDs and routing updates pause until `wavegen_stop()`.
- Frequency, waveform, amplitude, and offset can be changed live while running.
  

---

## INA (Current/Power Monitor)

Functions for reading data from the INA219 current sensors.

### `ina_get_current(sensor)`
Reads the current in Amps.
*   `sensor`: The sensor to read (0 or 1).
*   **Aliases**: `get_current()`

### `ina_get_voltage(sensor)`
Reads the shunt voltage in Volts.
*   `sensor`: The sensor to read (0 or 1).
*   **Aliases**: `get_voltage()`

### `ina_get_bus_voltage(sensor)`
Reads the bus voltage in Volts.
*   `sensor`: The sensor to read (0 or 1).
*   **Aliases**: `get_bus_voltage()`

### `ina_get_power(sensor)`
Reads the power in Watts.
*   `sensor`: The sensor to read (0 or 1).
*   **Aliases**: `get_power()`

**Example:**
```jython
current_mA = ina_get_current(0) * 1000
print("Current: " + str(current_mA) + " mA")
```

---

## OLED Display

Functions for controlling the onboard OLED display.

### `oled_print(text, [size=2])`
Displays text on the OLED screen. It can print strings, numbers, and custom Jumperless types.

*   `text`: The content to display.
*   `size` (optional): The font size (1 or 2). Defaults to 2.

### `oled_clear()`
Clears the OLED display.

### `oled_show()`
Refreshes the OLED display to show the latest changes. (Note: Often not needed as `oled_print` handles this).

### `oled_connect()`
Connects the I2C lines to the OLED display.

### `oled_disconnect()`
Disconnects the I2C lines from the OLED display.

**Example:**
```jython
oled_connect()
oled_print("Hello!")
time.sleep(2)
oled_clear()
oled_disconnect()
```

---

## Probe

Functions for interacting with the physical probe.

### `probe_read([blocking=True])`
Reads the pad currently being touched by the probe.

*   `blocking` (optional): If `True` (default), the function will wait until a pad is touched. If `False`, it returns immediately.
*   Returns a `ProbePad` object (e.g., `25`, `D13_PAD`, `NO_PAD`).
*   **Aliases**: `read_probe()`, `probe_read_blocking()`, `probe_read_nonblocking()`, `probe_wait()`, `wait_probe()`, `probe_touch()`, `wait_touch()`

**ProbePad Type:**

`ProbePad` objects support arithmetic and comparison operations with integers:

*   **Comparisons**: `==`, `!=`, `<`, `<=`, `>`, `>=`
*   **Arithmetic**: `+`, `-`, `*`, `//`, `%`
*   **Conversions**: `int(pad)` converts to integer value

**Example:**
```jython
pad = probe_read(False)  # Non-blocking

if pad != NO_PAD:
    print(pad)
    if pad <= 60:  # Compare with integer
        node_1 = pad
        node_2 = pad + 3  # Arithmetic with integer
        if node_2 > 60:   # Works!
            node_2 -= 60
        connect(node_1, node_2)
```

### `probe_button([blocking=True], [consume=False])`
Reads the state of the buttons on the probe.

*   `blocking` (optional): If `True` (default), waits for a button press. If `False`, returns the current state immediately.
*   `consume` (optional): If `True`, clears the button press after reading (one-shot detection). If `False` (default), the button state persists while held, allowing repeated reads in a loop.
*   Returns a `ProbeButton` object (`CONNECT_BUTTON`, `REMOVE_BUTTON`, or `BUTTON_NONE`).
*   **Aliases**: `get_button()`, `button_read()`, `read_button()`, `probe_button_blocking()`, `probe_button_nonblocking()`, `check_button()`, `button_check()`

**Consume Behavior:**
- `consume=False` (default): Holding the button returns the same state repeatedly - **ideal for continuous control** (e.g., incrementing values while held)
- `consume=True`: Each button press is detected only once - ideal for menu navigation or one-shot actions

**Example:**
```jython
# Continuous control - hold button to keep changing hue
while True:
    button = check_button()  # consume=False by default
    if button == BUTTON_CONNECT:
        hue += 1  # Keeps incrementing while button is held
        set_net_color_hsv(0, hue)
    elif button == BUTTON_REMOVE:
        hue -= 1  # Keeps decrementing while button is held
        set_net_color_hsv(0, hue)
    time.sleep(0.05)

# One-shot detection - each press counted once
presses = 0
while presses < 5:
    button = get_button(consume=True)  # Each press consumed
    if button == BUTTON_CONNECT:
        presses += 1
        print(f"Press #{presses}")
```

**Example:**
```jython
print("Touch a pad...")
pad = probe_read()
print("You touched: " + str(pad))

if pad == D13_PAD:
    print("That's the Arduino LED pin!")

print("Press a probe button...")
button = get_button()
if button == CONNECT_BUTTON:
    print("Connect button pressed.")
```

---

### `get_switch_position()`
Gets the current probe switch position.

*   Returns: `0` (SWITCH_MEASURE), `1` (SWITCH_SELECT), or `-1` (SWITCH_UNKNOWN)

**Example:**
```jython
position = get_switch_position()
if position == SWITCH_MEASURE:
    print("Probe is in measure mode")
elif position == SWITCH_SELECT:
    print("Probe is in select mode")
```

### `set_switch_position(position)`
Manually sets the probe switch position.

*   `position`: `0` (SWITCH_MEASURE), `1` (SWITCH_SELECT), or `-1` (SWITCH_UNKNOWN)

**Example:**
```jython
set_switch_position(SWITCH_SELECT)  # Force select mode
```

### `check_switch_position()`
Checks the probe switch position using current sensing and updates the internal state.

*   Returns: Updated switch position

Uses hysteresis thresholds to prevent oscillation between modes:
- Switches to SELECT when current > high threshold
- Switches to MEASURE when current < low threshold

**Example:**
```jython
# Periodically check and respond to switch changes
while True:
    position = check_switch_position()
    if position == SWITCH_MEASURE:
        voltage = measureMode()
        print(f"Voltage: {voltage}V")
    elif position == SWITCH_SELECT:
        pad = probe_read(blocking=False)
        if pad != NO_PAD:
            print(f"Touched: {pad}")
    time.sleep(0.1)
```

---

## Clickwheel

Functions for reading the rotary encoder (clickwheel) position, direction, and button state.

### `clickwheel_get_position()`
Gets the raw clickwheel position counter.

*   Returns: Current position value (integer, can be positive or negative)

The position accumulates as you turn the clickwheel - clockwise increases, counter-clockwise decreases.

**Example:**
```jython
pos = clickwheel_get_position()
print(f"Current position: {pos}")
```

### `clickwheel_reset_position()`
Resets the clickwheel position counter to 0.

**Example:**
```jython
clickwheel_reset_position()
assert clickwheel_get_position() == 0
```

### `clickwheel_get_direction([consume=True])`
Gets the current clickwheel direction event.

*   `consume` (optional): If `True` (default), clears the direction after reading (one-shot detection). If `False`, the direction persists until consumed.
*   Returns: `CLICKWHEEL_NONE` (0), `CLICKWHEEL_UP` (1), or `CLICKWHEEL_DOWN` (2)

**Important:** The direction state **persists** until consumed! This means you won't miss turn events even if you don't check every loop iteration. The UP or DOWN state stays active until you read it with `consume=True`.

**Example (One-shot - Default):**
```jython
direction = clickwheel_get_direction()  # consume=True (default)
if direction == CLICKWHEEL_UP:
    value += 1  # Only increments once per turn event
    print(f"Turned up: {value}")
elif direction == CLICKWHEEL_DOWN:
    value -= 1  # Only decrements once per turn event
    print(f"Turned down: {value}")
```

**Example (Persistent - Check Multiple Times):**
```jython
# Check direction without consuming
direction = clickwheel_get_direction(consume=False)

if direction == CLICKWHEEL_UP:
    print("Turning clockwise...")
    # Do some work...
    
    # Check again - still UP until consumed!
    if clickwheel_get_direction(consume=False) == CLICKWHEEL_UP:
        print("Still turning up!")
    
    # Finally consume it
    clickwheel_get_direction(consume=True)
```

### `clickwheel_get_button()`
Gets the current clickwheel button state.

*   Returns: 
    - `CLICKWHEEL_IDLE` (0) - Not pressed
    - `CLICKWHEEL_PRESSED` (1) - Just pressed
    - `CLICKWHEEL_HELD` (2) - Being held down
    - `CLICKWHEEL_RELEASED` (3) - Just released
    - `CLICKWHEEL_DOUBLECLICKED` (4) - Double-clicked

**Example:**
```jython
button = clickwheel_get_button()
if button == CLICKWHEEL_PRESSED:
    print("Button pressed!")
elif button == CLICKWHEEL_HELD:
    print("Button held down")
elif button == CLICKWHEEL_DOUBLECLICKED:
    print("Double click!")
```

### `clickwheel_is_initialized()`
Checks if the clickwheel hardware is initialized and ready.

*   Returns: `True` if ready, `False` otherwise

**Example:**
```jython
if clickwheel_is_initialized():
    pos = clickwheel_get_position()
else:
    print("Clickwheel not available")
```

**Complete Example - Menu Navigation:**
```jython
import jumperless as j
import time

menu_items = ["Option 1", "Option 2", "Option 3", "Option 4"]
selected = 0

j.clickwheel_reset_position()

while True:
    # Check direction (consume=True by default - one turn = one event)
    direction = j.clickwheel_get_direction()
    if direction == j.CLICKWHEEL_UP:
        selected = (selected + 1) % len(menu_items)
        print(f"> {menu_items[selected]}")
    elif direction == j.CLICKWHEEL_DOWN:
        selected = (selected - 1) % len(menu_items)
        print(f"> {menu_items[selected]}")
    
    # Check button
    button = j.clickwheel_get_button()
    if button == j.CLICKWHEEL_PRESSED:
        print(f"Selected: {menu_items[selected]}")
    elif button == j.CLICKWHEEL_DOUBLECLICKED:
        print("Exit menu")
        break
    
    # Note: Direction persists, so even with slow polling (50ms),
    # you won't miss turn events!
    time.sleep(0.05)
```

**Example - Value Adjustment with Persistence:**
```jython
import jumperless as j
import time

value = 50

while True:
    # Check direction without consuming
    direction = j.clickwheel_get_direction(consume=False)
    
    if direction == j.CLICKWHEEL_UP:
        value = min(100, value + 1)
        j.oled_print(f"Value: {value}", 2)
        time.sleep(0.1)  # Delay for visual feedback
        # Consume after displaying
        j.clickwheel_get_direction(consume=True)
        
    elif direction == j.CLICKWHEEL_DOWN:
        value = max(0, value - 1)
        j.oled_print(f"Value: {value}", 2)
        time.sleep(0.1)
        j.clickwheel_get_direction(consume=True)
    
    # Exit on button press
    if j.clickwheel_get_button() == j.CLICKWHEEL_PRESSED:
        break
    
    time.sleep(0.01)
```

---

## System Functions

### `arduino_reset()`
Resets the connected Arduino Nano.


### `run_app(appName)`
Launches a built-in Jumperless application.

*   `appName`: The name of the app to run (e.g., "File Manager", "I2C Scan").



### `pause_core2(pause)`
Pauses or resumes core2 processing.


*   `pause`: `True` to pause core2, `False` to resume. 

*For doing time sensitive things where you don't want core 2 to cause timing glitches while it periodically updates the LEDs.* Core 2 will resume when you exit the REPL no matter what.

### `send_raw(chip, x, y, setOrClear)`
Sends raw data to core2 for direct chip control.


*   `chip`: Chip identifier (string, e.g., "A", "B", "C").
*   `x`, `y`: Coordinates for the operation.
*   `setOrClear`: `1` to set, `0` to clear.
  
  You should probably be looking at the schematic if you use this. By bypassing all the routing logic, you can make or break connections in ~1 µs. Pretty handy if want to do high speed switching between known states.

### `force_service(name)`
Forces immediate execution of a specific system service by name.

*   `name`: Service name as a string (e.g., `"ProbeButton"`, `"Peripherals"`).
*   Returns: `True` if service was found and executed, `False` otherwise.

Useful for manually triggering specific services during tight loops where automatic service scheduling might not run frequently enough.

**Example:**
```jython
while True:
    # Fast loop that might miss automatic service updates
    connect(1, 2)
    force_service("ProbeButton")  # Ensure button state updates
    button = check_button()
    time.sleep(0.001)
```

### `force_service_by_index(index)`
Forces immediate execution of a specific system service by index (faster than name lookup).

*   `index`: Service index (integer, obtained via `get_service_index()`).
*   Returns: `True` if index valid and service executed, `False` otherwise.

**Example:**
```jython
# Cache the index once for maximum speed
btn_idx = get_service_index("ProbeButton")

while True:
    connect(1, 2)
    force_service_by_index(btn_idx)  # Fastest way to force service
    button = check_button()
    time.sleep(0.001)
```

### `get_service_index(name)`
Gets the index of a service by name for use with `force_service_by_index()`.

*   `name`: Service name as a string.
*   Returns: Service index (integer, 0 or higher), or `-1` if not found.

Cache the returned index for repeated fast calls to `force_service_by_index()`.

**Example:**
```jython
# Look up once, use many times
probe_idx = get_service_index("ProbeButton")
if probe_idx >= 0:
    # Use the cached index in your loop
    force_service_by_index(probe_idx)
```

### `context_toggle()`
Toggles the connection context between `global` and `python` modes.

*   In **global** mode: Connection changes persist after exiting Python.
*   In **python** mode: Connection state is restored when you exit the REPL.

**Example:**
```jython
context_toggle()  # Switch from global to python (or vice versa)
print("Now in " + context_get() + " mode")
```

### `context_get()`
Gets the current connection context name.

*   Returns `"global"` or `"python"`.

**Example:**
```jython
if context_get() == "global":
    print("Changes will persist after exit")
else:
    print("Changes will be discarded on exit")
```

---

## Status Functions

These functions print detailed status information to the serial console.

*   `print_bridges()`: Prints all active bridges.
*   `print_paths()`: Prints all resolved paths between nodes.
*   `print_crossbars()`: Prints the raw state of the crossbar matrix.
*   `print_nets()`: Prints the current net list.
*   `print_chip_status()`: Prints the status of the CH446Q chips.

---

## Help Functions

### `help()`
Displays a comprehensive list of all available functions and constants in the `jumperless` module. 

You can also pass it sections, so `help("GPIO")` will just print that section.

### `nodes_help()`
Displays a detailed reference for all available node names and their aliases. 

## Node Names and Constants
The Jumperless module provides extensive node name support with multiple aliases for each node:

```jython
# Power rails (multiple aliases supported)
TOP_RAIL = 101        # Also: TOPRAIL, T_R, TOP_R
BOTTOM_RAIL = 102     # Also: BOT_RAIL, BOTTOMRAIL, BOTRAIL, B_R, BOT_R
SUPPLY_3V3 = 103      # Also: 3V3, 3.3V
SUPPLY_5V = 105       # Also: 5V, +5V
SUPPLY_8V_P = 120     # Also: 8V_P, 8V_POS
SUPPLY_8V_N = 121     # Also: 8V_N, 8V_NEG

# Ground connections
GND = 100             # Also: GROUND
TOP_RAIL_GND = 104    # Also: TOP_GND (not actually routable but included for PADs)
BOTTOM_RAIL_GND = 126 # Also: BOT_GND, BOTTOM_GND (not actually routable but included for PADs)

# DAC outputs
DAC0 = 106            # Also: DAC_0, DAC0_5V
DAC1 = 107            # Also: DAC_1, DAC1_8V

# ADC inputs
ADC0 = 110            # Also: ADC_0, ADC0_8V
ADC1 = 111            # Also: ADC_1, ADC1_8V
ADC2 = 112            # Also: ADC_2, ADC2_8V
ADC3 = 113            # Also: ADC_3, ADC3_8V
ADC4 = 114            # Also: ADC_4, ADC4_5V
ADC7 = 115            # Also: ADC_7, ADC7_PROBE, PROBE

# Current sensing
ISENSE_PLUS = 108     # Also: ISENSE_POS, ISENSE_P, INA_P, I_P, CURRENT_SENSE_PLUS, ISENSE_POSITIVE, I_POS
ISENSE_MINUS = 109    # Also: ISENSE_NEG, ISENSE_N, INA_N, I_N, CURRENT_SENSE_MINUS, ISENSE_NEGATIVE, I_NEG

# GPIO pins (multiple naming conventions)
GPIO_1 = 131          # Also: RP_GPIO_1, GPIO1, GP_1, GP1
GPIO_2 = 132          # Also: RP_GPIO_2, GPIO2, GP_2, GP2
GPIO_3 = 133          # Also: RP_GPIO_3, GPIO3, GP_3, GP3
GPIO_4 = 134          # Also: RP_GPIO_4, GPIO4, GP_4, GP4
GPIO_5 = 135          # Also: RP_GPIO_5, GPIO5, GP_5, GP5
GPIO_6 = 136          # Also: RP_GPIO_6, GPIO6, GP_6, GP6
GPIO_7 = 137          # Also: RP_GPIO_7, GPIO7, GP_7, GP7
GPIO_8 = 138          # Also: RP_GPIO_8, GPIO8, GP_8, GP8

# UART pins
UART_TX = 116         # Also: RP_UART_TX, TX, RP_GPIO_16
UART_RX = 117         # Also: RP_UART_RX, RX, RP_GPIO_17

# Additional RP GPIOs
RP_GPIO_18 = 118      # Also: GP_18
RP_GPIO_19 = 119      # Also: GP_19

# Buffer connections
BUFFER_IN = 139       # Also: ROUTABLE_BUFFER_IN, BUF_IN, BUFF_IN, BUFFIN
BUFFER_OUT = 140      # Also: ROUTABLE_BUFFER_OUT, BUF_OUT, BUFF_OUT, BUFFOUT

# Arduino Nano pins (extensive support)
D13 = 83              # Also: NANO_D13
D12 = 82              # Also: NANO_D12
D11 = 81              # Also: NANO_D11
D10 = 80              # Also: NANO_D10
D9 = 79               # Also: NANO_D9
D8 = 78               # Also: NANO_D8
D7 = 77               # Also: NANO_D7
D6 = 76               # Also: NANO_D6
D5 = 75               # Also: NANO_D5
D4 = 74               # Also: NANO_D4
D3 = 73               # Also: NANO_D3
D2 = 72               # Also: NANO_D2
D1 = 71               # Also: NANO_D1
D0 = 70               # Also: NANO_D0

# Arduino Nano analog pins
A0 = 86               # Also: NANO_A0
A1 = 87               # Also: NANO_A1
A2 = 88               # Also: NANO_A2
A3 = 89               # Also: NANO_A3
A4 = 90               # Also: NANO_A4
A5 = 91               # Also: NANO_A5
A6 = 92               # Also: NANO_A6
A7 = 93               # Also: NANO_A7

# Arduino Nano non-routable hardwired connections
VIN = 69              # Unconnected to anything
RST0 = 94             # Hardwired to GPIO 18 on the RP2350
RST1 = 95             # Hardwired to GPIO 19 on the RP2350
N_GND0 = 97           # GND
N_GND1 = 96           # GND
NANO_5V = 99          # Hardwired to USB 5V bus (can also be used to power the Jumperless)
NANO_3V3 = 98         # Unconnected (without bridging the solder jumper on the back)

```




## The entire output of help()

```jython
>>> help()
Jumperless Native MicroPython Module
Available help sections:

  help() or help("all")     - Show all functions
  help("DAC")              - DAC functions
  help("ADC")              - ADC functions
  help("GPIO")             - GPIO functions
  help("PWM")              - PWM functions
  help("WAVEGEN")          - Waveform generator
  help("INA")              - INA current/power monitor
  help("NODES")            - Node connections
  help("NETS")             - Net info (names, colors)
  help("SLOTS")            - Slot management
  help("OLED")             - OLED display
  help("PROBE")            - Probe and button functions
  help("CLICKWHEEL")       - Clickwheel (rotary encoder) functions
  help("STATUS")           - Status and debug functions
  help("FILESYSTEM")       - Filesystem functions
  help("MISC")             - Miscellaneous functions
  help("EXAMPLES")         - Usage examples

DAC (Digital-to-Analog Converter):

   dac_set(channel, voltage)         - Set DAC output voltage
   dac_get(channel)                  - Get DAC output voltage
   set_dac(channel, voltage)         - Alias for dac_set
   get_dac(channel)                  - Alias for dac_get

          channel: 0-3, DAC0, DAC1, TOP_RAIL, BOTTOM_RAIL
          channel 0/DAC0: DAC 0
          channel 1/DAC1: DAC 1
          channel 2/TOP_RAIL: top rail
          channel 3/BOTTOM_RAIL: bottom rail
          voltage: -8.0 to 8.0V

ADC (Analog-to-Digital Converter):

   adc_get(channel)                  - Read ADC input voltage
   get_adc(channel)                  - Alias for adc_get

                                              channel: 0-4

GPIO:

   gpio_set(pin, value)             - Set GPIO pin state
   gpio_get(pin)                    - Read GPIO pin state
   gpio_set_dir(pin, direction)     - Set GPIO pin direction
   gpio_get_dir(pin)                - Get GPIO pin direction
   gpio_set_pull(pin, pull)         - Set GPIO pull-up/down
   gpio_get_pull(pin)               - Get GPIO pull-up/down

  Aliases: set_gpio, get_gpio, set_gpio_dir, get_gpio_dir, etc.

            pin 1-8: GPIO 1-8
            pin   9: UART Tx
            pin  10: UART Rx
              value: True/False   for HIGH/LOW
          direction: True/False   for OUTPUT/INPUT
               pull: -1/0/1/2     for PULLDOWN/NO_PULL/PULLUP/BUS_KEEPER

PWM (Pulse Width Modulation):

   pwm(pin, [frequency], [duty])    - Setup PWM on GPIO pin
   pwm_set_duty_cycle(pin, duty)    - Set PWM duty cycle
   pwm_set_frequency(pin, freq)     - Set PWM frequency
   pwm_stop(pin)                    - Stop PWM on pin

  Aliases: set_pwm, set_pwm_duty_cycle, set_pwm_frequency, stop_pwm

             pin: 1-8       GPIO pins only
       frequency: 0.001Hz-62.5MHz default 1000Hz
      duty_cycle: 0.0-1.0   default 0.5 (50%)

WaveGen (Waveform Generator):

   wavegen_set_output(channel)      - Set output: DAC0, DAC1, TOP_RAIL, BOTTOM_RAIL
   wavegen_set_freq(hz)             - Set frequency (0.0001-10000 Hz)
   wavegen_set_wave(shape)          - Set waveform shape
   wavegen_set_amplitude(vpp)       - Set amplitude (0-16 Vpp)
   wavegen_set_offset(v)            - Set DC offset (-8 to +8 V)
   wavegen_start()                  - Start waveform generation
   wavegen_stop()                   - Stop waveform generation

  Getters: wavegen_get_output(), wavegen_get_freq(), wavegen_get_wave(),
           wavegen_get_amplitude(), wavegen_get_offset(), wavegen_is_running()

  Waveform constants: SINE, TRIANGLE, SAWTOOTH (RAMP), SQUARE

INA (Current/Power Monitor):

   ina_get_current(sensor)          - Read current in amps
   ina_get_voltage(sensor)          - Read shunt voltage
   ina_get_bus_voltage(sensor)      - Read bus voltage
   ina_get_power(sensor)            - Read power in watts

  Aliases: get_current, get_voltage, get_bus_voltage, get_power

             sensor: 0 or 1

Node Connections:

   connect(node1, node2)            - Connect two nodes
   disconnect(node1, node2)         - Disconnect nodes
   is_connected(node1, node2)       - Check if nodes are connected
   nodes_clear()                    - Clear all connections

         set node2 to -1 to disconnect everything connected to node1

Net Information:

   get_net_name(netNum)             - Get net name
   set_net_name(netNum, name)       - Set custom net name
   get_net_color(netNum)            - Get net color as 0xRRGGBB
   get_net_color_name(netNum)       - Get net color name
   set_net_color(netNum, color)     - Set net color by name or hex
   set_net_color_hsv(netNum, h, [s], [v]) - Set by HSV (auto-detects range)
   get_num_nets()                   - Get number of active nets
   get_num_bridges()                - Get number of bridges
   get_net_nodes(netNum)            - Get comma-separated node list
   get_bridge(bridgeIdx)            - Get bridge info tuple
   get_net_info(netNum)             - Get full net info as dict

  Colors: red, orange, yellow, green, cyan, blue, purple, pink, etc.
  HSV: h=0.0-1.0 or 0-255 (auto), s=0-1/0-255 (default max), v=0-1/0-255 (default 32)

Slot Management:

   nodes_save([slot])               - Save connections to slot
   nodes_discard()                  - Discard unsaved changes
   nodes_has_changes()              - Check for unsaved changes
   switch_slot(slot)                - Switch to different slot (0-7)
   CURRENT_SLOT                     - Get current slot number

  Context (controls persistence):
   context_toggle()                 - Toggle global/python mode
   context_get()                    - Get current mode name

OLED Display:

   oled_print("text")               - Display text
   oled_clear()                     - Clear display
   oled_connect()                   - Connect OLED
   oled_disconnect()                - Disconnect OLED

Probe Functions:

   probe_read([blocking=True])                - Read probe (default: blocking)
   read_probe([blocking=True])                - Read probe (default: blocking)
   probe_read_blocking()                      - Wait for probe touch (explicit)
   probe_read_nonblocking()                   - Check probe immediately (explicit)
   get_button([blocking], [consume])          - Get button (blocking=True, consume=False)
   probe_button([blocking], [consume])        - Get button (blocking=True, consume=False)
   check_button([consume])                    - Check button non-blocking (consume=False)
   probe_button_blocking([consume])           - Wait for button (consume=False)
   probe_button_nonblocking([consume])        - Check button immediate (consume=False)

  consume=False (default): Holding button returns same state (continuous control)
  consume=True: Each press detected once (one-shot detection)

  Probe Switch Functions:
   get_switch_position()                      - Get current switch position
   set_switch_position(pos)                   - Set switch position manually
   check_switch_position()                    - Check switch via current sensing

       Touch returns: ProbePad object (1-60, D13_PAD, TOP_RAIL_PAD, LOGO_PAD_TOP, etc.)
       Button returns: CONNECT, REMOVE, or NONE (front=connect, rear=remove)
       Switch returns: SWITCH_MEASURE (0), SWITCH_SELECT (1), SWITCH_UNKNOWN (-1)

Clickwheel (Rotary Encoder):

   clickwheel_get_position()                  - Get raw position counter
   clickwheel_reset_position()                - Reset position to 0
   clickwheel_get_direction([consume=True])   - Get direction event
   clickwheel_get_button()                    - Get button state
   clickwheel_is_initialized()                - Check if clickwheel is ready

  consume=True (default): Direction cleared after reading (one-shot detection)
  consume=False: Direction persists until consumed (can read multiple times)

  Direction returns: CLICKWHEEL_NONE (0), CLICKWHEEL_UP (1), CLICKWHEEL_DOWN (2)
  Button returns: CLICKWHEEL_IDLE (0), CLICKWHEEL_PRESSED (1), CLICKWHEEL_HELD (2),
                  CLICKWHEEL_RELEASED (3), CLICKWHEEL_DOUBLECLICKED (4)

Status:

   print_bridges()                  - Print all bridges
   print_paths()                    - Print path between nodes
   print_crossbars()                - Print crossbar array
   print_nets()                     - Print nets
   print_chip_status()              - Print chip status

Filesystem:

  jfs.open(path, mode)              - Open file
  jfs.read(file, size)              - Read from file
  jfs.write(file, data)             - Write to file
  jfs.close(file)                   - Close file
  jfs.exists(path)                  - Check if file exists
  jfs.listdir(path)                 - List directory
  jfs.mkdir(path)                   - Create directory
  jfs.remove(path)                  - Remove file
  jfs.rename(from, to)              - Rename file
  jfs.info()                        - Get filesystem info

Misc:

   arduino_reset()                  - Reset Arduino
   run_app(appName)                 - Run built-in app
   pause_core2(pause)               - Pause/unpause Core2 (True/False)
   send_raw(chip, x, y, set)        - Send raw data to crossbar chip
   force_service(name)              - Force run a specific service (e.g., "ProbeButton")
   force_service_by_index(idx)      - Force run service by index (faster)
   get_service_index(name)          - Get service index by name (cache for fast calls)

Examples (all functions available globally):

  dac_set(DAC0, 5.0)                         # Set DAC0 using node constant
  voltage = get_adc(1)                       # Read ADC1 using alias
  connect(TOP_RAIL, D13)                     # Connect using constants
  connect(4, 20)                             # Connect using numbers
  top_rail = node("TOP_RAIL")                # Create node object
  oled_print("Hello!")                       # Display text on OLED
  current = get_current(0)                   # Read current using alias
  set_gpio(1, True)                          # Set GPIO pin high
  pwm(1, 1000, 0.5)                          # 1kHz PWM, 50% duty
  wavegen_set_wave(SINE); wavegen_start()    # Start sine wave
  set_net_color(0, "red")                    # Color net 0 red
  set_net_color_hsv(1, 0.5)                  # Cyan net 1 (HSV hue)
  nodes_save()                               # Save current connections
  pad = probe_read()                         # Wait for probe touch
  button = get_button()                      # Wait for button press



>>> 
```



## The entire output of nodes_help()

```jython
>>> nodes_help()
Jumperless Node Reference
========================

NODE TYPES:
  Numbered:     1-60 (breadboard)
  Arduino:      D0-D13, A0-A7 (nano header)
  GPIO:         GPIO_1-GPIO_8 (routable GPIO)
  Power:        TOP_RAIL, BOTTOM_RAIL, GND
  DAC:          DAC0, DAC1 (analog outputs)
  ADC:          ADC0-ADC4, PROBE (analog inputs)
  Current:      ISENSE_PLUS, ISENSE_MINUS
  UART:         UART_TX, UART_RX
  Buffer:       BUFFER_IN, BUFFER_OUT

THREE WAYS TO USE NODES:

1. NUMBERS (direct breadboard holes):
   connect(1, 30)                     # Connect holes 1 and 30
   connect(15, 42)                    # Any number 1-60

2. STRINGS (case-insensitive names):
   connect("D13", "TOP_RAIL")         # Arduino pin to power rail
   connect("gpio_1", "adc0")          # GPIO to ADC (case-insensitive)
   connect("15", "dac1")              # Mix numbers and names

3. CONSTANTS (pre-defined objects):
   connect(TOP_RAIL, D13)            # Using imported constants
   connect(GPIO_1, A0)               # No quotes needed
   connect(DAC0, 25)                 # Mix constants and numbers

MIXED USAGE:
   my_pin = "D13"                    # Create node object from string
   connect(my_pin, TOP_RAIL)         # Use node object with constant
   oled_print(my_pin)                # Display shows 'D13'

COMMON ALIASES (many names work for same node):
   "TOP_RAIL" = "T_R"
   "GPIO_1" = "GPIO1" = "GP1"
   "DAC0" = "DAC_0"
   "UART_TX" = "TX"

NOTES:
  - String names are case-insensitive: "d13" = "D13" = "nAnO_d13"
  - Constants are case-sensitive: use D13, not d13
  - All three methods work in any function
```

